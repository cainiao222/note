* 2016/11
** 2016/11/03
*** 多年前就已经想到了，函数这个东西，输入参数有多个，输出参数只能有一个是不合理的，这一点虽然可以通过将多个值封装成一个对象传出来解决，但这种变通方案并不好。这着实是一个非常前卫的想法，这一想法现在已经被c#7.0给做了出来，它就是tuple。有了tuple，函数的输入与输出终于得到了完美的统一。我们可以使用tuple作为函数参数，作为返回值，用来构造对象，用来解构，极大的优化了编程模型，扩充了函数的概念。
*** 从最传统的c函数，发展到闭包是函数的第一次飞跃，发展到tuple又将是函数的另一大飞跃。
*** 实际上就是这么个原则，如果saat不可通行且没有信息，那么不显示saat，如果maat不可通行且没有信息，那么不显示maat。反过来说就是，如果saat可通行或有信息，那么显示saat，如果maat可通行或有信息，那么显示saat。就是这么个逻辑。
** 2016/11/04
*** 判断一个文件是否混乱有个非常简单的方法，直接看文件行数，如果一个文件的行数过多又是多人开发的话，那么毫无疑问这个文件会非常的混乱。
*** 牛逼的程序编写者总是很少使用for的，因为它的功能总可以被高阶函数所代替。
*** 写函数返回值的时候，如果这个返回值的逻辑比较复杂，最好还是先用个临时变量存起来，然后返回，这样调试的时候比较方便。
*** reduce函数是一个神器，它的处理形状是一个梯形，类似于filter，不过不同于filter只能取原值，它能取值的同时对值进行一下变换，类似于filter与map的结合体，而且由于它在处理的过程中并不会丢失idx，所以它是强于filter与map结合的。
*** DONE 使用块与图层两个维度拆分数据，然后按照块与层请求数据，将大的数据分别请求，然后合并后显示，这就是webeditor的数据请求原理，这实际上可以作为大数据请求的范本来启示我们。
** 2016/11/05
*** webpack为什么不能做成动态打包呢？就是检测到哪些文件有变化，只把那些文件重新打包到旧文件，以充分利用旧文件中已经打包好的东西。相当于是直接热更新打包好的文件，这样打包速度肯定会有大幅提高。
*** 能否很好的把业务逻辑与技术逻辑解耦，是一个非常重要的能力。
*** 高阶函数能够让我们更加专注于一个对象的问题求解，只要解决了一个问题，一个集合的问题也就解决了。
*** 为什么会有vh这个单位呢？实际上是为了解决相对于屏幕占用的问题，
*** min-XXX是为了避免容器内内容过少，max-XXX是为了避免容器内内容过多。这两个属性都是用于动态调整布局的。
*** 全量渲染与差分渲染。iD在history.js中的change函数中会使用iD.difference差分两个graph，针对差分数据进行重新渲染，以保证修改属性时渲染的性能。这一措施极大的较少了需要渲染的节点数目，提高了渲染性能。这一方法实际上非常类似于react中使用的dom节点差分算法，react的性能保证很大程度上源于这点。
*** 只要通过perform修改了属性，就会发出change事件，map会收到这个change事件然后重新刷新地图，在change中iD会使用iD.difference进行两个graph的差分，并发这个change事件继续派发出去到map，触发map重绘，这是一套非常清晰，可当做范例的数据流，非常值得学习钻研。实际上react/redux也是使用的这一套数据流，只暴露一个修改数据的接口，然后再修改的过程中发出UI重绘事件，修改数据后马上就在UI上展示了出来。
*** 随着代码越码越多，我的编程风格越来越像lisp，我发现很多以前被我当做lisp缺陷的东西并不是缺陷，而是高手才能明白的优点。比如：
	1. for。lisp原生并没有提供for语句，表面上看非常的不方便。但是实际上通过map/reduce/filter/some/every等高阶函数完全可以取代for（其实也有不可取代的时候，比如：
	    1.1. 从一个数组中找到指定的元素进行一定的处理。
		1.2. 处理一个非数组对象，比如处理链式DOM节点。
），而且用这种方式写出来的代码精简易读易维护，比直接使用for写出来的代码不知道强多少倍。
	1. 没有=号，总是产生新的数据。
	2. 真正有副作用的地方使用感叹号明确区分，将有副作用的代码与没有副作用的代码区分开。
*** 实际上实现纯函数式编程是可能的，而且具有很多杀手级的好处。if，for这些语句是根本不必要的，完全可以用纯函数直接实现，而且这样实现出来的组合性更好。
** 2016/11/06
*** 编程过程中除了低耦合原则外，还有个很容易被忽视的原则就是高内聚，这一原则要求关联性很强的代码尽量放在一起，或者尽量放得比较近，比如在一个很长的函数中，变量的声明与变量使用最好放得比较近，也是基于这个原则。比如使用类组织代码，同一个类中的代码就是内聚比较强的代码。
*** 业务逻辑应该尽可能的耦合性低，为了修改互不影响；逻辑层应该尽可能的耦合性高，为了复用。
*** TODO 将数据操作与渲染分开？
*** 其实每个人都有自己的编程风格，要形成自己的编程风格，不要随波逐流。
*** 应该尽可能的表达出自己的优势部分，比如我的优势就是代码极客，如果问起应该有意识的把别人往这上面引导，只有这样别人才会记住你。
*** 且是减的关系，或是加的关系。一旦逻辑出现了偏差，一般情况下在原有逻辑的基础上加上一个或或者且条件就可以使得逻辑得到纠正，无需管之前的逻辑是什么意思。
*** 在或逻辑里面，总是为false的是不用管的，在且逻辑里面，总是为true的逻辑是不用管的。
*** what is setup？setup is a precedure which render ui and add event handler.By do this,we can interactive with the given ui,change the ui state and save state to store.
*** ui组件渲染一般遵循这样的规律，先设置各种参数，设置好后返回UI对象的渲染函数供外界调用。
** 2016/11/07
*** 只要不显示禁止信息，门禁信息也肯定不会显示。只有禁止信息显示，门禁信息才有可能显示。如果门禁信息显示，且发现这个门禁信息是无效的，这个门禁才会置灰。
*** 是否展示，是否置灰，是个非常复杂的逻辑，很有必要单独拎出来处理。
*** mode是将behavior、action、operation结合起来的东西，它提供一个环境与状态，用来给你组装实现功能。
*** 延迟计算很多时候是有用的，因为很多运算也许根本不会用到。
*** draw是前端非常复杂的逻辑，非常有必要单独抽象出来。
*** 要保持代码的可维护性，我们需要控制函数的行数，同理，我们也需要控制文件的行数。一般函数不要超过一屏，文件不要超过500行。一旦超过，可维护性就会极大下降。
*** 为很么要写小函数、无状态函数？还有一个原因是好拆分，当你想将一个文件拆分成几个文件时，你就会体会到写小函数，无状态函数的好处了，还拆分，重新组合起来也会非常方便。
** 2016/11/08
*** 高阶函数有什么作用？
	1. 函数参数调整。增加参数、减少参数、修改参数。
	2. 函数返回值调整。改变返回值、续处理返回值。
	3. 函数调用调整。比如让它能够处理数组对象，map、reduce、filter都属于此类。
	总之，高阶函数除了不能直接修改函数实现以外，几乎能够做任何事。
*** In functional programming, fold (also termed reduce, accumulate, aggregate, compress, or inject) refers to a family of higher-order functions that analyze a recursive data structure and through use of a given combining operation, recombine the results of recursively processing its constituent parts, building up a return value.   --wikipedia 《fold》
*** fold也叫reduce，真的是一个神器。
*** TODO immutable data is very important.
** 2016/11/09
*** 不要不停的修改同一个变量，变量创造出来了以后最好不要修改，如果真要修改，应该创建一个新的变量。
*** 把一段关联性很强的逻辑放在两个不同的地方就是一场噩梦，因为你很难搞清楚一个地方处理了什么，另一个地方还需要处理什么。
*** enumerate  --> filter --> map --> accumulate(reduce)
	enumerate --> map --> filter --> accumulate(reduce)
	这是数据处理的两种通用模式，基本上所有的数据处理都可以使用这一模型来处理。
*** 递归既可以处理链表，也可以处理树，
*** 所有面板都应该有是否显示，是否禁用的状态，便于总体控制。
*** 自己写一个自认为数据流最优秀，最合理的框架，加深对目前主流框架的理解。
*** redux中，actions既是数据的起点也是数据的终点。
