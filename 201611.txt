* 2016/11
** 2016/11/03
*** 多年前就已经想到了，函数这个东西，输入参数有多个，输出参数只能有一个是不合理的，这一点虽然可以通过将多个值封装成一个对象传出来解决，但这种变通方案并不好。这着实是一个非常前卫的想法，这一想法现在已经被c#7.0给做了出来，它就是tuple。有了tuple，函数的输入与输出终于得到了完美的统一。我们可以使用tuple作为函数参数，作为返回值，用来构造对象，用来解构，极大的优化了编程模型，扩充了函数的概念。
*** 从最传统的c函数，发展到闭包是函数的第一次飞跃，发展到tuple又将是函数的另一大飞跃。
*** 实际上就是这么个原则，如果saat不可通行且没有信息，那么不显示saat，如果maat不可通行且没有信息，那么不显示maat。反过来说就是，如果saat可通行或有信息，那么显示saat，如果maat可通行或有信息，那么显示saat。就是这么个逻辑。
** 2016/11/04
*** 判断一个文件是否混乱有个非常简单的方法，直接看文件行数，如果一个文件的行数过多又是多人开发的话，那么毫无疑问这个文件会非常的混乱。
*** 牛逼的程序编写者总是很少使用for的，因为它的功能总可以被高阶函数所代替。
*** 写函数返回值的时候，如果这个返回值的逻辑比较复杂，最好还是先用个临时变量存起来，然后返回，这样调试的时候比较方便。
*** reduce函数是一个神器，它的处理形状是一个梯形，类似于filter，不过不同于filter只能取原值，它能取值的同时对值进行一下变换，类似于filter与map的结合体，而且由于它在处理的过程中并不会丢失idx，所以它是强于filter与map结合的。
*** DONE 使用块与图层两个维度拆分数据，然后按照块与层请求数据，将大的数据分别请求，然后合并后显示，这就是webeditor的数据请求原理，这实际上可以作为大数据请求的范本来启示我们。
** 2016/11/05
*** webpack为什么不能做成动态打包呢？就是检测到哪些文件有变化，只把那些文件重新打包到旧文件，以充分利用旧文件中已经打包好的东西。相当于是直接热更新打包好的文件，这样打包速度肯定会有大幅提高。
*** 能否很好的把业务逻辑与技术逻辑解耦，是一个非常重要的能力。
*** 高阶函数能够让我们更加专注于一个对象的问题求解，只要解决了一个问题，一个集合的问题也就解决了。
*** 为什么会有vh这个单位呢？实际上是为了解决相对于屏幕占用的问题，
*** min-XXX是为了避免容器内内容过少，max-XXX是为了避免容器内内容过多。这两个属性都是用于动态调整布局的。
*** 全量渲染与差分渲染。iD在history.js中的change函数中会使用iD.difference差分两个graph，针对差分数据进行重新渲染，以保证修改属性时渲染的性能。这一措施极大的较少了需要渲染的节点数目，提高了渲染性能。这一方法实际上非常类似于react中使用的dom节点差分算法，react的性能保证很大程度上源于这点。
*** 只要通过perform修改了属性，就会发出change事件，map会收到这个change事件然后重新刷新地图，在change中iD会使用iD.difference进行两个graph的差分，并发这个change事件继续派发出去到map，触发map重绘，这是一套非常清晰，可当做范例的数据流，非常值得学习钻研。实际上react/redux也是使用的这一套数据流，只暴露一个修改数据的接口，然后再修改的过程中发出UI重绘事件，修改数据后马上就在UI上展示了出来。
*** 随着代码越码越多，我的编程风格越来越像lisp，我发现很多以前被我当做lisp缺陷的东西并不是缺陷，而是高手才能明白的优点。比如：
	1. for。lisp原生并没有提供for语句，表面上看非常的不方便。但是实际上通过map/reduce/filter/some/every等高阶函数完全可以取代for（其实也有不可取代的时候，比如：
	    1.1. 从一个数组中找到指定的元素进行一定的处理。
		1.2. 处理一个非数组对象，比如处理链式DOM节点。
），而且用这种方式写出来的代码精简易读易维护，比直接使用for写出来的代码不知道强多少倍。
	1. 没有=号，总是产生新的数据。
	2. 真正有副作用的地方使用感叹号明确区分，将有副作用的代码与没有副作用的代码区分开。
*** 实际上实现纯函数式编程是可能的，而且具有很多杀手级的好处。if，for这些语句是根本不必要的，完全可以用纯函数直接实现，而且这样实现出来的组合性更好。
** 2016/11/06
*** 编程过程中除了低耦合原则外，还有个很容易被忽视的原则就是高内聚，这一原则要求关联性很强的代码尽量放在一起，或者尽量放得比较近，比如在一个很长的函数中，变量的声明与变量使用最好放得比较近，也是基于这个原则。比如使用类组织代码，同一个类中的代码就是内聚比较强的代码。
*** 业务逻辑应该尽可能的耦合性低，为了修改互不影响；逻辑层应该尽可能的耦合性高，为了复用。
*** TODO 将数据操作与渲染分开？
*** 其实每个人都有自己的编程风格，要形成自己的编程风格，不要随波逐流。
*** 应该尽可能的表达出自己的优势部分，比如我的优势就是代码极客，如果问起应该有意识的把别人往这上面引导，只有这样别人才会记住你。
*** 且是减的关系，或是加的关系。一旦逻辑出现了偏差，一般情况下在原有逻辑的基础上加上一个或或者且条件就可以使得逻辑得到纠正，无需管之前的逻辑是什么意思。
*** 在或逻辑里面，总是为false的是不用管的，在且逻辑里面，总是为true的逻辑是不用管的。
*** what is setup？setup is a precedure which render ui and add event handler.By do this,we can interactive with the given ui,change the ui state and save state to store.
*** ui组件渲染一般遵循这样的规律，先设置各种参数，设置好后返回UI对象的渲染函数供外界调用。
** 2016/11/07
*** 只要不显示禁止信息，门禁信息也肯定不会显示。只有禁止信息显示，门禁信息才有可能显示。如果门禁信息显示，且发现这个门禁信息是无效的，这个门禁才会置灰。
*** 是否展示，是否置灰，是个非常复杂的逻辑，很有必要单独拎出来处理。
*** mode是将behavior、action、operation结合起来的东西，它提供一个环境与状态，用来给你组装实现功能。
*** 延迟计算很多时候是有用的，因为很多运算也许根本不会用到。
*** draw是前端非常复杂的逻辑，非常有必要单独抽象出来。
*** 要保持代码的可维护性，我们需要控制函数的行数，同理，我们也需要控制文件的行数。一般函数不要超过一屏，文件不要超过500行。一旦超过，可维护性就会极大下降。
*** 为很么要写小函数、无状态函数？还有一个原因是好拆分，当你想将一个文件拆分成几个文件时，你就会体会到写小函数，无状态函数的好处了，还拆分，重新组合起来也会非常方便。
** 2016/11/08
*** 高阶函数有什么作用？
	1. 函数参数调整。增加参数、减少参数、修改参数。
	2. 函数返回值调整。改变返回值、续处理返回值。
	3. 函数调用调整。比如让它能够处理数组对象，map、reduce、filter都属于此类。
	总之，高阶函数除了不能直接修改函数实现以外，几乎能够做任何事。
*** In functional programming, fold (also termed reduce, accumulate, aggregate, compress, or inject) refers to a family of higher-order functions that analyze a recursive data structure and through use of a given combining operation, recombine the results of recursively processing its constituent parts, building up a return value.   --wikipedia 《fold》
*** fold也叫reduce，真的是一个神器。
*** TODO immutable data is very important.
** 2016/11/09
*** 不要不停的修改同一个变量，变量创造出来了以后最好不要修改，如果真要修改，应该创建一个新的变量。
*** 把一段关联性很强的逻辑放在两个不同的地方就是一场噩梦，因为你很难搞清楚一个地方处理了什么，另一个地方还需要处理什么。
*** enumerate  --> filter --> map --> accumulate(reduce)
	enumerate --> map --> filter --> accumulate(reduce)
	这是数据处理的两种通用模式，基本上所有的数据处理都可以使用这一模型来处理。
*** 递归既可以处理链表，也可以处理树，
*** 所有面板都应该有是否显示，是否禁用的状态，便于总体控制。
*** 自己写一个自认为数据流最优秀，最合理的框架，加深对目前主流框架的理解。
*** redux中，actions既是数据的起点也是数据的终点。
** 2016/11/10
*** DONE 到底应该如何合理的使用事件呢？实际上前人已经给我们指出了明路，即UI相关的处理应该抛事件，也即我们应该将用户在界面上的一些操作抛事件，这样UI就会比较纯净，所有的操作都能够被挪到UI外面去处理，当我们想替换UI的时候，只要重新对接下事件就可以完成UI替换了。这一方式还有个听起来非常屌的名字叫做模块化，模块化离不开事件，事件是模块化的最后一环。
*** Redux是如何完成ui、modal、data解耦的呢，答案是使用事件。ui的事件往上抛使用的是事件（dispatch）、modal层的事件处理使用的实际上也是事件（action、reduce）。
*** TODO Redux的核心是什么，是个reduce函数吗？为什么叫reducer?
** 2016/11/11
*** 回调函数还有个非常重要的作用就是处理外层函数的处理结果，这一作用与使用返回值作用类似，但它有些独一无二的优点，比如：
	1. 能够用来处理异步，对异步调用的返回值进行处理。这是这一方法最常见的用法。
	2. 能够使用闭包来保存状态，构造出新的函数用于续处理，比如id中有很多这种用法。
	3. 能够对函数的参数进行进一步封装，加上我们自己需要的信息抛给函数调用者。这常被各种事件派发器所使用。
	这一方法唯一的缺点也许就是写出来的代码可读性没有使用函数的返回值来得好，多层嵌套以后会成为callback hell。
*** 使用纯函数 + 不可变数据还有个好处就是你可以非常容易的操控处理过程，增加、减少，代码的可组合性大大提高。
*** new Set(arr)最简单的数组去重方法。
** 2016/11/15
*** bind实际上也只不过是一个高阶函数，它对传给它的函数进行了下二次封装，使用闭包保存了this与部分参数，然后使用这些参数重新调用了传给它的函数，从而实现了patially applied function的目的。
*** TODO 研究下bind的实现。
*** 不要使用一个函数做完整件事，要将事情划分为几个过程，然后一个个串联起来去做事，这样写出来的代码可组合性会比较好。就好比browserify与webpack，虽然webpack使用起来简单方便，但若论灵活性与可组合性，它真的不如browserify。
*** 函数本身是无状态的，但很多时候我们需要有状态的函数，怎么办呢？使用闭包，将状态写在外面，将需要状态的函数返回，这样函数就变成了有状态的。通过这种方式，我们能够将状态对外隐藏，通过我们自己的函数统一管理，这样不容易出错，代码也会非常清晰易读。
*** OpenLayers3的API真的是能够给人一种美的享受。虽然API很多，但它通过合理的分类使得我们总能够直接猜出对应的API在那个地方，然后在对应位置一查就可以找到，十分优雅简练。颇为贴心的是，API文档上甚至直接标出了这个函数是在什么地方实现的，非常好用。
*** 编程的过程中应该尽早将错误的数据给滤掉，这样数据就会比较纯净，处理起来就会比较简单，不用各种特殊情况判断。
*** REPL模式能够带来极其强大的生产力，我们只需要在控制台不断的敲命令就可以直接在界面上看到结果，配合自动补全，非常有利于学习，可以很快就将API掌握的七七八八。
*** bootstrap是什么？可以把它理解为一组css规范，它会告诉你各种组件应该怎么写，哪些用css，哪些用js，加什么class，用什么属性等。当你要写一个新的组件而你不知从何下手的时候，可以到bootstrap文档中去寻找灵感。
*** 从bootstrap的示例中其实我们可以感觉出css class的大致用法———— 一个css类就是一个函数，它不应该用来表示一个页面的某个部分，更多的时候它用来表示给某个dom元素添加上一个功能。它本身是使用less写的，所以它也可以用来作为less的编写规范。
*** 写代码的过程中，我们经常会面对两种命名问题。即按照上层的逻辑来命名还是按照下层逻辑来命名。实际上两种命名方式都应该保留。按照上层命名代码结构会比较清晰，按照下层逻辑来命名复用会比较方便。我们所需要是一个中间层来组合这两个部分，形成一个不管是可读性还是可复用性都比较强的代码结构。
*** OpenLayer3启示：
	1. interaction中有数据，可以从这个对象中获取这个交互关联的数据。
	2. 每个layer有自己的样式与自己的数据源，我们在layer上操作会使用我们给定的样式并且绘制出的数据会被同步到数据源。
** 2016/11/16
*** objA.fn(arg1,arg2...)这种调用方式实际上等价于fn(objA,arg1,arg2...)。objA一般叫做this，它实际上也就是一个普通的输入参数而已。
*** 函数式编程确实非常好调试，由于它对原系统侵入小，一旦发生问题的时候需要查看的地方就非常小，改起来当然非常简单。
*** DONE 纯函数能够缓存以提高效率，这一特性非常震撼。这不就是我一直以来担心的函数式编程的效率问题的解决方案吗？
*** ES6的解构赋值是非常强大的东西，它有很多非常强大的作用：
	1. 一次从一个对象或数组中提取多个值，而不用一个个的取。
	2. 作为函数的参数使用，直接从一个对象中提取多个值，使用这种提取方法写出来的函数依赖于配置中的哪些值就非常清晰了。
	3. 作为函数的返回值使用，类似于tuple，相当于变相允许了一个函数返回多个值。
*** every interaction should have a event handler to handle the middle events,this should become a mode of interactions.
*** What is context?Context is a house to place data.Data must be placed in a place so that we can clean it at proper time.If we can't,memory leak happen. The best house to place data is a little house,the more little the more better.We can't manage a state in a big house because big house has various state,we can't handle them in a way.
