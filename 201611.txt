* 2016/11
** 2016/11/03
*** 多年前就已经想到了，函数这个东西，输入参数有多个，输出参数只能有一个是不合理的，这一点虽然可以通过将多个值封装成一个对象传出来解决，但这种变通方案并不好。这着实是一个非常前卫的想法，这一想法现在已经被c#7.0给做了出来，它就是tuple。有了tuple，函数的输入与输出终于得到了完美的统一。我们可以使用tuple作为函数参数，作为返回值，用来构造对象，用来解构，极大的优化了编程模型，扩充了函数的概念。
*** 从最传统的c函数，发展到闭包是函数的第一次飞跃，发展到tuple又将是函数的另一大飞跃。
*** 实际上就是这么个原则，如果saat不可通行且没有信息，那么不显示saat，如果maat不可通行且没有信息，那么不显示maat。反过来说就是，如果saat可通行或有信息，那么显示saat，如果maat可通行或有信息，那么显示saat。就是这么个逻辑。
** 2016/11/04
*** 判断一个文件是否混乱有个非常简单的方法，直接看文件行数，如果一个文件的行数过多又是多人开发的话，那么毫无疑问这个文件会非常的混乱。
*** 牛逼的程序编写者总是很少使用for的，因为它的功能总可以被高阶函数所代替。
*** 写函数返回值的时候，如果这个返回值的逻辑比较复杂，最好还是先用个临时变量存起来，然后返回，这样调试的时候比较方便。
*** reduce函数是一个神器，它的处理形状是一个梯形，类似于filter，不过不同于filter只能取原值，它能取值的同时对值进行一下变换，类似于filter与map的结合体，而且由于它在处理的过程中并不会丢失idx，所以它是强于filter与map结合的。
*** DONE 使用块与图层两个维度拆分数据，然后按照块与层请求数据，将大的数据分别请求，然后合并后显示，这就是webeditor的数据请求原理，这实际上可以作为大数据请求的范本来启示我们。
** 2016/11/05
*** webpack为什么不能做成动态打包呢？就是检测到哪些文件有变化，只把那些文件重新打包到旧文件，以充分利用旧文件中已经打包好的东西。相当于是直接热更新打包好的文件，这样打包速度肯定会有大幅提高。
*** 能否很好的把业务逻辑与技术逻辑解耦，是一个非常重要的能力。
*** 高阶函数能够让我们更加专注于一个对象的问题求解，只要解决了一个问题，一个集合的问题也就解决了。
*** 为什么会有vh这个单位呢？实际上是为了解决相对于屏幕占用的问题，
*** min-XXX是为了避免容器内内容过少，max-XXX是为了避免容器内内容过多。这两个属性都是用于动态调整布局的。
*** 全量渲染与差分渲染。iD在history.js中的change函数中会使用iD.difference差分两个graph，针对差分数据进行重新渲染，以保证修改属性时渲染的性能。这一措施极大的较少了需要渲染的节点数目，提高了渲染性能。这一方法实际上非常类似于react中使用的dom节点差分算法，react的性能保证很大程度上源于这点。
*** 只要通过perform修改了属性，就会发出change事件，map会收到这个change事件然后重新刷新地图，在change中iD会使用iD.difference进行两个graph的差分，并发这个change事件继续派发出去到map，触发map重绘，这是一套非常清晰，可当做范例的数据流，非常值得学习钻研。实际上react/redux也是使用的这一套数据流，只暴露一个修改数据的接口，然后再修改的过程中发出UI重绘事件，修改数据后马上就在UI上展示了出来。
*** 随着代码越码越多，我的编程风格越来越像lisp，我发现很多以前被我当做lisp缺陷的东西并不是缺陷，而是高手才能明白的优点。比如：
	1. for。lisp原生并没有提供for语句，表面上看非常的不方便。但是实际上通过map/reduce/filter/some/every等高阶函数完全可以取代for（其实也有不可取代的时候，比如：
	    1.1. 从一个数组中找到指定的元素进行一定的处理。
		1.2. 处理一个非数组对象，比如处理链式DOM节点。
），而且用这种方式写出来的代码精简易读易维护，比直接使用for写出来的代码不知道强多少倍。
	1. 没有=号，总是产生新的数据。
	2. 真正有副作用的地方使用感叹号明确区分，将有副作用的代码与没有副作用的代码区分开。
*** 实际上实现纯函数式编程是可能的，而且具有很多杀手级的好处。if，for这些语句是根本不必要的，完全可以用纯函数直接实现，而且这样实现出来的组合性更好。
** 2016/11/06
*** 编程过程中除了低耦合原则外，还有个很容易被忽视的原则就是高内聚，这一原则要求关联性很强的代码尽量放在一起，或者尽量放得比较近，比如在一个很长的函数中，变量的声明与变量使用最好放得比较近，也是基于这个原则。比如使用类组织代码，同一个类中的代码就是内聚比较强的代码。
*** 业务逻辑应该尽可能的耦合性低，为了修改互不影响；逻辑层应该尽可能的耦合性高，为了复用。
*** TODO 将数据操作与渲染分开？
*** 其实每个人都有自己的编程风格，要形成自己的编程风格，不要随波逐流。
*** 应该尽可能的表达出自己的优势部分，比如我的优势就是代码极客，如果问起应该有意识的把别人往这上面引导，只有这样别人才会记住你。
*** 且是减的关系，或是加的关系。一旦逻辑出现了偏差，一般情况下在原有逻辑的基础上加上一个或或者且条件就可以使得逻辑得到纠正，无需管之前的逻辑是什么意思。
*** 在或逻辑里面，总是为false的是不用管的，在且逻辑里面，总是为true的逻辑是不用管的。
*** what is setup？setup is a precedure which render ui and add event handler.By do this,we can interactive with the given ui,change the ui state and save state to store.
*** ui组件渲染一般遵循这样的规律，先设置各种参数，设置好后返回UI对象的渲染函数供外界调用。
** 2016/11/07
*** 只要不显示禁止信息，门禁信息也肯定不会显示。只有禁止信息显示，门禁信息才有可能显示。如果门禁信息显示，且发现这个门禁信息是无效的，这个门禁才会置灰。
*** 是否展示，是否置灰，是个非常复杂的逻辑，很有必要单独拎出来处理。
*** mode是将behavior、action、operation结合起来的东西，它提供一个环境与状态，用来给你组装实现功能。
*** 延迟计算很多时候是有用的，因为很多运算也许根本不会用到。
*** draw是前端非常复杂的逻辑，非常有必要单独抽象出来。
*** 要保持代码的可维护性，我们需要控制函数的行数，同理，我们也需要控制文件的行数。一般函数不要超过一屏，文件不要超过500行。一旦超过，可维护性就会极大下降。
*** 为很么要写小函数、无状态函数？还有一个原因是好拆分，当你想将一个文件拆分成几个文件时，你就会体会到写小函数，无状态函数的好处了，还拆分，重新组合起来也会非常方便。
** 2016/11/08
*** 高阶函数有什么作用？
	1. 函数参数调整。增加参数、减少参数、修改参数。
	2. 函数返回值调整。改变返回值、续处理返回值。
	3. 函数调用调整。比如让它能够处理数组对象，map、reduce、filter都属于此类。
	总之，高阶函数除了不能直接修改函数实现以外，几乎能够做任何事。
*** In functional programming, fold (also termed reduce, accumulate, aggregate, compress, or inject) refers to a family of higher-order functions that analyze a recursive data structure and through use of a given combining operation, recombine the results of recursively processing its constituent parts, building up a return value.   --wikipedia 《fold》
*** fold也叫reduce，真的是一个神器。
*** TODO immutable data is very important.
** 2016/11/09
*** 不要不停的修改同一个变量，变量创造出来了以后最好不要修改，如果真要修改，应该创建一个新的变量。
*** 把一段关联性很强的逻辑放在两个不同的地方就是一场噩梦，因为你很难搞清楚一个地方处理了什么，另一个地方还需要处理什么。
*** enumerate  --> filter --> map --> accumulate(reduce)
	enumerate --> map --> filter --> accumulate(reduce)
	这是数据处理的两种通用模式，基本上所有的数据处理都可以使用这一模型来处理。
*** 递归既可以处理链表，也可以处理树，
*** 所有面板都应该有是否显示，是否禁用的状态，便于总体控制。
*** 自己写一个自认为数据流最优秀，最合理的框架，加深对目前主流框架的理解。
*** redux中，actions既是数据的起点也是数据的终点。
** 2016/11/10
*** DONE 到底应该如何合理的使用事件呢？实际上前人已经给我们指出了明路，即UI相关的处理应该抛事件，也即我们应该将用户在界面上的一些操作抛事件，这样UI就会比较纯净，所有的操作都能够被挪到UI外面去处理，当我们想替换UI的时候，只要重新对接下事件就可以完成UI替换了。这一方式还有个听起来非常屌的名字叫做模块化，模块化离不开事件，事件是模块化的最后一环。
*** Redux是如何完成ui、modal、data解耦的呢，答案是使用事件。ui的事件往上抛使用的是事件（dispatch）、modal层的事件处理使用的实际上也是事件（action、reduce）。
*** TODO Redux的核心是什么，是个reduce函数吗？为什么叫reducer?
** 2016/11/11
*** 回调函数还有个非常重要的作用就是处理外层函数的处理结果，这一作用与使用返回值作用类似，但它有些独一无二的优点，比如：
	1. 能够用来处理异步，对异步调用的返回值进行处理。这是这一方法最常见的用法。
	2. 能够使用闭包来保存状态，构造出新的函数用于续处理，比如id中有很多这种用法。
	3. 能够对函数的参数进行进一步封装，加上我们自己需要的信息抛给函数调用者。这常被各种事件派发器所使用。
	这一方法唯一的缺点也许就是写出来的代码可读性没有使用函数的返回值来得好，多层嵌套以后会成为callback hell。
*** 使用纯函数 + 不可变数据还有个好处就是你可以非常容易的操控处理过程，增加、减少，代码的可组合性大大提高。
*** new Set(arr)最简单的数组去重方法。
** 2016/11/15
*** bind实际上也只不过是一个高阶函数，它对传给它的函数进行了下二次封装，使用闭包保存了this与部分参数，然后使用这些参数重新调用了传给它的函数，从而实现了patially applied function的目的。
*** TODO 研究下bind的实现。
*** 不要使用一个函数做完整件事，要将事情划分为几个过程，然后一个个串联起来去做事，这样写出来的代码可组合性会比较好。就好比browserify与webpack，虽然webpack使用起来简单方便，但若论灵活性与可组合性，它真的不如browserify。
*** 函数本身是无状态的，但很多时候我们需要有状态的函数，怎么办呢？使用闭包，将状态写在外面，将需要状态的函数返回，这样函数就变成了有状态的。通过这种方式，我们能够将状态对外隐藏，通过我们自己的函数统一管理，这样不容易出错，代码也会非常清晰易读。
*** OpenLayers3的API真的是能够给人一种美的享受。虽然API很多，但它通过合理的分类使得我们总能够直接猜出对应的API在那个地方，然后在对应位置一查就可以找到，十分优雅简练。颇为贴心的是，API文档上甚至直接标出了这个函数是在什么地方实现的，非常好用。
*** 编程的过程中应该尽早将错误的数据给滤掉，这样数据就会比较纯净，处理起来就会比较简单，不用各种特殊情况判断。
*** REPL模式能够带来极其强大的生产力，我们只需要在控制台不断的敲命令就可以直接在界面上看到结果，配合自动补全，非常有利于学习，可以很快就将API掌握的七七八八。
*** bootstrap是什么？可以把它理解为一组css规范，它会告诉你各种组件应该怎么写，哪些用css，哪些用js，加什么class，用什么属性等。当你要写一个新的组件而你不知从何下手的时候，可以到bootstrap文档中去寻找灵感。
*** 从bootstrap的示例中其实我们可以感觉出css class的大致用法———— 一个css类就是一个函数，它不应该用来表示一个页面的某个部分，更多的时候它用来表示给某个dom元素添加上一个功能。它本身是使用less写的，所以它也可以用来作为less的编写规范。
*** 写代码的过程中，我们经常会面对两种命名问题。即按照上层的逻辑来命名还是按照下层逻辑来命名。实际上两种命名方式都应该保留。按照上层命名代码结构会比较清晰，按照下层逻辑来命名复用会比较方便。我们所需要是一个中间层来组合这两个部分，形成一个不管是可读性还是可复用性都比较强的代码结构。
*** OpenLayer3启示：
	1. interaction中有数据，可以从这个对象中获取这个交互关联的数据。
	2. 每个layer有自己的样式与自己的数据源，我们在layer上操作会使用我们给定的样式并且绘制出的数据会被同步到数据源。
** 2016/11/16
*** objA.fn(arg1,arg2...)这种调用方式实际上等价于fn(objA,arg1,arg2...)。objA一般叫做this，它实际上也就是一个普通的输入参数而已。
*** 函数式编程确实非常好调试，由于它对原系统侵入小，一旦发生问题的时候需要查看的地方就非常小，改起来当然非常简单。
*** DONE 纯函数能够缓存以提高效率，这一特性非常震撼。这不就是我一直以来担心的函数式编程的效率问题的解决方案吗？
*** ES6的解构赋值是非常强大的东西，它有很多非常强大的作用：
	1. 一次从一个对象或数组中提取多个值，而不用一个个的取。
	2. 作为函数的参数使用，直接从一个对象中提取多个值，使用这种提取方法写出来的函数依赖于配置中的哪些值就非常清晰了。
	3. 作为函数的返回值使用，类似于tuple，相当于变相允许了一个函数返回多个值。
*** every interaction should have a event handler to handle the middle events,this should become a mode of interactions.
*** What is context?Context is a house to place data.Data must be placed in a place so that we can clean it at proper time.If we can't,memory leak happen. The best house to place data is a little house,the more little the more better.We can't manage a state in a big house because big house has various state,we can't handle them in a way.And when the house is destory,the variables in the house will be cleaned together.No memory leak happen.The more bigger the house,the more hard to collect the data,so we should be sure not place data in big house.
*** DONE Data is lonely,they need a house to live,whether object or function.
*** An object can fire various of events and the object can handle them outside.In other words,events is also a method to continue handle the rest things.
*** 到目前为止，我已经掌握的续处理方法有三种：
	1. 使用返回值，将处理结果作为返回值返回进行续处理。这是最常见的续处理方法。
	2. 使用回调函数作为参数续处理。这是异步编程情况下的常见用法。
	3. 使用事件。这种方式具有最好的解耦效果，在各种框架中使用的非常普遍。
*** 自己实现一套API不用别人已经提供好的API的缺陷就是很多别人已经封好的数据你是拿不到的，你需要自己去组装一套数据。比如OpenLayers中的坐标。
** 2016/11/17
*** Webpage is just a area in the screen.We can use BFC to create a new plattle at any place so we can draw on it.
*** TODO 要形成自己的代码库，包括函数库、组件库、样式库。
*** 匈牙利命令法实际上是一个非常好的额东西，但这一好习惯在前端不怎么收到重视，但也不是没有，比如bootstrap中的btn-、dropdown-、input-、nav-等等这些前缀实际上就是匈牙利命令法的变体。
*** 实际上类名也可以看成是匈牙利命名法的一个变种，通过类名表示类型，这样我们寻找一个东西的时候
*** 为什么jquery的Ajax会被Promise取代，因为Ajax毕竟只是数据，不是函数，可组合性太差。
*** DONE 前端开发的过程中常常会碰到与后端进度不一致的情况，这个时候只要将请求地址改成本地，就可以照常收发请求了，等后端好了之后直接切下地址就好了。
*** TODO js的数组有reduce方法，但对象却没有reduce方法，这是可以做文章的。
*** TODO js的数组与对象在很多操作上是不同的，如果能够统一这两种对象，那么这门语言的优美性又能上升一个台阶。
*** OpenLayer的事件体系是这样设计的，map统管全局的事件，然后很多interaction有自己的小事件，一般情况下直接使用小事件就好了，但是如果小事件不能满足需要了，这时就需要使用map上的大事件了。其实不止OpenLayer，所有事件体系都应该这样设计，先用小事件，再用大事件。
*** 浏览器的地址栏只能发送GET请求，如果要发送POST请求，使用Jquery的post方法就好了,这也是一个非常好的调试方法。
** 2016/11/18
*** 一个函数调用中如果派发了事件，那么这个函数就有副作用了。
*** 使用B.prototype = new A()这种方式实现继承可读性很差，最好还是抽个函数。更进一步，可以抽一个关键字用来继承，ES6就是这么干的。
*** js的事件是怎么实现的？实际上很简单，事件就是一个对象，以事件类型为key，以callback数组为value，这个对象被放在事件对象原型的
*** 文件实际上是一个隐式的作用域，新建一个文件就等于新建了一个作用域。
*** 在函数与函数中间穿插中间处理，这是极其常见也极其重要的编程技巧。比如：
	1. requirejs的define与require。通过在define与require间穿插中间过程，维护当前已经加载的文件信息，以达到管理文件加载的目的。
	2. React的数据流。通过组件的构造函数将数据流入组件，然后在中间完成一些组件渲染与UI交互之类的操作，最后将数据通过回调函数流出来。
*** 写UI组件的时候，应该将尽可能少的数据写在UI上，因为写在UI上的数据不可避免的需要同步到js里，同时js里的数据也需要同步到UI，这样就会形成双向数据流，同步起来非常复杂。正确的解法是UI上应该尽可能的只写常量数据，凡是可能会变的数据统统写到js对象里。这样你只需要将js数据同步到UI上就完成了两端的数据同步，大大降低了维护负担。
*** 编程过程中，数据流是极其重要的东西，理解了数据流，程序就理解了一大半。一切软件系统，其数据流都差不多————整体单向，部分双向。我们要控制双向数据流中逆向流动的数据的量，一旦量大了，维护起来就会非常的复杂。不管是同步的也好，异步的也好，都逃不开这个规律。
*** 事件是最常用的处理异步消息的方式。
** 2016/11/21
*** js中普通对象的key是可以是对象的，这就大大扩充了对象的使用范围，可以用对象作为key，然后value纪录这个对象的状态。
*** 对于重复计算，缓存计算结果对计算速度的提升具有极其重要的意义，典型的例子就是裴波那切数列，即"var fibonacci = _.memoize(function(n) {return n < 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);});"这样能够极大提升计算速度，这一技巧应该被推广。
*** 常见的函数式编程库有四个，分别是underscore.js/lodash.js/lazy.js/ramda.js，这四个库各自都有自己的特点，熟练使用能够极大提升我们的编程效率。这四个库中underscore.js是初始库，lodash相当于是underscore的优化版本。而lazy则是lodash的深度优化版本，其核心特性是引入了惰性求值。ramda也是lodash的深度优化版本，其核心是引入了自动柯里化。
*** ramda实际上非常类似于Haskell。
*** SICP真的是一本神作，任意掌握其中一门精髓就可以横扫编程界了。
*** 事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。
	————Stark伟 《JavaScript函数式编程》
*** 一个函数返回另一个函数，并将外部函数的状态给保存起来供后面的函数调用，这是一种极其常见的编程方法
*** 其实早期的webpack只考虑了打包，没有考虑不打包的情况，这个问题现在已经得到了重视，就是分开打包，这就是webpack的DllReferencePlugin。
*** 其实webpack使用配置文件配置并不是什么大问题，也不用担心配置复杂之后的配置问题，因为它的配置文件本质上也就是一个js对象而已，你完全可以使用代码自己拼出这个对象，将每个字段单独分到文件中去，这样就解决了配置文件复杂的问题。
** 2016/11/22
*** 两个工程共享一个文件，各大在实际的工程中，一个在测试工程中，这样写出来的程序非常容易模块化，也容易测试。但是很多IDE并不支持这个功能，比较好的做法是在复制粘贴，在测试工程中做好了然后引入到正式工程。
*** 在渲染引擎中，如何防止渲染到面板上的东西下次渲染就没有了？答案是不要只是将数据渲染到界面，要将增量数据添加到渲染数据库中，这样下次渲染时是基于已经修改了的数据，你所需要渲染的东西就不会丢了。
*** 实际上常见的绘图API只是提供了一个渲染的方法，你需要自己管理所需要渲染的数据，渲染引擎的精髓就在于此了。
*** init实际上是一个有副作用的操作，它一般用来给类设置初始属性。
*** 事件实际上也是一个有副作用的操作，一般用来向上层传输数据。
** 2016/11/23
*** TODO 关于按钮的active与非active状态，更好的做法是使用基类，而不是使用事件。
*** 动态事件框架模式是使用Layers来管理所有的操作，每个操作有一个基类compSwith用来管理对象入口以及按钮状态。
*** TODO 在js中，想要把函数调用时的所有状态都传递到函数中是需要点技巧的，这个技巧非常重要，常常在各种库与框架中看到，它就是————fn.apply(this,arguments)。
*** requirejs确实是前端的一个巨大进步，用它写出来的代码一般只要依赖一样一般都可以直接拷出来放在另一个工程中直接使用，不能require css或者说require css比较麻烦，拖了它的后腿。
** 2016/11/24
*** 结对串需求，结对编程，结对测试。
** 2016/11/25
*** 其实函数式编程远没有得到足够的重视。并不是使用map、reduce这些函数就叫函数式编程了，它要求我们自己去造高阶函数，然后用在编程中。
*** 自己造高阶函数还是有相当的难度的，在实际的编程中，这一技巧也只能偶尔用用，大多数时候并不需要自己去造。
*** 很多时候函数式编程会要求单个参数，因为一般函数的返回值只有一个，只有一个参数的函数才能跟这个返回值无缝接合，串联起来形成强大的抽象，但是现在js可以返回tuple这种结构相当于允许返回多参了，这一情况在以后将得到改观。
*** js中shift与pop是一对兄弟，两者所做的事正好相反。前者用来把数组中的第一个元素给删除，后者用来把数组中最后一个元素给删除，它们都会修改原数组，都会返回被删除的元素。
*** 柯里化理论确实听起来好像没什么用，但是柯里化函数就大有用处了。通过柯里化函数，我们可以将一个函数的参数分解，分次传入，然后在函数的定义与返回的函数中间做点操作什么的，这才是柯里化的精髓。实际上，所有的复杂应用程序都是用柯里化函数构建起来的，只是很多时候我们意识不到而已。
*** 实际上，管道（不管是windows/linux/mac/nodejs中）的核心思想就是高阶函数compose，通过将层层嵌套、一层包一层的函数调用转化为前后相连的一个接一个的函数来处理数据，使得数据流清晰可见，极大的提升了数据流的组合能力。
*** 保证数据的唯一性以及一致性，除非有特殊的理由，否则不要复制重复的数据，不然你就需要为这份重复的数据买单。
*** angularjs是现有module,再有component的。
*** 什么是component呢？实际上在没有引入任何框架之前，一个文件就是一个component。它里面主要有模板、事件监听以及数据处理这三个部分。各个框架的引入都是为了稍微简化一下这三个部分，提高开发效率而已。比如react主要是简化了模板、redux简化了数据处理、angular/vue简化了事件监听。
*** ES6的之所以要引入rest arguments这个语法实际上是为了改善arguments这个关键字的使用，传统的arguments关键字令人费解，类似于数组却不是真正数组，经常需要一点变通的小trick，而且你不能只取一部分参数，只能一用arguments就不再传参了，还有就是引入了一个奇怪的arguments对象非常不利于编译器优化。正是基于这些缺陷，ES6才引入了rest arguments。有了这个东西之后，几乎所有需要使用arguments关键字的情况我们都可以使用rest arguments了，以前无法用arguments关键字做到的情况也可以用rest arguments解决了。
*** rest arguments不止可以用在形参中，还可以用在实参中。当它用在实参中时，表示把数组原样传递到以rest arguments形式写的函数中，这样我们就不用使用apply来调用函数了。
*** rest arguments实际上也有逆运算，就是spread operator。这两者前者用来将参数转换为数组，后者用来将数组转换为参数，一个用在函数定义中，一个主要用在函数调用中。唯一有些许不同的是，rest arguments只能用在最后一个参数中而且只能用一次，而spread operator可以用在中间参数中而且可以用多次，甚至用在函数返回值中。所有spread operator更加强大，而rest arguments可以说是有些许瑕疵吧。
*** 写柯里化函数时，返回的函数使用箭头函数写比使用function写要来的好些。因为代码量比较少，可读性也更好。
*** compose的本质就是一个reduceRight，所以从这一点上来说，也许使用reduceRight比使用递归来得要好点，不过对于不懂reduce这个函数的人来说，代码看起来就没有递归那么简单了。
*** js中对象的key可以是对象，这个可以继续延伸，由于函数也是对象，所以它的key甚至可以是一个函数。
** 2016/11/26
*** redux也许不难，但rest arguments也许是一个障碍。
*** redux实际上可以说是一个状态与函数的结合体，函数处理状态，返回新的状态，依次往后传递。
*** 数组与对象实际上是差不多的东西，特别是对于js这种数组里面的每一项可以是不同类型的语言而言，所以ES6的很多新特性都是数组与对象都可以使用的。区别仅仅只在于数组是有序的，而对象是无序的。排除性能上的考量，我们完全可以使用数组代替对象。
*** TODO 数组与对象有着千丝万缕的联系与区别，需要仔细考量。
*** 由于js对象的key可以是一个对象，所以可以使用Symbol作为对象的key也就非常容易理解了。
*** 什么是数据类型？数据类型不过是一个值的集合以及定义在这些集合上的一些规则（也叫运算），没有规则不能叫一种数据类型。通过这些规则，我们能够对这些值进行过滤、映射、变换等各种操作，最终解决实际问题。
*** 以类为框，以函数为骨架，这就是现代编程语言的发展趋势。
** 2016/11/30
*** if与for实际上也可以看成是一个高阶函数，完全可以直接用函数去实现，只不过为了使用的方便被做了特殊处理，使得我们能够更简单的使用罢了。
*** lisp的宏与普通的表达式有什么区别呢？最大的区别在于宏不受语法的限制，只要最后变换出来的代码符合语法就行了，但是表达式不行，而且表达式还要考虑context/scope这些东西，但是宏统统不用。正式因为宏摆脱了这些限制，才使得宏具有表达式无法企及的表达能力。比如下面的例子：
    function func_for(initExp,stopExp,stepExp,bodyExp) {
        initExp();
        while(true){
            if(stopExp()){
                bodyExp();
                stepExp();
            }
            else{
                break;
            }
        }
    }
这个for如果用宏来写是没有什么问题的，但是用表达式的话，我们就很容易看出问题了。
*** 宏无与伦比的灵活性也有着它自己非常大的弊端。一门语言总是有些坚持，有些原则的，这个原则就是语法，有语法学习的人才能感觉比较好学，但是宏打破了这一规则，这就必然造成学习的人学起来感觉非常痛苦。
*** TODO 奇怪的EVAL,通过js的eval调用的代码相当于直接把eval的代码拿出来写在外面，替换eval，所以，如果在里面写一个局部变量，会多出来一个局部变量，如果写一个全局变量，会多出来一个全局变量。还有就是hosting命名提升会失效。
*** 面向对象开发就是使用模具造零件，模子会事先将东西的框架定好，然后你只需要往里面填充细节就好了。函数式开发就是连接电路，将每个做好的零件连在一起做东西。前者具有更好的整齐的结构，后者具有更好的灵活性。
** 2016/12/01
*** TODO 编写一个函数，用于在控制台直接加载常用的函数库，这样以后就可以直接在任意网页的控制台测试任意库的函数了。
*** 正向解需要将所有的代码包起来可以考虑反向解，也就是直接返回，这样就可以减少一层代码。
** 2016/12/02
*** js Array的方法中,多数方法都会改变原有数组，如push/pop/shift/unshift/sort/splice，但还有些方法不会改变原有数组，比如slice/concat。
*** 根据上面的总结，想取数组的一部分返回一个新的数组也只有slice一种方法了，concat是操作两个数组的方法。
*** slice与splice，一字之差，千差万别，前者不会改变原有数组对象，会返回原数组的一个拷贝，而后者会改变原有数组对象。前者主要用来取字串，后者用来操作数组中间的元素，比如替换、删除、新增等。
*** 我们经常会碰到有些意外的错误，我们不想继续往下执行，想直接把这个错误报出来。console.log往往不是最好的选择，因为提示信息不明显（没有标红），而且无法指定条件，更好的方法是使用console.assert()，这样既能指定条件，又能标红显示，当然最好不过了。
*** EventSource --> EventCreator --> EventHanldler/EventDispatcher --> EventSourceHandler.这样就形成了一个环，从头开始处理事件。
*** 事件相当于是组件的入口，相当于是组件的UI，写组件却不考虑事件是不可理喻的。每个组件提供一个唯一的处理事件的入口函数（如handleEvent）就可以了，这样跟其他的API就不会冲突了。
*** 使用函数作为参数确实具有极强的抽象能力，它使得我们能够以同一个框架处理各种情况。使得我们可以自己定义枚举、映射、累积、过滤这些东西。
*** each的第一种有用用法————归类。这个确实好像没有什么合适的高阶函数用来做这个事。
*** 关于时间有个常用的命名法就是统一用小写，一个大写字母都不带。
*** TODO 抽象要求我们提供一个黑盒，通过提供的API能够访问到它里面所有的部分，所有的API都应该使用我们自己的API来完成。
*** 前面的interaction已经处理了，后面的interaction就不再处理了。
*** 编程过程中垃圾回收非常重要，如果放了资源就要考虑什么时候收，尽管好多语言有自动的垃圾回收机制，但是很多时候垃圾回收机制不能解决所有的问题，典型的问题就是存在于全局变量（凡是作用域很大的变量都可以理解为全局变量），比如事件、三方库变量等。收放之间，一切编程问题迎刃而解。
*** 社交的潜力是巨大的，想陌陌、探探、钉钉等等各种工具其核心就是社交。不得不提的是有个产品————网易云音乐，它之所以评价这么好，其核心很有可能也是社交。
