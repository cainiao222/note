* 2015/08
** 2015/08/01
*** 何为求值？求值只不过是一个等价替换的过程。一般是将复杂的过程用简单的形式，简称结果来表示，换着换着结果就越来越简单，最后得到一个别人都可以看懂的结果，这就是求值。求值即化简。
** 2015/08/03
*** 当对象的某个属性值发生变化的时候发出某个事件，这是事件的常见发生方式，一种非常有用的技巧，如下：
public object SelectedItem
        {
            get
            {
                return selectedItem;
            }
            set
            {
                if (selectedItem == value) return;
                selectedItem = value;
                OnPropertyChanged("SelectedItem");
                OnSelectedValueChanged(new SelectedValueChangedEventArgs(selectedItem));
            }
        }
获取这个属性值的时候直接返回，但设置的时候除了设置以外还做个关键的动作，发出值改变的事件。
*** 其实接口的出现很有可能就是为了并发。通过提前定义好接口，说明那个类做什么，那个类做什么，却不去具体的实现。这样一个团队的多个人就可以同时开发实现不同的类并且知道其他的类在做什么。就可以同时工作了。但是，通过接口来组织团队工作的方式对接口设计者提出了非常高的要求，一旦接口设计的不好，整个软件都不会很好。
*** 使用一个全局变量管理整个程序是一个很好的做法，既可以方便程序的管理，也可以很容易的将这个对象给保存起来实现程序的恢复。
** 2015/08/04
*** 只要同一个东西出现两次，最好就是用变量将这个东西保存起来。这样只要修改这个变量的值，就可以做到一改全改了。同时还能缩减代码量。变量是人类历史上的一个伟大的发明。
*** 异步会使代码难写难调，因为问题出现的地方和实际错误的地方可能相隔十万八千里。只能拼程序员自己的感觉去碰运气，运气好的才能改正错误。
*** 一门语言说提供的整理代码的能力是非常重要的。好的语言应该提供良好的代码分类方式，在遇到新的需求的时候，能够轻而易举的将这些代码放到合适的位置。不会影响原来的代码结构，也就是说，好的代码应该只提供扩充代码，不修改代码。
** 2015/08/05
*** 我们一般说一个函数最好只做一件事，但有的时候一个函数真的需要做几件事。这可能是因为效率，比如统计同一个文件夹下的DBF与JPG文件，当然最好是一次遍历就同时算出这两种文件来的好。
*** c++的命名空间确实是一个很好用的东西，首当其冲的好处就是它可以用来弥补c++枚举类型可以不用带类型的不足。
*** 相比于类，命名空间的好处在于它并不影响其内部的代码。你在全局区域怎么写代码，在命名空间里面依然可以这样写。而不像像类一样要先声明一个对象了才能使用它内部的代码。它并不与语义挂钩，就是一个简简单单的分类方法，将所有的全局变量，全局函数，枚举等划分到了不同的逻辑区域。而且它是跨文件的，即使是在不同的文件，不同的地方，依然可以把某些变量与函数逻辑上的放到一起。它就是一个代码的文件夹，而且是一个很高级的文件夹。
*** 享受抽象的乐趣！！！即使别人不说，也要持续改进代码。
*** 写代码要写出层次来。这个层是分层的层，并不是说代码的境界。
*** 将状态在函数间传输是有通信开销的，有时候，也许直接在错误产生的地方把错误处理了是更好的选择。
*** 把代码写到最短也许并不是最好的写代码的方式，最佳的写代码的方式是要让代码容易读容易改。
*** 代码风格的统一非常重要，如果不能统一风格，那么新的代码引入的时候就不知道应该以哪一种风格来编写代码了。
*** 基于内部结构的算法往往只能处理一些结构比较简单、可以计算的问题，这种问题叫做确定性的问题。但现实生活中的很多问题是没有清晰的结构的，无法找出规律以推算结果，是非确定性的问题。这个时候就需要使用概率方法了。也许你并不知道这个东西为什么是这样，但你依然可以推算出结果，这就是概率方法。
*** Debug模式下正常，Release模式下不正确毫无疑问就是配置不一样惹得祸。这个配置多半都在配置下的c/c++面板上，主要是在优化以及代码生成两个子选项卡里面。配置不一样，选择的dll，生成程序的方式都不一样，程序的行为自然也就可能有差别。
** 2015/08/06
*** 事件机制有个很重要的作用就是可以延后计算。当我们在程序设置的时候需要做某些操作，但设置尚未完成，还不能马上执行的时候，我们就可以将要做的操作添加到设置完成的事件中，然后在设置完成的时候调用这个时间，然后所有的操作就可以一次执行了。这一特性在设置复杂的时候特别好用，比如图形窗口的设置，控件的加载等。
*** 使用函数参数可以减少没必要的成员变量，很多时候要分清一个东西到底是属于函数还是属于对象，也就是这个成员到底是不是属于这个对象所表示的意思。多余的成员一个都不要有，这样才能使得代码逻辑简单，达到编写函数库的标准。
***
http://item.jd.com/895852.html	花生

http://item.jd.com/1285105.html	草莓干

http://item.jd.com/611021.html	芒果干
** 2015/08/07
*** 时代越发展，人们越注重自我价值的实现，以利益最大化，但与此同时，带来的问题就是人会越来越自私，对别人的要求越来越高，却越来越不懂自律。
** 2015/08/10
*** 其实求值的本质就是一个分情况处理的问题，分类质量的高低将决定求值的复杂度。为什么要分情况处理呢？因为有不同的处理逻辑。现实生活中的问题其本质是一个求值问题，但现实太复杂，我们唯有分类才能使得事情得到简化，进而变成我们能够处理的问题。可以说，是分类使得我们对问题的求解达到了和谐的统一。
** 2015/08/11
*** 使用emacs来作为操作系统的入口启动其他程序，这样就可以使用emacs定制的快捷键，使用emacs来手机各个程序的信息，以便于更好的管理，实在是一个很酷的想法。
*** .NET使用的垃圾回收策略是分代回收以及标记清理回收。0代对象的回收成本是最低也是发生最频繁的。代数越高，回收的成本越高。大对象直接属于2代对象，所以要尽量较少大对象的使用。分为大对象堆以及小对象堆，只有小对象一开始才属于0代，大对象一开始就属于二代，所以回收是非常慢的。
** 2015/08/12
*** 其实真正应该在构造函数以及析构函数中做的事应该仔细考量。因为这两个函数有额外的动作，很多时候这回影响你真正想执行的功能。还不如将他们提取到其他的函数里面，这样就实现了一个函数只做一件事，而不会跟构造与析构的动作混杂在一起了。一般只在这两个函数中执行一些类似输出这类辅助功能的函数。
*** 在c#中，一个工程想要使用到另一个工程的代码，必须通过添加引用来实现。这样就相当于将另一个工程的代码添加到了这个工程，这样就能引用那个工程的命名空间，进而使用那个工程的类，实现将大量的类与代码组织到一个类里面。
*** TODO webmap控件是核心，改变需要花时间搞懂这个控件。
*** 在c#里面，应该尽可能的较少大对象的分配与回收。因为首先大对象属于G2代，分派回收成本很高。其次大对象堆是不会轻易移动内存的，这很容易造成内存空隙。这样很可能内存虽然还有，但由于内存空隙造成无法成功分配，进而引起内存泄露。
*** 在C#中，托管堆和非托管堆的区别在于，在托管堆中，垃圾回收器回收完废弃的内存后，有一个压缩操作，即在垃圾回收器每次释放了不再被引用的对象后，都会检查堆中的内存分配情况，他会压缩其他对象，把它们都移动会到堆的端部，使所有的未分配内存再次形成一个连续的块。这样，在下次分配新的对象时，计算机就不必去搜索整个堆，以找到足够大的内存来存储新对象。 在移动堆内的对象时，指向这些对象的所有引用都要用新的地址来更新，垃圾回收器会负责处理更新问题，当然这也会带来一定的性能损失。 由于托管的堆中，垃圾回收器具有压缩操作，因此使用托管的堆，就只需要读取堆指针的值即可，而不是搜索链接地址表，来查找一个地方以便放置新对象。 这种能够被垃圾回收器访问管理的堆，我们称为托管堆。反之，通过指针访问，不能被垃圾回收器访问，管理，需要手工管理内存释放的堆，我们成为非托管堆。 ――china_bai
*** 使用c#的大对象时要特别注意：大对象一般是不移动的，这是一般的说法。但实际上，这句话其实比较坑爹。大对象其实是会被移动的，而且几率很大。所以，最好的做法是――只要使用大对象，一律加上fixed将对象锁住。
** 2015/08/13
*** 其实c#要想调用c++的DLL还是非常简单的，只需要将DLL拷贝到c#程序所在目录，然后在c#中声明下所需要使用的函数，就可以直接使用了。并不需要DLL的头文件或者说只需要将头文件利用c#的方式改写下就可以直接调用了。至于不知道为什么设计出来的那个完全不干啥事的lib文件更是不需要。不得不说，使用c#调用c++的DLL比直接使用c++自己来调用自己的DLL还要方便。
*** 其实c#是对c++的很多设计缺陷的一次正面回应。很多地方它就是比c++要方便，不论你承不承认。
*** c++并没有在代码层面上的项目依赖的概念，只有最终程序上的项目依赖。所以c++中，当你的一个项目依赖于其他项目时，你需要进行复杂无比的各种路径设置与文件拷贝。更关键的是，这些设置的方法并不是唯一的，每个人都可能有自己的设置习惯，使得协作开发非常困难，沟通成本非常高昂。
*** 在c++中，对于类或是结构体，必须将部分细节实现放在头文件中，不能只是简简单单的声明一下然后将实现放在cpp文件中，这样会造成重定义。这也是一个非常扯淡的设计，会让头文件结构混乱，写的非常丑。
*** 一个c++写出来的库，还不如c#重用起来好用，真是悲哀。完全可以使用c#做上层，c++做底层来进行混合编程，效率更高，BUG更少，更易于沟通。
** 2015/08/25
*** 如何完成代码间的解耦，这是一个非常复杂的问题，也是一个非常重要的问题。在写代码的过程中应该有意识的注意这些问题，使得代码更其他的代码没有交集。这样做的好处不仅在于好分离出这一块的代码，还有一个非常重要的好处是会使得代码比较好理解，这是非常重要的。
*** namespace实际上就是一个代码层面的文件夹，同名的namespace里面的代码就是属于同一个文件夹，在这个文件夹里面的文件不能重名。但对于不同的namespace，也就是相当于在不同的文件夹以内，变量重名是没有问题的。可以说，是namespace的出现使得我们的代码不再粗暴的共享一个共同的名字空间，使得代码从此有了树形结构。
*** TODO 命名空间的设计，很大程度上也许是为了兼容以前的老代码，为了不修改已有的代码而被设计成了现在这个样子，也就是为了兼容性。但如果抛开这一点，命名空间也许是并不需要的东西。我们也许并不需要显式的指定一个名字来区分我们的变量，也许仅仅依靠大括号就可以完成我们所需要的功能。如果真的只靠大括号来完成命名空间的功能，会有哪些缺陷呢？
*** 请叫我设计师，而不是工程师。
*** 编程工具永远不是程序本身，对编程工具的熟练掌握，永远也无法代替真正的对程序和计算的理解。过分强调这些工具的使用，是本末倒置的，让工程走上失败道路的作法。――王垠《所谓软件工程》
*** 一个真正的艺术家，可以用任何在手上的工具创造出色的作品。有些甚至可以用一些废品垃圾，拙劣的工具，做出杰出的，别具风味的艺术品。因为艺术存在于人的心里，而不在他们使用的工具里面。――王垠《所谓软件工程》
*** 编程的核心永远在于抽象而不在于面向过程还是面向对象。
*** 何谓函数式编程？函数式编程使用一个个函数，以数据流的形式完成功能实现。非常类似于电路的中数据的流动，可以用来设计电路。由于类似于电路，因此非常容易并行。试想我们的所有家用电器不都是并行接在标准电压上并行的吗！
*** 函数式编程可以用来指导电路设计，同样，电路设计也可以用来指导函数式编程。有时候，我们觉得并发编程很难，这时候，可以从电路上去寻找灵感，反过来指导编程。它们是互相促进的关系。
*** 使用电路来理解函数式编程是非常有效的，那么，如何使用这一视角来理解面向对象编程呢？面向对象编程实际上是带有存储的电路。纯的函数式编程是不带有存储的，一个输出会立刻流入到一个输入。但面向对象编程会大量的使用到存储。
** 2015/08/26
*** 面向对象，使用新类型而不是原有类型的好处是你并不需要对外暴露代码实现，而只需要暴露接口，然后将实现隐藏在新的类型里面。这样做的好处在于隐藏了次要代码逻辑，以更简单清晰的方式呈现了主要代码。
*** 其实相机控制这个东西真正难的并不在于技术，而在于逻辑。每个动作比如打开相机、关闭相机需要做哪些事，PGR的、日志的、写盘的等等这些错综复杂的东西需要被最恰当的分类到买个动作中才能最好的完成功能。
** 2015/08/27
*** 关于东西南北记忆问题的思考。
“前面是东，后面是西，左面是北，右面是南”这种记忆方式。首先这是一种层次性记忆，把很少的信息分在了四个层。这样提取起来就不得不一层一层的去提取，无法一步到位的辨别方向。其次这是一种文字性的记忆，这种记忆方式缺乏与现实的联系，记忆方式很差。
其实这种信息少却重要的东西适合于使用图像记忆。这样能够将保存在同一个平面上，提取起来非常快。还有图像记忆与现实紧密相连，不需要死记硬背。只有对于大规模的杂乱无章的信息才适合于使用文字死记硬背，比如数字、文章等。
其实除了图像记忆与文字记忆以外还有一种非常牛逼的记忆方式――理解记忆。理解记忆适合于记忆大量的信息。从信息中找出规律、建立模型来进行记忆。提取信息的快慢取决于模型建立的好坏。不同于记忆少量信息，只有大量信息才适合于理解记忆，这样才能建立模型，很少的信息比如东西南北是不好直接使用理解记忆的，但如果辅助很多东西南北方面的知识，理解记忆就变成了可能。
*** 图像记忆并不是随便照张图来记在心里就叫图像记忆了，要使用现实中的图像来进行记忆。比如东西南北，要使用地球与太阳转动来进行记忆，记住关键的方向东方与北方，然后其他两个方向就记住了。
*** 小时候记忆混进了垃圾记忆，以后想要改变是非常难的。比如我以前记忆东西南北的方式“早晨上大路，前面是东，后面是西，左面是北，右面是南”这种记忆方式其实完全不如“上北下南左西右东”这种记忆方式来得简单好记。
*** 把代码当成自己的孩子一样爱护它们，时时修整，这样才能让他们更好的为你工作，不会动不动就耍脾气，闹BUG。
*** 多问问自己这个东西是什么，而不是自己去试验哪种方式是不会崩的，要自己多事情的逻辑心中有数。什么是打开相机？什么是关闭相机？什么是开始拍摄？什么是停止拍摄？而不是打开相机要做哪些事？关闭相机要做哪些事？开始拍摄要做哪些事？停止拍摄要做哪些事？询问是什么而不是问怎么办。
*** 要做到心中对代码的逻辑有数，主动发现问题，而不是等待问题出现了再去解决这个问题。
*** 在一个函数里面使用一个函数外面的全局变量就等于从函数外面拉了一条专线到函数内部，这种乱拉线的行为是非常不利于函数实现模块化的。要编写模块化的代码最好所有的输入都从函数参数中得到。如果函数参数过多，表明这个模块做了太多的事，需要继续细分。导线，使用电路设计来理解编程。
*** 如何在一个函数里面调用自由的调用多个函数，这是一个非常复杂的问题。好多时候我们写了大段大段的框架代码就是为了实现这一点。
*** 状态机的核心就是一个死循环，这个循环中有很多在此循环之外也可以读写的对象，然后在外面每次修改这些对象，这些对象值的改变影响到循环里面的动作，从而实现不同的动作。实际上就是一个不断修整，循环显示的过程。这一过程在很多方面都非常有作用，典型的例子就是windows窗口程序，还有各种渲染引擎、图像显示库等。
** 2015/08/28
*** 其实DOTA、LOL这样的游戏的本质就是先建立一个基本的平台，规定玩家要干什么（推塔），如何获取优势、避免劣势（阴影、血量、野区、河道），然后定义规则（技能），给予玩家充分的只有去利用这些规则趋利避害，已达到最终的目的。这其实是游戏能够获得成功的不二法门。首先你得定义一个基本的原则与平台，然后设计很多相关的因素，这些因素有助于或有害于你达到目标，然后设计很多有趣的规则，玩家可以使用这些规则自由组合，达到最终的目的，这才是一个优秀的游戏。
*** 多线程引发冲突的原因无非读写同时进行或写写同时进行，只需要保证在进行一个大对象的读写的时候先加锁，就可以避免这种冲突。实际上还是非常简单的。注意只有读是不会有冲突的，一旦有写，不管是读写还是写写都可能发生冲突。所以，为了保证始终不发生冲突，最好的方式就是不管读还是写大对象，最好都加上锁，这样就可以避免冲突崩溃。
*** 多线程崩溃有一种非常简单的调试方法，崩在哪一个对象上就寻找所有读写这个对象的地方一个个加锁，加着加着不崩了，那么问题就找到了。
** 2015/08/31
*** 面向对象编程有一个非常重要的好处就是新加入一个功能只需新建一个类，如果要去掉这个功能只需要将这个类的所有代码给去掉就可以了，非常的方便。
*** 程序的本质是图灵机，而图灵的本质是状态机。使用状态机可以解决许许多多的问题。其实窗口程序的本质就是一个状态机，所谓的消息不过是由于一个状态的改变而触发了一个函数而已。
*** 先辈程序员们其实非常厉害，他们已经做了许许多多方面的数字化工作，比如视频、音频、计算机系统、网络，这些东西虽然在现在的程序员看来已经过时了，但其实依然闪烁着智慧的光辉，如果你去研究的话依然可以给现在的程序设计带来很多启示的。
