﻿﻿﻿﻿﻿﻿* 2015/01
** 2015/01/01
*** 要想成为一个好的领导人，你必须要有很强的人格魅力。善良亲和是基本的要求，此外还要引导自己手下的人实现自我发展和提升，给他们一个方向和理想。这样他们才能懂得他们自己，懂得你，从而从他们自己的自我发展出发全心全意的为你效力。
** 2015/01/02
*** 实际上，性格才是阻碍自己改变的最大枷锁。比如你觉得自己是一个内向的人，自我表现不是你自己的风格。在这种情况下，实际上，并不是本性阻碍了你，而是你给自己总结的性格“内向”这个词阻碍了你去自我改变。
*** 我们往往喜欢给这个世界制定规则，因为这样能使我们的生活变得简单容易。但殊不知这种规则往往在方便了你的同时也会限制了你去探索规则之外的世界。规则都有局限，都只是在某种条件下才成立，只有不断的打破规则才能继续发现新的规则，从而使你的生活变得更加容易。
** 2015/01/05
*** 交互式编程并不是函数式编程语言的专利。命令式编程语言也可以实现交互式编程。只不过命令式编程语言函数并不一定有返回值，所以导致某些函数敲进去后可能没有任何输出，你无从判断函数执行的结果是否正确。所以，只能说函数式编程语言更适合于交互式编程。
*** 编程=数据结构+算法。这一对编程极度精简的概括实际上透露了关于编程本质的不少东西。编程实际上就是一个查询数据库的过程，很多看上去很高端的功能实际上也就是一个查询数据库而已。同样，要实现一个功能，首先要构建与这个功能相关的数据。只要有了数据，什么都好说了。
*** lisp并不是一种纯的函数式编程语言。函数式编程语言也有其不可回避的缺陷，比如状态机，如果纯函数式编程来实现，那么难度将会相当地大。
** 2015/01/06
*** 易经是一门讲述天地间万事万物规律的学问，学好以后妙用无穷。比如你可以用来指导文学创作，某个人有某种性格，这种性格确实就可以决定这个人的命运，而如何决定，这其中的规律就蕴涵在易经中。很多的小说中所谓的传说，所谓的天命，其实都只是按照易经演化规律所必然的结果。当然，易经只是能指出大致的规律，也并不是绝对准确的，因为性格是可变的，性格一变，那么依据此演化出的规律自然也不再适用了。但性格很少变化，所以这门规律绝对是大致准确的，具有参考意义的。
*** MFC程序有一种很常见的写法，就是除了主窗口线程之外再额外创造一个工作线程，用来完成耗时的数据处理，并将与此处理相关的逻辑放在另外的文件中，而不是写在窗口类当中，这样就完成了显示与处理的隔离，便于程序的维护与扩充。
*** 赋值实际上类似于内存拷贝memcpy，但又不完全等价。具体的差别是内存拷贝不会再开辟内存空间，只会在已有的内存空间上做简单的复制，但赋值则是如果已有空间，就制作复制，如果没有空间，会先开辟内存空间（栈上和堆上),然后再做复制。相比于赋值，内存拷贝memcpy所做的事情更少，更加灵活强大。其实赋值往往意味着新对象的产生，一旦使用了赋值，你在新对象上所做的修改就无法在原对象上生效了，想直接操作原对象还是应该用指针或引用，不能直接赋值。
*** memcpy是更为强大灵活的赋值命令，可以拷贝任何一块可读内存到指定的可写内存中。比如它可以在一个进程的几个线程之间读写数据。
*** 还有一个很类似于memcpy但比它更好用的实现内存拷贝的方式，sprintf，它也是一个非常好用的赋值命令。
*** 如何实现资源的管理。很简单，做间接的资源资源访问就可以了。具体就是每访问到一块子内存时先访问到一块总控内存，查看访问对象是否有这个子对象的访问权限，如果有才给予这个访问对象访问的权利，这样就实现了资源管理。
*** 工作是为了生活，但生活不仅仅是为了工作，还有很多其他的吸引我们的事情等着我们去做。
*** 大批量的数据处理很重要的一点就是处理中途出现错误不能直接退出或是暂停下来要求人工干预，正确的处理方式是先跳过这个错误并将这个错误记录下来，然后继续处理剩余的数据。最后给作业人员看到的数据一定是尽可能地处理了所有能够处理的数据，后续的小错误可以慢慢调整。要预留出处理所有数据的接口，也要留出针对具体的错误数据进行小范围处理的接口，这是一门学问。
*** 一个进程的多个线程之间进行通信时，一般的API留出的接口只有一个指针，通过这个指针来将数据从一个线程传递给另一个线程。要特别注意，这个指针所指向的对象必须是接收线程的整个生命周期都存在的对象，不能是临时对象，否则就有读取到脏数据的危险。
*** 指针的使用要慎之又慎，因为指针本质上是几个对象共享同一份数据，而且都有这个对象的修改权限，一旦一个对象不小心修改了对象的值以后，另一个对象是不知道的，这样就有可能获取到错误的数据。
** 2015/01/07
*** 最近分布式很火，但其实不能因为这样就忽略了集中式处理的优势。集中式处理能够把相同或类似的问题集中到一起，便于针对此问题提出针对性的解决方案，这种方案往往更优秀更高效。编程有个非常基本的原则就是消除重复，如何消除重复？其实方法就是集中式处理，这样就消除了重复。
*** 处理数据之前先对数据集中地做个数据格式的检查，这一点非常有必要，不然基本的条件都不满足，就运行处理代码，就会导致检查代码与处理代码杂糅在一起。非常不利于维护，也不利于程序逻辑的清晰。
*** 在作用域内部使用外部变量会使得外部变量与这一块代码紧密耦合，这种情况下，如果将这块代码与变量放在一块还比较好维护，但是如果两者隔得很远就会导致代码非常难维护。
** 2015/01/08
*** 记录式思考与纯用脑思考是两种不同的思维方式，各有各的优缺点。纯用脑思考更接近于只用电脑的CPU进行思考，速度飞快，不受内容的限制，灵活性高，便于进行一些创新性的思考。而记录式思考则便于对一些新概念进行深度挖掘，有条不紊，稳扎稳打，思维条理清晰，可以比纯用脑思考思考得更远，虽然慢但永不止步，慢慢的总可以超越那种突发式，根基不牢的思考。
*** 循环的层数问题。首先应该尽量避免两层及以上的循环，一层循环是比较容易理解的，两层的话就有点难理解了，如果再两层以上，理解起来就非常费劲了。就像指针一样，使用一级指针，少用两级指针，避免三级指针。实际编程中，三层循环几乎见不到。所以主要的问题是如何将两层循环优化为一层循环。最简单也是最常用的方法是将内层的循环放到单独的函数上面去，这样就总是只有一层循环了。但有时候内存循环的代码只被调用一次，这时抽象出此函数就没啥必要，要采用其他的办法解决。
*** while的表达能力确实比for更强，因为while可以以更加灵活的方式控制遍历数据的方式，一次移动几个位置，而for只能以指定的步长遍历数据，不然会写出很丑陋的代码。但for确实使用起来比while更加的方便。所以能用for很好地表达就用for，不能才用while。
*** 资料，比如收藏夹，磁盘文件等东西不能总是增加，偶尔也要减减。不然数据越来越多，必然会导致全部成为垃圾，要始终保持整体的数据量处于可控的范围内。
*** 其实可以这样理解，lisp里面所有的symbol都是函数，都需要求值，并不是只有表的第一个symbol才是函数。
** 2015/01/11
*** 想的越多，就越喜欢关注东西的负面效应。因为往往从背面来看事物往往更容易看清看懂这个事物。
*** 技术可以简化生活，但同时也在复杂生活。要在这两点之间仔细权衡。
*** 其实只要能抵御瘴气的诱惑，就可以多活很久，比如说六千年。
** 2015/01/12
*** 编程最擅长做的事就是处理重复劳动，一旦你发现某件事变成了重复劳动，你就要考虑用编程来解决它了。
*** 爱与理智真的不能共存吗？
*** 使用两面视角来理解事物，因为我们所处的世界就是一个两面的世界。
*** 上堆视角擅于解决问题，下切视角擅于提出问题。上堆视角擅于提出聊天的新话题，以便于继续聊下去；下切视角则擅长于给一个话题作一个总结，中止聊这个话题。我总是习惯用上堆视角来思考，而忽略了下切，导致我不会聊天，以后要尽量避免。最正确的处理方式是少用上堆，要用的恰到好处，要多用下切，最好上堆以后马上接一句下切。
*** 在编程时，使用函数比使用数据能够提供更强大的灵活性。在使用数据时，多想想使用函数是不是更好一些。
*** 在windows API里面，凡是要得到一个字符串的函数都不会以返回值的形式返回，而绝对是以输出参数的形式返回，多数情况下这种情况会有两个参数，一个是字符串的地址，另一个是字符串的长度。因为效率问题。
** 2015/01/13
*** 公开了数据结构才可以自己写，不公开只能调用API。
*** 使用hpp的主要局限在于只能有声明代码，不能有定义代码，否则就很容易出现重复定义的错误。这一点的主要体现就是不能有全局变量以及全局函数，不能有静态变量，不能有循环引用。
*** 编程的四种境界：
1、无意识无能力
2、有意识无能力
3、有意识有能力
4、无意识有能力
** 2015/01/14
*** 将可能需要被多个代码文件所公用的代码部分抽象到单独的文件里，然后再在几个需要使用的地方include进这部分代码，这就是include这个关键字所设立的意义。一旦某部分代码可能被几个地方公用，就要考虑将这部分代码抽出来放到单独的文件中，不然就可能出现重复包含的垃圾。
** 2015/01/16
*** 可以不学习，但不可不思考。
*** 学习不在于你学了多少东西，而在于你学进去了多少东西。
** 2015/01/18
*** 慎防数据垃圾。没有作用的多余数据一点也不需要，尽量精炼数据。这样能增强思考能力。比如coc造兵。
** 2015/01/20
*** 变量是数据的抽象，函数是代码的抽象，模板是类型的抽象，函数对象是函数的抽象。
*** 语言的抽象能力是一个非常重要的指标，一门强大的语言应该有着抽象一切的能力。能够抽象函数（lambda，function），抽象类型（template），抽象数据（var），抽象代码（函数）等等。语言其实本质上就是对现实世界的抽象，用以一种更加简洁的方式来描述我们所生活的世界。像java这种语言，很多现实世界中的东西都无法直接抽象，需要通过类之间叠床架屋式的设计来间接地抽象世界，就是一种很糟糕的语言。
*** 继续谈语言的抽象能力。静态变量抽象了数据的值，模板抽象了数据的类型，两者共同抽象了数据；函数抽象了代码，函数对象抽象了函数；lambda可以将代码抽象成函数，从而消除了代码与函数的隔阂。动态语言的变量可以接受任何类型的任何值，从而打破了数据类型与数据值的隔阂。一门语言的抽象能力越强，就越能够以更短的代码表达更复杂的问题，最终就可以以更短的代码解决更复杂的问题。
** 2015/01/21
*** 生活实际上就是一场零和游戏，你得到了某些东西，就必然会失去一些东西。那么生活的意义在哪？生活的意义就在于选择。对不同的人来说，得到的东西和失去的东西孰轻孰重是见仁见智的。有些人可能会觉得这个更重要，而另外一些人可能会觉得那个更重要，虽然从客观上来说两者其实是一样重要的。这就是生活的意义，我们能朝着我们想的方向去追求，即使失去一些东西也在所不惜。
*** 继续谈语言的抽象能力。静态变量抽象了数据的值，模板抽象了数据的类型，两者共同抽象了数据；函数抽象了代码，函数对象抽象了函数；lambda可以将代码抽象成函数，从而消除了代码与函数的隔阂。动态语言的变量可以接受任何类型的任何值，从而打破了数据类型与数据值的隔阂。一门语言的抽象能力越强，就越能够以更短的代码表达更复杂的问题，最终写出更短的代码。
*** c++其实就是一堆杂七杂八的工具所拼凑起来的语言，缺乏整体的设计。但这些工具经过多年的实践检验，已经能够很全面地解决方方面面的问题了。不过同时也由于工具太多，工具之间缺乏联系，造成了学习困难。
*** c++如果几个命名空间名字相同，编译器会直接将这几个命名空间中的变量与函数合并，如果这两个命名空间中没有重复的符号，那么不会有什么问题，这就是命名空间不同于类的地方。但是如果这两个命名空间中又有重复的变量或函数的话，一样会产生重复定义的错误，这种情况下命名空间就没有什么意义了。
*** 街景数据自动化处理工具还是一个比较完美的程序的。程序由三大部分组成，分别是服务端，客户端以及处理端。它使用了一个公有的配置文件作为在所有机器上通信的工具
** 2015/01/22
*** Lisp表达式的求值过程其实就是一个前缀表达式的求值过程，其实说白了跟算数学表达式的值没什么不同，只不过是将数学运算符换成了函数名而已。
*** 前缀表达式不同于中缀表达式，前缀表达式只需要一个栈就可以完成运算，而且可以支持多个参数，比前缀表达式好上不少，也不用管优先级，大大简化了中缀表达式的计算。
*** 如何将一个新东西用已有的东西来实现？很简单，将这个新东西用已有的东西表述出来，然后就可以用已有的东西的方法来解决这个新问题。比如使用c语言的函数来实现lisp，核心思路就是将lisp的函数调用转化成c语言的函数调用，由于c语言的函数调用实际上是用的堆栈，所以堆栈是两者进行转化的关键点。
*** 如果考虑问题不从整体的角度的话，很容易引发拆东墙补西墙的错误，这个问题虽然解决了，但新的问题也出来了。
** 2015/01/24
*** 自命不凡往往是程序员最大的敌人，自以为很牛逼，其实一窍不通，落入下层境界。
*** 美好的东西往往只是妙手偶得，刻意的地追求反而容易落入下层的境界。
*** 我们永远只可能在某些方面达到精通，而在其他的方面一窍不通，即使这两件东西存在千丝万缕的联系。
** 2015/01/25
*** 发送口只有一个，接收口也只有一个，但要分比较多的不同类型，来解析发送的消息类型，针对不同的消息做不同的处理。
*** 关于数组的引用与引用的数组，实际上引用的数组是不被允许的，因为引用本质上来讲就是一个不占用程序空间的符号，而数组初始化时必须知道所占用的具体空间才能完成初始化，所以引用是不能有数组的。其实引用是变量的抽象，引用可以指向不同的变量，从而代表不同的东西。
** 2015/01/27
*** 写代码的抽象级别越高，就越能够以更短的代码解决更复杂的问题。
*** 将作用域范围很大的变量使用单例模式静态变量放到另外的文件中去，可以使得代码变得更加整洁。
** 2015/01/28
*** 未来的互联网将不止能够卖已经做好的现成产品，也能做一些加工之类的工作。比如打印（照片，pdf书籍，甚至3d模型），制造等。这一改变具有非常重要的意义，这意味着很大的工厂可以直接面向终端的用户，利用互联网的聚集效应来将中间过程消弭于无形。未来任何人想做任何东西都可以直接通过互联网，会有人来帮你做了然后邮寄过来给你。同时，对于卖家而言，他们也能最大限度的聚集用户，利用批制造节约成本。
*** 什么样的代码才是容易阅读的代码？首先函数绝对不能过长；其次要注意清楚的命名。不要怕函数过多不容易看，其实一般一个程序里面真正重要的函数就那么几个，只要这几个函数是清晰的，看起来就回非常方便，别人并不会那所有的函数一个一个去看。
