* 2015/02
** 2015/02/01
*** cygwin就是一个windows上的linux虚拟机，在它上面可以直接使用linux下的很多命令，这个都不算什么。最可贵的是可以使用它来编译很多只能在linux下编译的代码，以后下了源代码却发现没有vs的解决方案都不是事了，直接在cygwin下编译就ok了。
** 2015/02/02
*** 关于集中式管理与分布式管理。集中式管理企图将所有的管理任务都交给少数的几个几个人去掌握，这种结构决策迅速。如果领导者有才能，能更好更快地发展。但也造成了少数人权利过大，容易滋生腐败。还有使得管理者与被管理者脱节，导致越来越难以管理。而且一旦结构复杂以后，会导致派系林立复杂，难以管理，缺乏拓展性。分布式管理能够避免集中式管理的缺陷，它将管理任务分发给每一个个人，每个人在做事的同时还有一部分管理子类的信息，能够方便地在所有被管理者之间做遍历，完成收集意见之类的工作，但分布式管理也有缺陷——决策缓慢。这两种管理模式互相补充，优缺点正好互补。要灵活运用这两种管理模式，不管做事还是——写代码。
*** 实际上函数参数也是一个定义变量的接口，它跟在函数里面定义变量表面上看起来功能相似，但实际上有着不小的区别。它实际上是说这个函数的功能是可配置的。每当你传入不同的变量值给函数的时候函数能够返回不同的结果，这就比定义在函数内部获得了更好的灵活性。尽可能地将变量定义转移到函数参数这里来还可以获得一个额外的好处，就是这样写起代码来会渐渐的改变你的思维模式，使得你写出的代码越来越函数式化，因为你不得不考虑到不能使参数太长，从而使得函数写的简短。非常有利于编程能力的提升。所以，尽可能地将变量定义写在函数参数里面，这是一种强于写在函数里面的编程手段。
*** 函数式编程其实很简单，把握一个标准，不要出现游离的变量就可以了，真要出现也要尽可能地减小变量的作用域。比如严禁出现全局变量，少用作用域范围很大的局部变量。尽可能地将函数写的短小（这样变相地减小了变量的作用域）。其实严格的函数式编程并不好用，完全避开命令式编程并不是编程的解决之道，最好的方法就是利用函数式编程给命令式编程建立一个约束，减小命令式编程的作用域，用这种形式写出来的带啊就会非常的好拆分，可以充分利用函数式编程的优势，特别是并发的优势。
** 2015/02/04
*** 关于可穿戴设备绝对不能简简单单的理解为一个记步的工具，而是应该把它理解为一个随身信息采集的工具，就是你一天到晚所做的所有事都信息化的手段，从中可以提前出许许多多重要的信息，比如个人的健康状态，学习状态等。它第一次将人接入了互联网，使得电脑能够帮助人思考一些问题，从而将人从某些工作中（比如体检，记笔记等）解放出来。这才是可穿戴设备的意义。
** 2015/02/05
*** 写函数有三重境界，最低境界是将函数中的数据与代码互相穿插杂糅在一起；高一层的境界是将函数中的数据提到函数头，这样下面的代码能够使用到这些信息，能够写出更短、更灵活、抽象级别更高的代码；最高境界是函数里面都完全不要出现数据，将数据全部放到参数里面去，这样写出来的函数是纯代码的，其实也就是所谓的函数式编程了，这样写出来的代码抽象级别就更高，更加灵活了。需要注意的是，并不是境界越高就是越好，境界越高写出来确实质量好，但相应的花费的时间也会越多，代码越难写。在这个以开发效率为先的年代，要根据实际的情况考量使用哪种代码。
*** 关于代码的境界问题，上条记录已经提到了，将数据提到参数里面是最好的做法，提到函数头部次之，但其实也要根据实际情况而定。有个普遍的规律可循就是——一旦出现数据，先看看将这个数据提到参数里面是否合适，也就是别人是否会传递其他的参数过来以提高可定制性，如果答案是否的话，将这个数据提到函数前面反而会更合适。
*** lisp虽然具有几乎是所以编程语言里面最强的抽象能力，能够以最短的代码解决最复杂的问题。但解决最简单的问题的时候却反而不如c语言这种底层语言好用。
*** lisp这种语言可以在语言中自动维护所用到的环境，不需要显式的去声明，而c,c++这种语言是不行的，它必须自己去定义与维护这样的环境，这样就使得环境与求值无法分隔开，写出的代码不如lisp的优雅，或者即使写出同样优雅的代码也要比lisp花费更多的代码行。
*** 其实用c++来写lisp的环境模型最大的问题就是自己要手动的去管理，去切换当前所使用的环境，不像lisp那样环境的切换是自动的。
** 2015/02/06
*** c++缺乏将代码作为数据的能力，即使是使用模板，实际上也做不到这一点，使用模板跟使用函数参数实际上是一样的，使用模板只会徒增复杂性，实际上还不如使用函数参数。
*** c++函数里面的变量（包括参数与函数体内部的局部变量）是在下一次函数调用的时候被清掉的，如果在两次函数调用中间做一些其他的操作但是不调用函数，那么上一次函数调用的数据是不会被清掉的。
*** 对于c++语言的每一次函数调用过程实际上是这样实现的——每一次调用都是现根据EBP找到基地址，然后用ESP操纵这一块内存(实际上就是进程启动时创建的栈内存)的数据，再加上从从EIP得到的指令，两者共同协作完成程序的执行的。正因为如此，没当下一次函数调用开始时，由于EBP很少变化，所以原有的数据不需释放，直接就可以再利用用来进行新的函数。还有一个一般的规律，一般数据在低地址，而指令在高地址，至少32位程序是这样。还有正因为所有函数调用使用的是同一块内存地址（栈内存）所以，下一次函数调用会冲掉上一次函数调用的数据，因此对于有些需要保存起来不被冲掉的数据需要用全局变量或是静态变量来使之保存在其他区域，这样就可以一直使用了。
*** 使用static变量作为函数参数是无效的，虽然编译不会报错，但实际上这个变量依然是保存在栈内存上，下一次使用依然有被冲掉的风险的。
*** 实际上，引入lambda与fucntion之后的c++在函数式编程的支持上是一点也不输于其他的函数式编程语言的。通过函数嵌套，传递引用，使得c++也能在在求值的过程中建立起一个新的求值环境，然后可以在新的环境中使用环境中新加入的值，所唯一不同的必须将值保存在变量中才能继续使用，c++并不支持保存函数参数的那个临时变量。这是因为lisp这种语言在计算时无需考虑符号的存储问题，不管符号的内容是什么，但c++是不能的，c++必须计算与存储一起抓才行。
*** 像lisp这种动态语言支持保存运行环境，也就是将变量与函数一起给保存下来，然后将这一环境返回（返回lambda函数）赋值给其他的变量，然后在同一环境上继续运算。原始的c++语言无法实现这种功能，但自从有了lambda与function以后，c++也拥有了这种能力。
*** 给自己的思维做个手术，将循环式思维更改成为迭代式思维。
** 2015/02/09
*** 实际上，循环与递归只有一线之隔。它们两者的核心都是重复执行相同的代码，不同的地方是：
    1、循环是在循环体内部重复执行代码，递归是在函数调用外部重复执行代码；
    2、循环跳出重复执行的条件是条件变量不再满足条件，而递归跳出循环的条件是在所有的循环执行通路中留出一个口来跳出循环执行。
    两种形式的相互转化也不太困难，只不过要注意，普通循环要重复的代码是写在循环内部的，而递归循环的条件是写在代码外部的，而且递归循环必然要留出至少一条执行通路用来结束递归的执行。递归比循环有更高的抽象登记，更简洁强大的表达能力，但比普通的循环不好写些也是不争的事实，所以各有优缺点，要谨慎权衡使用。
** 2015/02/10
*** 递归真的是一种编程方法，什么语言都可以使用这一方法。这一方法虽然在lisp中使用的比较多，但真的与语言无关，c++一样可以使用，而且使用这种方法编写出来的代码简洁高效，更加优美，就是不容易理解。
*** 如何防止机器自动模拟人操作电脑？常见的方法就是验证码，验证码的本质就是出一些人很容易识别但电脑不容易识别的题目。由于图像识别现在尚不完善，因此这一方法暂时可行，但随着图像识别算法的进步，这一方法也面对着严峻的挑战，急需另一套方法来替代这种传统形式。
** 2015/02/11
*** 何为抽象？这是一个经常使用但真正理解它的人没多少的东西。实际上抽象就是隐藏细节，一个东西你一旦进行了抽象，就应该直接用抽象出来的工具去思考而完全忽略细节。它实际上建立起了一个屏障使得我们能站在更高的层次上，从另外一个角度来思考问题。一旦抽象出新工具，就应该对所要解决的问题重新表述，当新问题的各个部分都可以得到对应的解决方案的时候，这个问题就解决了。
*** 在不知一门语言如何实现的时候如何保证自己所编写程序的效率？很简单，尽量调用基础的运算符，尽量减少调用的次数。因为对一门语言来说，为了保证语言整体的优秀，其基本运算符必然是经过精心优化的产物，其效率必然是很高的，使用这些算符而且控制使用次数必然能够使得程序的效率达到极致。那么对一门语言来说，什么算符算是基本算符呢？下面对常见语言简单说下，比如对c与c++而言，基本的肯定就是指针操作，位运算这种；对lisp而言，最基本的肯定就是七个基本操作符。
*** 使用变量来将运算的结果给保存起来，需要的时候直接取用，这样能够减少大量的重复运算。不要小看这一性质，很多重要的场合这一性质能够发挥巨大的作用。比如lisp求值的环境模型使用的应用序而不是正则序，五大算法之一的动态规划算法也会经常利用这一点减少重复运算。如果能好好利用这一性质能够起到非常良好的效果，比如数据检查工具里面可以提前将文件夹的目录结构保存起来，然后随时取用，这样就避免了重复求值引起的无谓时间消耗。这是一种典型的以空间换时间的方法。
*** 函数式编程中，代码提前return实际上是一种对整体演算过程的一种打破，尽量少用。
*** emacs最强大的地方并不在其编辑能力上，论编辑能力，emacs是比不上vi的。emacs真正强大的地方在集成能力。这货就是一个通用的前端，任何程序都可以很容易地集成到这里面来，从而再也不用在各种乱七八糟的窗口里面切来切去。就像其他操作系统里面的shell。不过shell是使用命令行来集成各种工具，无法编辑比较复杂的命令行，虽然可以调用vi来解决这一问题，而且一旦要在编辑的过程中调用其他的程序，vi是无法很好的胜任的。emacs不同于shell，直接将编辑环境作为最顶层的环境，从而提供了比命令行shell更加灵活强大的控制能力。
** 2015/02/13
*** 函数里面可以定义函数这一性质并不是一种玩具，而是一种新的抽象方法与工具。这一功能的支持好处多多。首先这是一种全新的组织代码的形式。有了之一功能的支持，再也不用把一些只调用一次的接口函数放到函数外边，扰乱代码的结构了。直接定义在代码里面，形成局部函数，然后调用就好了。其次可以利用这一功能实现对代码参数的重整，去除一些为了实现代码功能而增加到函数参数上的丑陋参数，给这些参数一个缺省值。
*** 要善于使用“按照愿景思维”，这将使你在一开始就站在较高的层次上思考问题而无需关注尚未实现的技术细节。
*** 很多功能语言不提供，但你可以自己来给语言添加这个功能，比如初始化列表这种东西，虽然vs10尚不支持，但可以通过自己的变通，使用字符串来变相的实现这一功能，这是任一高级码农所不可或缺的能力。
创造力并不是来源于中彩票似的灵感突发，而是来源于长期的思考累积，需要不断的进行跳出常规似的思考训练，才能在真正碰到问题的时候更快的灵光一闪。
男人与女人实际上是两个性格极端。男人是危机型性格，女人是享受型性格。当乱世时代的性格会偏向于男性，因为这是一种在瞬息万变的时代杀伐果断，不婆婆妈妈的性格。而太平盛世时代的性格会偏向女性，因为这是一个只需享受，无需考虑太多其他东西的时代。
名主与专制实际上是互补的一体两面，并不是像大多数人说想的那样名主就一定好于专制，名主意味着对任何事所有人都要决策表态事情才能进行下去，任何正常人都知道这种执行模式绝不会比单人独裁来的高效。你可能会反驳说名主代表了绝大多数人的意愿，做出来的决策肯定比独裁来的高质量。也许在一些比较简单的决策上确实是这样，但当问题复杂之后，只会有少数的人真正地理解这个问题，这时候让那些根本不理解问题的人来决策就是个天大的笑话了。所以，全面的名主只能建立在所有人都确实理解这个问题的基础上，这根本就是幻想中的世界。真正成立的统治制度只能是建立在少数人的独裁环境下。
为什么从来没有一个时代能永不倒下？这个问题并不是一个以前的统治体制不对就可以解释得通的，真正的原因是在时代建立的初期人们为了战胜更大的困难，往往能够同心同德，甚至发展成为一个时代的价值观。而当天下大定，人们会往更高的层次追求，会变得越来越自私，为了一己之利不计后果，这才是时代崩塌的根源。归根到底是社会整体的意识决定的。
** 2015/02/28
*** 使用函数参数来作为返回值与直接使用函数返回值来作为返回值有一个非常重要的区别就是——使用函数参数作为返回值是过程式编程，而使用函数返回值来进行返回是函数式编程。函数式编程可以更好地支持递归，而过程式编程只能支持迭代式递归，这两者虽然表面上看起来差不多，但其实在表达能力上有着很大的差别。
