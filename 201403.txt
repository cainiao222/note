* 2014/03
** 2014/03/09
*** 在判断指针是否为空时最好将NULL写在前面，防止漏掉等号照成if里面的语句永远得不到执行的情况。

*** 关于赋值语句的返回值问题，返回的是等式的值，比如i=0,此时放回的是0；i=1返回的就是1，并不是赋值成功就返回0（假），赋值失败就返回1（真）。

*** 百度谷歌是搜索框是可以当做计算器使用的，比系统自带的计算器要好，因为可以编辑，支持高级一点的运算等。

*** 关于命名空间的使用要注意：命名空间不能使用过多，想using namespace ...;这样的句子不要出现太多，因为使用的越多，冲突的几率越大，有时发生了冲突，但你直接从程序上是很难看出来的。良好的习惯是像std这种比较短的命名空间就不要using了，直接在每次使用的时候加std：：吧。

*** 每个项目（不是解决方案）的包含文件目录，库目录，包含的文件，以及其他很多设置等都是保存在项目文件中（.vcproj），打开此文件即可很清楚的看出来，很容易懂。此文件主要是由很多ItemGroup,ItemDefinitionGroup,PropertyGroup组成的。包含目录与库目录在<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug（或release）|Win32'">，包含的库在<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug(或Release)|Win32'">的Link子项目下。

*** 关于vs解决方案的版本转换08转05比较简单，10转08的没试过，10转05比较麻烦，以为两者的项目文件的结构有很大的不同，但转换的方法还是有的，只不过麻烦点。具体的方法如下：先用vs10打开项目文件，根据此项目文件的内容用vs05建立一个与之相同的解决方案与项目目录，然后将所有的文件复制，对于有冲突的几个文件，跳过解决方案与项目文件，覆盖源代码文件，最后再修改一下设置就可以了。

*** 关闭文件时往往会有一些最后写入总体属性的操作，如果忘记了，虽然程序最后结束后一样会自动关闭文件，但会漏掉一些值的写入，使得打开时出现问题。比如dbf文件。

*** 指针移位？一个东西做几件事，夹杂冲突。不能提前读到vector中，因为地址可能因为添加字段而变化。


*** #define xxx。这种形式仅仅定义标示符，放在函数等前面什么意思都不做，仅仅提示别人这是一个什么什么，这是一种很好的用法，使代码的可读性更好。

*** 有时修改代码比自己重写代码更头疼，一旦有比较大的改动时有时即使是重写也是值得的，否则你会淹没在一堆小的修修补补中，非常容易改的出一堆小问题。

*** 一个程序不要有几种风格（命名风格与编码风格），否则你会把自己给弄糊涂。不要因为写了一半觉得程序风格不好就去改风格。

*** 需求之难难在什么地方呢，难在空想与做之间的距离。

*** 关于赋值的方法有很多，不止只有等号赋值一种。其他常见的方法有使用函数参数赋值。

*** 子类对象以及子类对象的指针可以直接赋值给父类对象，不用做转型，但指向子类对象函数的指针不能直接赋值给父类对象函数指针，需要做强制转型，做过之后就可以使用指向父类函数的指针（加上父类或子类对象，这是类函数指针的调用要求）调用子类的函数了。

*** 怎样尽可能地减小耦合度，有一个原则很重要，就是尽可能地缩小变量的作用域。比如可以直接在函数参数上写的变量，不要写在类里面。可以写在函数里面的变量，不要写在全局变量里面。其实作用域的交叉与污染几乎可以说是造成耦合的根本原因，但有些时候我们需要耦合，因为程序本身就是一群变量输入在一起互相配合作用得到输出的结果，所需要注意的是不要将不相关的程序也放在一起，这种耦合就是不需要的。实际上public,protected,private,函数参数，类属性等这些控制的都是作用域而已。

*** 软件项目的耦合应该只体现在参数上，通过类似管道的方式来进行处理，这种才是将耦合降低到最低程度的方法。

*** 优先考虑使用函数参数传递数据，只有在数据必须在函数间共享的情况下才会考虑将数据作为类的成员。

*** c++中，转型实际上仅仅只是一个内存偏移。在当前对象的内存块中找到新类型的那一段内存将地址赋值过去，这样就完成了转换，如果对象中没有新类型的内存段，则类型转换失败。要想存在那个内存段，一般方法是继承，当然使用内存复制也是可以的。

*** 如何使程序再窗口与控制台之间相互转换完全不需要修改核心逻辑？秘诀就是尽可能地将代码往自己写的类里面塞，不要在窗口的dlg类里面写上过多的东西。

*** 碰到稀奇古怪的错误看不懂时，直接采用二分法查找出现问题的代码位置就行了，很多时候不用再网上搜来搜去的。

*** DONE 多加参数合法性判断，这样能大大减小程序异常输入时崩溃的情况，在不懂程序的人看来，崩溃是非常严重的问题。虽然对程序员来说，崩溃非常有利于程序员寻找错误，发现隐藏的问题。

*** 写MFC程序的时候，如果要求程序便于移植到控制台，就尽量不要将核心逻辑写在dlg类里面，dlg里面只需要完成获取数据输入的工作，其他代码尽量都写在自己另开的类里面。在自己的这个类里面，尽量少调用windows,mfc的类与函数，这样才能便于移植。

** 2014/03/17
*** 存储中间过程数据而不仅仅是输入数据，将这些数据分发到不同的机器上，这就是分布式系统区别与一般的文件系统，实现其高效特性的秘密。

*** 你永远想象不到你所写的软件的奇葩用户会搞出什么奇葩的输入，所以你必须把所有的情况都给考虑到了，才能保证程序的正确运行。当程序碰到某些情况不知道怎么办了，程序唯一的做法就是——崩溃。这会给用户造成非常糟糕的用户体验。很多2b用户明明是自己的错误，但他会返过来骂写软件的人愚蠢。

*** 事不过三，三则重构。

*** 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类能够理解的代码，才是优秀的程序员。

*** 重构的第一步————为即将修改的代码建立一组可靠的测试环境。

*** 重构的基本定义：重构是在不改变软件可观察行为的前提下改善其内部结构。但这其实只是最基本的要求，要想真正让重构技术发挥威力，就必须做到“不需了解软件行为”如果一段代码让你容易的了解其行为，说明它不是那么迫切地需要被重构。最需要被重构的代码，你只能看到其中的““坏味道”，而无法看懂它。通过重构，你能不断简化这圾代码的逻辑，到后来就可以看懂了。

*** 代码的“坏味道”：
+ 重复代码(*)
+ 过长函数(*)
+ 过大的类(*)
+ 过长参数列（*）
+ 分散式变化(一个变化需要修改类里面的多个函数*）
+ 霰弹式修改（一个变化需要修改多个类*）
+ 依恋情结（函数对某个类的兴趣高过对自己所处的类的兴趣*）
+ 数据泥团（相同的几项数据总喜欢待在一块*）
+ 基本类型偏执（不喜欢封装，总喜欢用基本数据类型扎堆*）
+ switch惊悚现身（多次看到switch，解决方法：用多态来替换*）
+ 平行继承体系
+ 冗赘类（多余的无用类*）
+ 夸夸其谈未来性（过度设计*）
+ 令人迷惑的暂时字段
+ 过度耦合的消息链（过长的调用关系*）
+ 中间人（过度委托）
+ 狎昵关系（过度喜欢探究其他类的私有成分）
+ 异曲同工的类（相同功能，不同类名*）
+ 不完美的类库
+ 幼稚的数据类
+ 被拒绝的遗赠
+ 过多的注释（解决方法：对注释分函数*）

*** 代码逻辑的简单容易理解与代码的效率很多时候是一个矛盾的事情。在多数情况下，代码逻辑的简单比效率要重要，写出容易理解的代码远比写出效率高却难以理解修改的代码要好的多，而且容易理解的代码后期优化的空间相对大的多，所以注意代码逻辑的简单，不要太注意效率。

*** 图表在很多时候能够很方便的使我们发现现有结构的问题，不会使用图表确实是很大的一个损失。最有用的图表有如下几个：时序图，架构图。

*** mfc的控件对齐的逻辑是这样的，以最后选择的一个控件为基准，比如两个控件一个在上面一个在下面，若先选择上面的控件再选择下面的控件，再按向上对齐，mfc会把上面的空间就移动到下面，因为后选择的是下面那个控件。反之，如果先选择下面那个控件再对齐，情况就是相反的。

*** 不要将几个功能杂糅在一起写，因为即使是相似的功能在写代码时也会有自己的不同之处，强行兼顾只会写出非常糟糕的代码。

*** 使用子类对象调用父类函数的方法————比如说类B继承自类A，要想在类B中调用类A的方法，如下"b.A::fn();",这样就可以了，如果函数fn是static函数还可以更简单一点，直接"A::fn();"不需要对象就可以调用父类的方法了。这其实给我们一个很重要的启示，其实在类里面不止是有一个隐含的this指针，还有一个隐含的“"ClassName::"这样的一个作用域，很多时候我们会忽略掉这个东西，但有时候我们需要指明这个东西以使得函数调用可以变得更加灵活强大；只有调用static方法才不需要变量名，调用其他任何非static方法都需要显示或隐式地指明变量名，只要此方法不是私有的，在类里面就可以随意调用，只要此方法是public的，在类外面就可以通过对象随意调用。

*** 子类可以访问到指定父类的非私有命名空间。

*** 类的方法与类的属性一样也有类型，只是这种类型一般被隐含了。既然是类型就可以用此类型来定义变量与赋值调用，很多非常高端的技巧比如反射泛型实际上也就是玩的这个游戏而已。

*** 类是对象的抽象，泛型是类的抽象。泛型是语言的一种机制，当我们实例化类对象时，类型会首先被作为参数被用来填充泛型占位符，然后再实例化类对象。由于这一切是在编译阶段完成的，所以不会影响到最后生成的程序的效率。但大量使用泛型会增加编译时间，因为类型替换是需要时间的。

*** 函数模板的性质
1) 函数模板并不是真正的函数，它只是C++编译生成具体函数的一个模子。
2) 函数模板本身并不生成函数，实际生成的函数是替换函数模板的那个函数，比如上例中的add(sum1,sum2)，
    这种替换是编译期就绑定的。
3) 函数模板不是只编译一份满足多重需要，而是为每一种替换它的函数编译一份。
4) 函数模板不允许自动类型转换。
5) 函数模板不可以设置默认模板实参。比如template <typename T=0>不可以。

*** 类模板的性质
1) 类模板不是真正的类，它只是C++编译器生成具体类的一个模子。
2) 类模板可以设置默认模板实参。
3) 与函数模板一样，类模板也不是只编译一份满足多重需要，而是为每一种替换它的类编译一份。

*** 函数参数与返回值与函数体都是可以是const的，对应不同的位置，每个位置对应不同的部分不能被修改，尤其要注意函数体是const的情况，如int fn()const;一旦一个函数体被标记为const，在这个函数体部分只能读函数作用域部分的变量而不能修改这些变量的值。

*** MFC其实不麻烦。他还是普通的C++程序，只不过他加上了一点额外的代码，这些代码中最神秘的就是消息映射，而消息映射其实也简单，只不过是将windows消息绑定到指定类的函数上的一种代码宏而已。你完全可以按照标准c++的写法写出自己的代码逻辑，然后再使用消息映射宏将自己写的代码入口绑定到指定的消息上。

***  编程原则有很多，但真正有实用价值的并没有多少。具体有以下几条：
1) 一个函数应该只做一件事，所有语句都在一个抽象层级。
2) 类应当短小，应当遵循单一权责职责（srp)。
3) 注释应该尽量少，尽可能地以函数代替注释。

*** 实际上直接通过虚函数就可以实现消息系统，但这样做会产生很多很多的虚函数，在父类框架上面调用每一种消息的映射函数，通过虚函数的特性以实现调用子类的函数，而实际上大多数程序只是处理了几种消息而已，大量的代码被闲置，这显然会严重影响性能，而且子类与父类的耦合也太高了。MFC为了避免这一点，采用了消息映射机制。消息映射机制实际上就是定义了并实现了两个函数————一个虚函数一个静态函数。父类调用这个虚函数以调用静态函数，获取子类静态对象里面的函数地址，从而完成消息映射，极大的降低了父类与子类的耦合，减少垃圾代码，提升了性能。（类与类之间最好只有一个接口用来通信，这样能大大降低耦合，如果有多个接口，耦合就会非常高）。

*** MFC的消息映射宏DECLARE_MAEEAGE_MAP实际上是声明了两个消息映射，GetMessageMap与GetThisMessageMap,前者是整体的消息映射，虚函数，后者是当前类的消息映射，静态函数。通过BEGIN_MESSAGE_MAP与END_MESSAGE_MAP宏实现这两个函数后，MFC会把当前类的消息映射加入到整体的消息映射，当特定消息发生时，MFC会查询整体的消息映射，将消息发送到正确的类的正确函数上。

*** 对一个东西的理解非常重要。何谓理解？理解就是掌握这个东西的层次结构，实际上就是理解其树形结构，一级一级的划分。比如Excel表，一个excel就是一个数据库，里面有很多表sheet表,每个sheet表里面有很多sheetRange,sheetRange就是sheet里面的某一块，然后再用下标指明是哪一格，再通过不同的属性与方法就可以对这一格进行操作了。

*** static函数是一个入口，通过此入口可以连接到其他的程序调用，同时使得调用看起来简单清晰。要注意static函数是不能访问本类的非static函数的，因为没有对象，但如果有了对象（通过参数传递或内部定义），static函数和其他的函数没有什么不同。

*** 不要以点线面体的方式来理解0123维数组，这样会局限你的思维，应该采用分层的方式来理解，一级一级逐步细化，这样理解起来无论多少维就都变得非常简单了。

** 2014/03/24
*** 在使用不熟悉的库是不要使用连点。这样做虽然有时能少写几行代码，却会让你不会去注意到每一次调用的函数的返回值类型，非常不利于对类的理解。而且这样做也会导致代码提示一团糟，非常不便于找到自己想找的函数。

*** 迭代器模式能够隐藏遍历时对象的内部表示，使你可以动态的改变对象的存储结构而无需修改遍历方法。当你加减对象的长度，甚至加建了行数目后依然可以正常遍历。

*** 越抽象越强大。抽象实际上就是分类，越抽象越能将隐藏对象细节，从而给程序员越大的灵活度，给用户越简单好用的用户体验。

*** 尽量不要出现两层循环，碰到这种情况应该继续抽象，考虑看能不能把内层循环抽象出一个类，典型的例子就是将表格里面的一行给抽象出来，这样读写每一格时就不会有两个循环了。
** 2014/03/25
*** 在多线程程序下程序出错的根源在于对于任意运算来说，cpu与内存之间的关系类似于cpu读写文件的情况，同时读写同一文件容易出错，同时读写同一内存也一样容易出错。

*** 匈牙利命名法最前面的类型信息以前是为了让人们知道变量类型。在现在都可以转到定义看类型的情况下好像没啥用了，但其实不是的，现在最大的作用是对变量进行分类，因为当你需要一个变量时脑子里回想可能的变量名最容易想到的就是变量类型，只要打出类型前缀，就可以很容易地找出你所需要的变量了，这就是新时期匈牙利命名法的类型意义。

** 2014/03/26
*** 如何看代码？有静态查看与动态调试两种方法，后者要远远优于前者。如果代码结构清晰整洁，改分的函数都分了，直接根据输入输出与函数名就可以最快的理解程序，看高层就够了，如果需要深究再看想深究部分的底层代码。在这种方法下，函数越短小，理解起来越容易，不要将不同层次的代码放在一起。

*** 对同一个问题有很多种不同的切分方式，良好的切分方式能够尽可能地降低代码间的耦合，提高可拓展性，可维护性，可移植性。这也就是对同一个问题，有很多不同的库实现，这些库真正的差异所在。要非常关注这一部分，这是构建大型程序的基本功。

*** 配置网络不需要界面，一般都是通过直接打命令来完成的。
*** 如果做某一件事比较复杂，而又想清楚地给别人讲清楚的话，最好分层次的讲，先讲几个大步骤，在每次解释其中一个步骤。不要每次讲一个很细的点，这样根本无法理解。

** 2014/03/28
*** 如果每天起来都报着“忘掉昨天，重新做人”的想法，那会怎么样？这很有可能是改变性格的关键。

*** 实际上服务，不管是windows的还是linux的，都只是在普通的程序上加了层皮，多实现了几个启动，停止，重启等方法，隐藏了界面而已。没有界面不能控制，完全可以忽略掉这一优点，直接用普通的程序来代替服务。直接在服务上面点右键，查看属性，就可以看到是把哪个程序给包了这层皮。

** 2014/03/30

*** windows服务实际上只是一个程序链接，并不是程序复制。当我改变了所链接程序的行为后，服务的行为也会随之改变。

*** vs的intelligence智能提示实际上是通过扫描外部依赖项，即所有引入的头文件来实现的，这一点可以从解决方案里面的外部依赖项文件夹里面看出来，这实际上给了我们一个非常好的从大库如boost中剥离小库的方法，将所有外部依赖项的头文件以及其实现文件给复制出来放到工程里面就实现了这个方法。被代码的任何一个头文件引用过的头文件都会出现在这个地方。

*** c++0x新特性主要有以下几个：bind,function（位于functional头文件中），auto,lambda。这几个新特性可以说就像是一套工具，一起使用可以大大简化函数编写的灵活度。

** 2014/03/31
*** 尽量减少磁盘IO次数，这个操作非常耗费时间，宁愿多花一点内存，将数据暂时缓存在内存里，达到一定程度后再进行IO,这样可以大大加快程序速度。

*** 一切皆服务。实际上MPI的原理就是在每台电脑上开启一个smpd服务并监听来自其他电脑的命令，获取到这些命令后再用类似system("")这种类似的技术调用本地机器上的程序而已，更进一步，其实就是一个ssh协议的封装，使得程序在几台机器上同时执行而已。

*** 实际上所谓的分布式也是一个服务。其过程可以简要描述如下：首先将程序的代码和数据拆分成很多份，然后通过类似mpi这样的服务在很多机器上面运行，不同的机器上面运行不同的程序，在程序运行期间不用也不能向外界传出信息，运行完成后通知服务，然后服务在给这台机器分配其他的任务，一直到程序结束。