* 2016/08
** 2016/08/02
*** 实际上jsx与js的模板字符串是一样的东西，这也就是可以用babel编辑jsx文件的根本原因。
** 2016/08/03
*** 代码是用来制定规则的，类似于计算机里面的法律。而数据是用来遵守规则的，是被代码管理的对象。前者编程（program）而后者被编程（be programmed）。代码制定了规则，然后所有的子元素只要按照这个规则来，代码就能够帮你做很多额外的事情。编程的世界，应该尽可能的减少代码，用最少的规则去约束下面的对象，同时提供最强大的功能
** 2016/08/07
*** 在原有API接口上进行更高层次的封装，用更高层的抽象来解决问题。
*** flex布局几乎是万能的，复杂的布局几乎都可以使用它来解决，它是html非常有限的几种容器布局中的一种，非常的有用。
*** 实际上，在现存的所有html的布局方式中，flex可能是唯一一种容器布局了。实际上，在flex布局出现以前，布局这个东西也许是走上岔路了。几乎所有其他的布局都只能影响到自己的布局，并不能影响其子元素的布局，这也许是之前的html布局能力如此差的最重要的原因。
*** 行内元素与行内元素之间本来就是有间距的，这个间距是由于空格导致的。这常常容易使人困惑，无法实现准确对齐，但是如果将父级设置成flex布局，这个间距就不再存在了。
*** 当父容器被设置成flex布局之后，不管其子元素是行内元素还是块级元素，都会变成flex item，一个类似于块级元素的东西，这个东西可以设置宽高，不会自动换行，外内间距都可以被设置。
** 2016/08/09
*** webeditor核心逻辑――――使用一个全局变量存储当前所有图层，维护这一图层并使用这一图层进行绘制。
** 2016/08/10
*** js的call与apply的作用是劫持一个方法为己用，实现功能的复用。我们可以抽象出很多经常要使用的公共方法，然后在适合的地方使用call与apply借用这些方法，实现制定对象上功能的复用。
*** mixin是比类复用更加精细的一种复用方法，它通过方法拷贝将一个对象中指定的方法拷贝到另一个对象，实现方法的复用。
*** mixin与继承并不冲突，因为继承更多的时候表达的是一种语义上的继承，而mixin表达的是实现上的继承，这两种方式可以根据实际情况混用。
** 2016/08/11
*** 实际上，模式匹配也叫解构，原理就是从一个结构已知的数据中提取出各个部分的值，由于数据与变量之间有着良好的对应关系，因此我们可以快速的使用模式匹配来从一个复杂的数据结构中取出我们想要的值，实现多值与多变量的映射。
*** js为什么会有箭头函数这个东西出现呢？因为长久以来，js中的this都是动态绑定的，而不是依据词法绑定的，这很多时候并不会有什么问题。但是有些时候，我们确实需要使用词法中的this，
** 2016/08/12
*** 实现可变的第一步是――――将数据封装成函数，哪个数据需要变化就应该讲这个东西封装成函数。
*** 什么是cookie？cookie是一个作用域比较特殊的的全局字符串，说它特殊是因为它不是在代码块结束的时候回收的，而是过期回收的。它绑定于域名，我们可以随时使用"document.cookie"来读写某个域名的cookie。即使我们关闭了网页，网页的cookie依然不会被删除，所以我们可以用它来保存用户的登录信息。当我们打开一个网页的时候，这个网页的cookie会被发送到服务器端，服务器端可以解析来自浏览器的cookie并做一些特殊处理。由于cookie是一个字符串，所以其实读写网页cookie里面的字符串是比较费劲的。默认cookie的过期时间是当浏览器关闭时。
*** cookie与session的最终目的都是用户状态保持，都是为了弥补http协议无状态的缺陷而产生的变通方案。不同的是cookie是存储在客户端的，而session是存储在服务器的。
*** cookie的原理是拓展http协议，一旦发现存在满足条件的cookie就将cookie信息附加在http请求头上发送给服务器；session的原理是使用一个散列表来存储每个用户的session信息，并将session id保存在客户端cookie来辨别当前请求是哪一个用户发出的。
** 2016/08/13
*** 为什么会有uri编码？是为了将控制字符与值字符区分开，以便于解析。我们一般需要对什么进行uri编码？很简单，对参数值。这样就能保证不会意外的将参数值给拆分开。
*** 关于url编码，实际上浏览器本身自己就会对url地址进行编码，只是浏览器的编码规则比较奇特，很多时候未必符合我们的预期，因此需要我们自己对url地址进行编码。常用的编码函数有encodeURI与encodeURIComponent,这两个函数的主要区别是前者是对整个url地址进行编码，它不会编码url地址中的"：/?&"等分割符进行编码；而后者一般用于对url地址中的参数值进行编码，它会把地址中的分隔符也进行编码。
*** lisp是完全不区分代码与数据的，但js很多时候还是区分代码与数据的。比如对象的key就是一个数据而不是代码。这会影响灵活性。比如：
    1) 我们经常碰到"{name:nameValue;value:valueValue}"这种对象，如果key可以是代码的话根本不用这么麻烦，直接"{nameValue:valueValue}"就可以了，根本不用冗余的name与value。
	2) 我们创建了这样一种对象{abc:def},
*** es6的模板字符串实际上是lisp中的宏，它能够轻易决定一句话到底应该是数据还是代码。
*** TODO 多层循环如何抽象？
** 2016/08/15
*** 抽象的第一步就就是将数据编程函数。
*** 数据是易变的东西，代码是不变的东西，编程的最终目的是将写代码变成写数据。
** 2016/08/16
*** 递归具有无与伦比的抽象能力，因为递归可以根据具体情况控制执行流，是活的。而循环是死的，一旦写出，就始终在一个上下文中执行，无法控制执行流。
*** 递归与循环最关键的差别在于上下文，递归可以切换执行上下文，而循环始终在一个上下文中执行，可以说就没有上下文的概念。这一差别会带来什么具体影响呢？影响就是一旦循环复杂之后，变量就会变得越来越多，依赖关系就会越来越复杂，难以管理甚至无法管理。还有一个关键差别就是这两种写法的思维方式是不一样的。递归允许我们在更高层的抽象上思考问题，而循环就做不到这一点。
*** 递归与循环具体表现在代码上有什么区别呢？比如：
	1) 要控制循环层数，也就是循环层数不确定的情况，不用递归就很难写出来。这方面实际上有很多的例子，比如reduce、流（有限流与无限流）、管道、Promise等，你会发现这些东西都离不开递归。
	2) 要控制循环执行流，比如树的遍历。
*** 实际上只要理解了为什么正则表达式的计算能力不如上下文无关文法，就理解了为什么不是所有的递归都可以在不借助递归数据结构的情况下化解为循环了。      ――――vczh《所有的递归都可以改写成循环吗？》
*** 递归有两种情况，直接递归与间接递归。直接递归是直接在函数里面调用函数本身的递归。间接递归是在函数里面调用了另一个函数，而另一个函数又调用了这个函数本身，这种情况实际上也很常见。
** 2016/08/18
*** 函数分组成为类。当函数多了之后，分组是必须的要求，因此才有了类，但类概念的提出又引入了新的东西――――属性(Attribute)，这也许是历史的谬误。
*** TODO 在代码里面，如何组织与管理数据，这是一个非常困难的问题。
*** 写代码实际上都应该有两个层次，业务层与技术层。上层是业务层，下层是技术层。大多数的项目刚开始的时候都会出现只有业务层，没有技术层的情况，这样会带来什么问题呢？一大堆业务重合会导致出现大量的重复代码，难以维护和复用。这种时候需要沉淀，从千头万绪的业务代码中抽取出公共的部分来复用，这就是技术层了。业务层面向具体业务，技术层面向通用的业务实现。
*** 实际上代码分层是可以从一开始就做起的，写业务代码的时候要有意识的抽取技术代码。首先从函数命名上就应该区分出来，应该总是写两个函数，外层函数是业务函数，这个业务函数的实现会调用技术函数，这样代码就自然而然的分为两层了。
*** 实际上，编辑器就是一个状态机，它有一套自己的状态循环，然后我们需要这整个状态中添加新的状态来改变渲染显示以及编辑数据，达到我们自己的目的。
*** 实际上，js中的this又叫执行上下文(context),普通的函数与箭头函数最大的不同至于普通函数的执行上下文是在运行期动态改变的，而箭头函数的执行上下文总是绑定在定义时的对象上。
** 2016/08/19
*** BFC(块级格式上下文，blocked format context)具有这样的特性：它不会压盖到别人，也不会被别人压盖。这一特性使得它非常适合于用来做容器，不论它内部的子元素使用浮动、绝对定位、flex等任何方法都休想逃离出它的范围。
*** inline-block与block实际上除了换行以外，其他的地方是完全没啥差别的。inline-block能够使得我们能够设置行内元素的宽高边距等属性同时又不改变这个元素的不换行属性。（inline-flex同理）
*** UI控件的回调函数都应该用单独的函数，不能直接用一个匿名函数，因为你总是很容易的碰到需要手动调用事件处理函数的情况，这种情况就坑爹了。
** 2016/08/20
*** 抽象是编程世界中最重要的概念，如果不能很好的理解和运用抽象，那么你就不可能真正理解编程的精髓。
*** 面向对象的三大特性（继承、封装与多态）这三个概念中最重要的其实是多态。继承其实是可以没有的（例如js），封装其实也是可以没有的（例如CLOS），但多态是必须要有的。多态允许我们使用统一的方式处理不同的情况，从而简化了复杂度，提高了开发效率。
*** 我的学习思路实际上跟别人不大一样，很多人学习是遵循着前人的脚步，一步步的提升，而我是自己按照自己的思路去学，遇到问题再去探索更好的方式，再去学别人的东西，这样短期内虽然可能落后，但长期下来绝对不会有问题。
** 2016/08/21
*** 从某种程度上来说，使用断点调试也许是一个非常糟糕的习惯。因为依赖断点调试很容易让我们犯下头疼医头，脚疼医脚的误区，不从总体上去思考问题产生的根源而只是对报错情况做个特殊处理，这样类似的错误还会一而再的发生。
*** 只在同一个层次写代码，一个代码文件绝对不要涉及太多的层次。
** 2016/08/22
*** 关于javascript的作用域链。作用域链是用来解析标识符的（实际上就是查找变量值）。当定义一个函数的时候，js引擎会将函数以及函数使用的外部变量一起保存起来，称为闭包，当调用函数的时候，对函数中的变量，js引擎就会沿着。
*** 关于javascript的原型链。实际上原型链类似于作用域链。它不同于作用域链的地方在于它是不是用来解析变量，是用来继承的（实际上就是解析函数调的）。当一个对象的方法在对象本身不存在时，js引擎就会沿着原型链去查找构造它的函数对象中是否有同名方法
** 2016/08/23
*** 写函数的时候应该尽量做到最少依赖，不要依赖于其他的库，这样写出来的函数的重用性才会非常好。
*** 漂亮的函数应该让读者一眼就知道他在做什么以及怎么做的。注意不仅是要让人容易看出它是在做什么，还要容易看出它是怎么做的。前一点一般只需要注意设计函数的名称以及参数就可以做到了，要想做到后一点就没有那么容易了，它需要我们留心去写函数的实现，不要过多的hack，不要写不常见的写法，不要有不同的层次，要求非常高。
** 2016/08/25
*** TODO 纯函数的可组合性也许才是函数式编程的最大价值所在。这种可组合性表现在：
	1) 对数据进行封装，以产生灵活的数据。
	2) 对函数进行封装，使得我们可以在原来函数所做的事情的基础上再做些其他的事情。
*** 实际上redux的核心还是非常简单的，它就是使用store来将数据与渲染连接起来，同时通过reducer开放中间的接口，允许我们根据用户交互对数据进行修改并将这个修改在界面上显示出来而已。可以概括如下：
originalStore --> dispatch --> action --> reducers --> updatedStroe --> render
*** redux的真正价值在哪呢？
	1) 它通过store抽象接管了界面渲染工作，使得我们可以只关注于数据处理而不用过多关心数据改变之后的UI重绘，实现了界面与逻辑的分离。
	2) 在数据处理部分，它通过统一的函数接口（reducer），使得我们可以对这些处理方法进行自由组合，就像管道与流一样。
*** 到底什么是函数式抽象思维呢？函数式抽象思维主张变换，强调一次次的往后变换的顺序，先做什么，再做什么，最后做什么，这一步步都是有明确的顺序的。比如redux就是函数式编程思维的典型，它将前端逻辑抽象成为界面渲染，用户操作，数据更新与界面重绘几个过程，然后对每一个过程都有自己的处理与组合方式。而对象式抽象思维又是什么呢？对象式最重要的概念就是多态。主张将系统拆分成一个个部分，将核心的变换隐藏在某个部分的某个函数里面。
*** es6 class的get、set是一个好东西，它等于是将等号赋值变成了一个函数，这样就给予了赋值非常大的灵活性，我们可以在赋值的时候对数据进行变换或再封装，自定义赋值的行为，使得赋值不再是一个简单的变量绑定。
*** 函数式编程思维的突出优势是我们可以随意增加处理流程，比如在UI数据与模型数据中间加上验证环节等。
*** redux是纯函数可组合性的突出表现之一，这个是毋庸置疑的。实际上，react也是这一特性的突出表现。使用react，我们能够产生可自由组合的组件，而组件，虽然使用的是JSX语法，但实际上，一个组件就是一个函数，组件名就是函数名，props就是函数参数，外层组件使用内层组件作为参数，产生新的组件，这样一层一层的嵌套调用，就产生了复杂的UI界面。
*** 由于React具有纯函数的可组合性，这样就使得我们可以自由的使用别人已经写好的组件，比如MarkDown组件，这是非常惊人的，我们从此可以重用html代码了，再也不用从头开始自己手写了，前端的组件化条件已经基本成熟。
*** react有两个非常重要的概念――――props与state，这两者最主要的区别在于前者是不可变的，而后者是可变的，不止可变，当它发生改变时，会发生界面重绘。这就为我们编写响应式界面提供了非常好的基础。只要我们在数据发生改变的时候调用setState就可以立刻将这一数据的改变更新到界面上去。
*** 面向对象抽象实际上有个非常重要的方面就是你需要写一个类，这个类使用另一个类进行工作，然后只要我们重新实现另一个类，就可以实现我们自己的特殊逻辑，同时不用管许多相同的事情，实现抽象。
*** 抽象的本质就是消弭重复的同样的工作，开发人员只需关注实现业务逻辑，就可以实现功能。
*** 任何事件都有一个投机取巧的实现方法，它叫做：计时器。    ――――huhu45691074
** 2016/08/27
*** 在css的3d变换中，如何计算视觉中心点是问题的关键。
*** 其实三维变换存在三个步骤，按照步骤一步步的来做，三维变换就会非常简单。
	rotate --> move
*** css的3d需要三个层来实现，最外层是相机，也就是视距、景深；中间层是空间，也就是坐标系；最里层是需要显示的物件。相机、坐标系、物件这三层基本上是必不可少的，想要做三维动画，首先就需要建立起这些东西。（camera、space、box）。
*** 使用css做3d动画还是有些原则需要注意的：
	1) css的旋转是基于元素中心点的，并不是坐标系的中心点。
	2) 平移变换实际上不管怎么设置中心点都是一样的，但旋转变换则不一样，旋转中心点（tranform-origin）的设置对于最后变换的效果影响非常大。设置旋转中心点有个非常重要的点就是我们是无法设置到元素外面去的，不能向你自己心里想的一样设置到坐标原点进行旋转。
	3) 旋转的时候要始终记得，要先把div挪动到正面，然后横轴是X轴，竖轴是Y轴，里外是Z轴。
	4) 要将元素的position设置成absolute，这样才能让所有元素都相对于同一个中心点进行变换。设置了元素的absolute属性之后，如何进行变换呢，首先可以用left/top这些东西进行整体变换，然后可以用transition中的translationtransform进行平移变换。
*** perspective-origin视觉中心点，也就是相机中心点，tranform-origin旋转中心点。
*** 视觉点与消失点表现为一种相对于屏幕对称的关系，一般从视觉点出发去理解三维物体的形状比较困难时，换个思路从消失点去考虑也许会有奇效。
*** css的变换是有顺序的，比如先移动后旋转与先旋转后移动的效果就是不一样的，因为当进行旋转的时候元素的坐标轴也会跟着变换。而不管怎么平移，元素的坐标轴是不会变换的。
*** css动画中，元素变换的原点与变换方式，掌握了这两点基本上就掌握了css动画的大多数东西了。
*** css动画中，给元素设置position:absolute可以强制所有元素使用同一个中心点。
*** 其实css动画也分为设置在容器上的属性以及设置在元素上的属性，设置在容器上的属性有
*** 嵌套具有强大的生产力。什么是组件化，实际上就是允许给一个组件命名以及嵌套，react的组件化就是如此，它只不过是实现了给html标签命名以及嵌套而已，就能实现模块化了。而对于css的animation，尽管我们已经可以使用keyframes来给动画命名了，也可以使用多个逗号来将多个动画连接在一起，但动画的嵌套依然做不到。
*** 两层css结构，外层写类别，里面写一些公共的属性；内层写id，里面写一些特异性的属性。
*** TODO 按照功能做需求会比按照顺序做需求可重用性好，写出来的代码质量也高。
** 2016/08/28
*** 在调试css的时候，很多时候将边框给显示出来是个非常好的做法，这样非常有利于我们查找样式发生问题的原因，等到最后调试好了然后再将边框给隐藏起来就好了。
*** 写css的时候有个原则就是尽量不要将内容写到html元素里，比较好的办法是先使用div占位，然后再在css里面填充内容。
*** 在编程的过程中，我们每次理解事物能够接受的最大复杂度有限，所以在理解的时候要尽可能的去除依赖，这样才能尽最大程度上将模型简化，达到化简的目的。
*** html元素的占位作用不可忽视，很多时候，我们能够使用一个空的html元素在网页中占位，然后通过特定的css类，然后在css中控制显示的内容，这样就实现了用css样式来改变显示内容。
*** 其实原始的css确实值只能控制显示样式，并不能控制显示内容，但自从before/after伪类出现以后，就不是这样了。这一特性允许我们控制显示的内容，而不止是显示的样式，只不过它依然有个限制就是――――只能有两个，如果有多个，那么只能将这多个放在一起，一起放在一个图片里面来实现了。
*** 前端代码的写法确实非常非常的灵活，不同的写法写出来的代码可能代码量隔着一个数量级。
*** 使用递归进行续处理，不断的将同一处理传播下去，比如Promise实现，requestAnimationFrame函数写法。
*** requestAnimationFrame请求一个动画帧，通过不断的请求动画帧，不断的往后走，就实现了一帧一帧的动画。这种一帧一帧写动画的方式虽然强大但写起来复杂。
*** html5给每一个dom元素都添加了一个classList对象，通过这个对象我们能够给元素添加和删除类，非常有用，有了它，我们再也不用自己去手动拼接字符串了。
*** 制作css动画最难的地方在哪里呢？在于我们需要一个时间轴，而时间轴是css不具备的，我们需要使用js来自己实现也给时间轴，然后根据时间将不同的元素添加进场景，实现动画。
*** css制作动画的合理方式应该是先分开写html元素与动画，然后使用js将元素与动画连接起来。
*** 通过嵌套标签的形式也可以实现连续动画，因为只有外层元素的动画播放完毕以后内层元素的动画才会开始播放。
*** 制作动画的过程中，嵌套标签是一个非常重要的技巧，通过嵌套标签的形式，我们可以实现动画的并行与串行。
*** css的3d变换实际上有个原则就是眼睛始终在是在屏幕上，不管设置正的投影还是负的投影，所看到的物体总是在它后面。所以为了让它所看到的物体正好占满整个屏幕，物体的尺寸应该设置的大点，至少大于屏幕才行。
** 2016/08/29
*** 立方体旋转
*** 其实d3这个库并没有做什么多余的事情，它的大多数函数都可以我们自己用js轻松实现。
*** 续处理具有相当强的抽象能力，当我们需要在某个操作流程中间加上一步处理的时候，使用续处理很多时候具有非常好的效果。
** 2016/08/30
*** 在centos7中，打开关闭防火墙的方法已经改了，分别是systemctl start/stop firewalld。以前系统的老用法service start/stop iptables已经失效了。所以，当你打开了web服务器却发现依然无法远程访问的时候可以考虑使用新方法关闭防火墙，很有可能就可以访问了。事实上，在centos7中，为了简化操作，service与chkconfig已经被systemctl所替代。
*** 抽象就是把经常变化的代码抽出来，将不变的代码
*** 如果一段代码被反复的调用，那么久表示这段代码需要提前或是押后，需要在共同的地方统一处理，这样就能消除这段重复代码了，比如常见的场景判断、数据保存判断、数据保存、数据渲染等。
*** 一段代码应该在什么时候被调用，这非常重要，需要仔细理清楚流程。
*** 不只要有类别（横向划分），还要有过程（纵向划分）。代码编写的初期往往会有类别，但不会有过程，随着代码的演进，过程就会渐渐出现。
*** 也许全局变量最大的缺陷就在于很难调试，我们无法追踪它是在何处被赋的值。需要指出的是，事件实际上也可以看做是全局变量，它也具有非常难以调试的缺点。
*** 不要使用全局变量，让数据在函数中慢慢流动，这才是程序好调试的秘诀。
** 2016/08/31
*** 写程序的时候要保证程序随时是可以拆分的，可解耦的，以这样的原则写出来的程序就会非常容易拆解，而不需要重复劳动。
*** "margin:auto"具有非常有用的用法――――用来做水平方向的居中，包括左对齐，右对齐，水平居中对齐。这一用法非常有用，像强大的flex布局之所以没有提供justify-self就是因为已经有了margin:auto用来做这件事情了，因此再提供就变得不是那么重要了。
