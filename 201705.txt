* 2017/05
** 2017/05/04
*** 我一般习惯于抽函数，将所有的重复代码都抽出来，这本没有错，但不能乱抽。如果抽的不合理，那么抽出的函数与函数之间就会出现过度耦合的情况，你修改了一个函数，另一个地方也使用到了这个函数，也意外的被修改了。应该抽跟业务逻辑没有关系的函数并形成一个函数库，实际上也就是函数式编程里的那些函数。
*** 关于async与await,它的原理实际上是当碰到await函数调用的时候，将这个调用以及前面的调用代码暂存到promise等待队列里面，然后当队列前面的函数返回的时候，将resolve的值给到函数的返回值继续往下执行，它将一个函数分成了好几段，然后一段一段执行，直到结束。它实际上只是promise的语法糖而已，但是它能极大简化promise，使得我们能够更轻易的写出更加复杂的逻辑。
*** async与await的最大意义是使得异步代码能够更好的与同步代码配合着去写代码，我们再也不需要一碰到异步就将这段异步代码单独放到一个函数中去处理，或者为了这个异步写一大堆无意义的重复代码，比如then()，比如catch()等。
*** TIPS 豆瓣开发API是测试异步接口的一套非常好的API接口，而且具有一定的实用性，可以用来写写爬虫之类的。
** 2017/05/06
*** IMPORTANT pandoc————使用haskell写的文档格式转换神器，能够让我们轻松的在docx、markdown、org-mode、pdf、odt、slide,甚至xml、json这些格式中互相转换，实在是写文档及演示的必备神奇啊。
*** TIPS pandoc将文档转换为pdf时，有两点需要注意，一是需要制定latex引擎，否则会报错，二是要不指定字体，否则中文是不会出现。所以，最后的转换命令需要多加点"料",形如：
	pandoc test.org -o test.pdf --latex-engine=xelatex -V mainfont="SimSun"
*** TIPS Latex到底是什么呢？它实际上是一门排版语言，也可以说是一门标记语言，与markdown差不多，不过比markdown更加的复杂强大，它主要用于生成具有印刷质量的文档。
*** IMPORTANT 工作只是生活的一部分，而且是很小的一部分，虽然它从时间上算真的占用了非常多的时间，但其实真的是这样。要想活得精彩，功夫在工作之外。
*** markdown语法总结：
	1. markdown最重要的语法元素类型实际上非常少，列表、链接、引用，基本上掌握了这几个就没什么了。
	2. 它实际上类似于去掉标签只有类的html，比如*、#、·、[]等这些实际上就是html里的class，表明文章的元素类型。通过这种简化，将具体类型的样式给定死，不开放给文档编写人员，这样我们就可以更加只专注于写文档。
	3. 推而广之，实际上不管是什么标记语言，html,markdown,emacs org mode,json,xml,它们的本质都只不过是将type与content写在一起，然后针对不同的type做不同的处理。这样有个问题就是转义，有些时候我们的内容里面有可能与样式标签出现碰撞的情况，这时就会出现转义符号。
*** 关于markdown与org-mode的比较，它们都是专注于纯文档写作的标记语言。但两者在抽象上有些区别，两者各有千秋吧。
	+ markdown的优点是引用格式设计的不错，比较简单。反引号、尖括号、中括号，带叹号的中括号、大于号这些比org-mode乱七八糟的"#begin_xxx ... #+end_xxx"要好记与好用，对文档内容的侵入也比较小。
	+ org-mode的优点是快捷键完善，不管插入什么类型的元素，都只需要一个快捷键就可以了。
*** TIPS markdown的入门教程看多了之后容易让人忘记markdown终究只是个转换器。使用它写出来的文本最终会被转换为html的标签，看这种转换关系实际上是更容易理解markdown的，官方文档就是这么写的，实际上也是最好的markdown教程。
*** TIPS 使用马克飞象写markdown文档，写完后查看打印预览，选择另存为pdf，这也许是最简单，效果最好的产生pdf文档的方式了。
*** 使用html写界面写的多了，很容易让人忘了html还有个很重要的能力————写文档，而这实际上是一个不能被忽略的缺失，虽然不会我们现在基本不会真正用到这些标签，但是理解这些标签对我们写出高质量的html是非常有好处的。
*** IMPORTANT 语义化标签的最大作用到底是什么呢？实际上就是写好html，即使离开了css，文档的结构依然要要清晰明了，它的作用可不仅仅是为了让机器识别，更是为了让人对文档有个清晰的认识。
*** IMPORTANT 我需要注意锻炼几项自己的核心竞争力，今年上半年，我着重锻炼了自己的读英文文档的能力，应该说基本上已经成功了。在下半年的时间里，我需要锻炼自己写文档的能力，包括文档中的图表，markdown、emacs-org-mode、graphviz都要补上来。
*** 使用pandoc进行文档格式转换尽管支持的格式最多，功能最为强大，但是它有个比较头疼的模板问题，需要良好的模板配合才能有比较好的效果，而这pandoc是不是那么完善的。这在html、pdf这种需要有模板才能有比较好的显示效果的时候表现得尤为明显。所以，一般用它来进行比较基础的转换比如org格式转markdown格式这种就可以了。
** 2017/05/07
*** TIPS 面向对象的编程手法需要你把握全局观，更是面向未来编程，适合于写外层用来分类的架子代码，没有经验比较难掌握好这种大局观；函数式编程手法擅长于写流程，适合于用来控制架子里面的流程，这两种编程手法是正交的。
*** IMPORTANT 写css绝对是一个技术活，绝对不是各自写自己的，拷来拷去再改改就可以了的，你需要从全局上考虑，尽量的将可以重用的，不会变得基础样式抽出来复用，而不是整体复用。
*** TIPS box-sizing是一个非常重要的属性，它会影响到宽高是内容的宽高还是边框的宽高，这非常重要。
*** naming命名的巨大作用————
	有了命名，我们才可以使用名字而不是具体的实现，从而只需要修改实现，所有用到这个名字的地方都会一起修改，实现面向接口编程，修改实现时只要接口不变，系统的其他地方完全不会受到影响。命名确实是一个极其伟大的发明，函数名实际上也只是一个naming而已。
*** 只有读懂了孤独，你才能读懂你的用户。
	————秦汉青
** 2017/05/08
*** 执行上下文（也叫作用域）是在函数调用的时候被创建的，this是组成执行上下文的一部分。如果直接调用一个函数，由于没有对象可以绑定到this，所以this是windows.
*** js是单线程的，但是它需要在每次主线程循环结束后检查下所有的异步回调，看是否有相应的回调需要调用，大致的代码如下：
	function mainLoopFunc(){
	    ...

		asyncFuncs.forEach(func => func.triggered ? func() : null);
	}
*** 原型链、作用域链。原型链用于对象的属性查找，作用域链用于函数求值时的变量查找，这两者非常相似但不是同一个东西。
*** IMPORTANT 什么是交互？交互实际上就是事件监听与处理，这也是组件最核心的东西，组件的本质就是抽象出与业务逻辑无关的交互以供业务逻辑使用。
*** 如何实现图层？图层实际上是一个数据的管理机制，通过图层，我们可以将不同类型的数据放在不同的图层中分别处理，大大简化了管理数据的难度。它实际上只是个数据分类机制而已。
*** TODO 变量实乃最重要的抽象手段，没有之一。一切抽象技术的本质实际上都只是将不变的东西拿出来设个变量，同时将变化的东西弄成参数（实际上也是变量），这样我们就可以实现重用了，而且只要接口不变，我们可以修改实现却不影响系统的功能。
** 2017/05/09
*** js的无类型有些时候并不方便，有些时候一个对象被传递过来后，你并不知道这个对象有哪些属性与方法以及这些属性与方法是如何使用的，这个时候通过Objecct.keys(obj)以及Object.keys(obj.__proto__)可以大致的看下，至于更详细的信息就要查API文档了，这个时候你就会发现对于js来说，文档是非常重要的。
*** IMPORTANT 不要小看下面这个函数，它是一个非常通用而且非常简单的遍历树的函数，不管是二叉还是更多的叉，使用它我们能够对树结构上的所有节点一个个的进行处理，比如统计dom树的节点，统计文件夹中的文件等，非常有用。
	function triverse(tree,cb){
	    cb(tree);
		for(let i = 0;i < $elem.children.length;++i){
		    triverse($elem.children[i],cb);
		}
	}
	
** 2017/05/10
*** IMPORTANT 不同的代码写法、语法糖等并不仅仅只是敲字符的多少而已，它还将深刻的影响我们的思维。比如async与await，它实际上是做到了返璞归真，以一种不阻塞主线程的方式实现了异步等待，我们再也不用将异步代码后面的代码专门抽到一个新的函数里面去实现异步续处理了，同步与异步的写法终于得到了统一。
*** promise的缺点：
	1. 非Lazy的，一旦新建，立即执行，无法中途取消。
	2. 在错误处理上有缺陷。promise内部抛出的错误，不会被外部的catch捕捉到。
	3. 复杂的异步场景下有缺陷，只能等待单值，如果是多值的话还是需要嵌套。
*** promise虽然比较好的抽象了异步的定义端，但是对异步的调用端的抽象却不怎么好。这会导致我们碰到比较复杂的promise调用时力不从心，比如等待多值的情况。真是为了解决这一问题，才有了generator与async/await。
** 2017/05/11
*** 递归并不总是低效率的代名词，有些问题用递归解决比循环要简单得多。大部分都是一些需要探测或者处理几个分支的情况（每个分支又有可能生成更多分支）的问题。
	————《Javascript编程精解》
*** TIPS 循环只是一种特殊情况下的递归，发明它是为了效率而不是必须。它只是递归的一种特殊情况，模式定死，无法改变，简单重复。在循环过程中，我们对过程的控制能力非常有限。想要获得更强的过程控制能力，就必须写递归。所有循环都可以轻松改写为递归，但递归改成循环却不是那么好办。
*** 使用异步callback加递归可以轻松实现异步循环等待，这样直接用原生的ES5就可以实现异步续处理的效果了，非常牛逼。比如：
	function wait(count){ //循环从1输出到10，每个一秒输出一个数
	    let timeId = setTimeout(function(){
		    clearTimeout(timeId);
			if(count < 10){
			    count++;
				console.log(count);
				return wait(count);
			}
			else{
			    return;
			}
		},1000);
	}
*** 去掉了循环，我们再来思考下条件判断这个东西，条件为什么不能是函数呢，当然是可以的，像lisp这样的语言，条件判断实际上就是一个函数。有了这点认知，我们可以得出如下结论：
	一切皆函数，不管是循环还是条件，通通都可以用函数来表示，编程得到了和谐的统一，没有什么语句，什么都是函数，仅仅使用函数就可以完成所有的事情。
*** 实际上可以这么理解，前++与后++的差别在于优先级，前++是高优先级，先加1了在进行其他计算，而后++是低优先级，先进行其他运算了再进行加1。比如fn(a++)与fn(++a)虽然最后a都是加了1，但在fn里面a的值是不一样的。
*** 交互的本质就是事件监听处理，这句话本身非常简单，但其实有着很多隐含的信息。比如：
	1. 事件监听是哪些？鼠标当然是时间监听，但是键盘就不是了吗？当然也是的，而键盘上的事件监听多数时候就是快捷键，所以，快捷键是交互上不可或缺的一环。特别是对于编辑器这种UI元素非常少的元素而已，快捷键是交互中极其重要的一部分，如何区分用户在不同的场景下点击某个按钮是表示的什么意思，是成败与否的关键。
*** 模块化的本质就是封装某个功能，而一个功能的核心实际上就是一组交互，有可能是鼠标交互，还有可能是键盘交互，每个交互得目的实际上都是修改数据。
*** 如何管理交互呢？交互的管理包括交互的创建/销毁、加载/卸载、启用/禁用、查询、查看这些都是需要考虑的问题。可以这么说，交互的管理绝对是一个非常复杂的问题，而且暂时好像没有什么库是瞄准这这一块问题在解决，是有非常大的改善空间的。
** 2017/05/15
*** 实际上if与for语句只是函数的一个简写形式而已，我们完全可以不使用它们而直接使用普通函数来实现if和for。if和for只是函数的一种特例而已，简单的情况下使用它们就好了，复杂的情况下还得靠函数。
*** 函数极其强大，只使用函数就可以完成编程中的所有工作了，完全不需要使用到选择与循环（它们都可以用函数实现出来），所以才有了很多基于lambda演算的纯函数式语言。
