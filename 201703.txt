* 2017/03
** 2017/03/04
*** 关于类参数与函数参数的选择问题，类参数是用来给类使用的，这个类里面的很多方法都会使用到这个参数，而函数参数是专门用来给某个方法使用的，其他的函数应该不需要这个参数。更近一步说，类参数应该是类的状态信息，而函数参数是函数函数的功能信息。
*** TIPS 关于写测试代码，如果不写UI相关的代码，那么直接使用node运行是比使用chrome运行更加优秀的方法，因为node轻量，你可以马上看到运行的结果。
** 2017/03/06
*** TIPS onchange、onclick这种通过表达式调用js函数的事件绑定方式如何传递参数呢？通过this就可以了，这样就可以把目标控件给传递过去了，然后我们就可以在js中拿到控件值了。
*** TODO 关于缓存数据导致的调用断层问题。
** 2017/03/07
*** TODO display:inline-block没有内容也占用高度？
*** background-image是非常好的装饰div的方法，如果是在div内部装饰，直接使用background-image，然后relative定位下就好了，但是如果是想在div外面装饰的话，依然可以使用它，不过是在before/after伪元素上添加backoground-image就行了，非常好用。
*** 左右分栏布局的n中方法：
	1. float:right。
	2. flex。
	3. position:absolute。
	4. background-image。
** 2017/03/08
*** TIPS 如何实现样式联动，很简单，在父级元素上增加样式，同时去掉子级元素的对应样式就可以了，这种方式适合于想样式作用于父级元素的所有子元素的情况。如果只想作用于一部分元素，也是有办法的，比如对于hover，将hover加在父级，然后找对对应的想修改样式的子元素修改样式就可以了。如下：
    <style>
        .outer.hehe:hover > .inner1,
        .outer.hehe:hover > .inner3{
            background:red;
        }

        .outer.hehe *{
            background:blue;
        }

    </style>

    <div class="outer hehe">
        <div class="inner1">INNER1</div>
        <div class="inner2">INNER2</div>
        <div class="inner3">INNER3</div>
    </div>
** 2017/03/09
*** TIPS 关于界面驱动与数据驱动，在很早的以前，前端开发是界面驱动的，要做一个什么功能，首先需要设计出这个功能的界面，然后通过界面处理数据传递给后端；这种方式在问题规模比较小，数据比价少时能够很容易的完成任务，后来，前端越来越复杂，要处理的东西越来越多，使用界面驱动无法适应数据的频繁变化，而且数据间的通信也是个大问题，数据驱动就渐渐出现了。使用数据驱动，把数据放在核心位置能够使得数据比较规整，想要对数据进行什么操作都比较轻松。
*** TODO 如何做到自动化的分析依赖呢？实际上依赖本质上就是一个排序问题，这就是模块加载器所干的事情。那么如何排序呢？使用栈，先将目标文件放在栈底，从上往下找，一旦找到依赖，就先分析这个文件的依赖，然后将这个文件最终的依赖数组放在目标文件的前面，如此下去，最后就得到了这个文件的所有依赖数组了。
*** TIPS 传统的module.exports与require的模块加载方式有什么缺点呢？为什么要引入import/export这种新的模块记载方式呢？因为require与module/exports的加载方式不够灵活，它不能让开发者自由的选择导出哪个函数，引入哪个函数。
*** webpack实际上并不是一个前端专用的工具，后端也可以使用它来进行打包。使用它打包出来的文件是可以直接跑在node上的，并不一定需要使用浏览器来运行。
*** 不要讲样式写在js中，也不要将样式写在html中，因为这样写的样式优先级很高，很难复写与调整，而且代码写出来也非常难读难维护。
** 2017/03/10
*** TODO z-index的层级问题
** 2017/03/12
*** TIPS 函数的返回值能够提升调用层级，使得我们能够在父级获取子级的值进行续处理。
*** 直接返回对象与返回封装对象的函数区别就在于使用函数封装能够传递与使用额外的参数，对对象进行一些额外的处理。
*** Promise的then实际上与pipe有着异曲同工之妙，他们都是使用同一个API进行链式调用，它们的实现也是非常类似的，都是通过柯里化函数加闭包，使用闭包传递执行结果，使用柯里化函数延迟计算执行，从而成功的将流式的计算过程给显示的表达了出来。
** 2017/03/13
*** 实际上，css调多了之后，脑子里想的就不再是怎样看起来像效果图了，而是怎样让页面有一个好的结构，由哪几个部分组成，左边、中间、右边。应该采用什么布局，相对于谁，这些都是非常重要的问题，只有脑子里有个很好的结构，调节起来才能得心应手。
*** 关于行内元素、块级元素、行内块级元素、flex布局可以这样理解：
	1. 行内元素是用来放内容，给内容加样式的，它是不可以设置宽度、高度、margin/padding/border的设置能力也很有限，一般也不能transform，只能设置水平方向上的距离，它只适合于用来放置内容，无法专门用来占据一块空间；
	2. 块级元素是一个盒子，它可以有自己的宽度、高度、margin/padding/border，它可以用来占据一块空间，然后在这块空间上放置其他任意元素，实现布局；
	3. 块级元素虽好，但是它有个缺陷，就是不管它的宽度为多少，它都是从上到下排列，即使上面还有充足的空间，为了解决这个问题，就出现了行内块级元素，这样我们就可以水平排列块级元素了。但是它依然有个问题，就是元素与元素间会有一个空格，还不大好解决，非常恶心，而且左中右三栏，某一格自适应也非常困难。为了解决这个问题，就出现了flex布局。
	4. flex布局是非常完美的布局，它主要用来解决单行元素内水平排列的问题（我的理解），最好不要使用flex来处理几列元素布局的情况，而应该用几个行内元素，分几行来处理，它添补了水平布局元素不好排的问题，大大丰富了网页的表现力。
*** TIPS 关于css盒子边框叠加的问题，负margin是最佳的解决方法，它能将所有的盒子往上移动几个像素，这样盒子与盒子之间的边框就正好能够爹在了一起，更加完美的是它下面的元素也会跟着往上移动，它所腾出的空间下面的元素能够无缝的往上靠，唯一的不足是上面的元素不会跟着移动，有可能因为平移压盖到上面的元素，需要在父级列表中通过设置margin或padding将元素整体再向下移动几个像素。除了边框叠加问题外，还有个问题就是inline-block元素间空格间距的问题，这一问题也能通过负margin的方法来解决，此外，float也可以解决间隙问题。
** 2017/03/14
*** Monad:
	1. 软件最基本的数据，就是各种值。
	2. 处理值得一系列操作，可以封装成函数。
	3. 函数想漏斗，上面进入一个值，下面出来一个值。
	4. 数据类型就是对值得一种封装，不仅包括值本身，还包括相关的属性和方法。
	5. 函数也可以封装成一种数据类型。
	6. 我们需要这样一种函数，它的输入输出都是数据类型。
	7. 因为数据类型是带有运算方法的，如果每一步的返回都是数据类型的实例，我们就可以把它们连起来。
	8. 所有这些运算连起来，就叫做Monad。
	9. 简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成多个互相连接的步骤。你只需要提供下一步运算所需的函数，整个运算就会自动进行下去。
	   ————阮一峰 《图解Monad》
*** TIPS flex布局是一种盒子布局，它先定义一块空间，然后这个空间里面的子元素就能够以崭新的布局规则进行排布，同时不影响子元素下的子元素，它们依然能够用传统的布局方法进行布局。它基于两个轴，相当于建立了一个坐标系，里面的元素能够相对于这个坐标系进行自适应布局，非常灵活。
*** TODO flatMap
*** padding-left + background-image是在文字旁边加图标的不二法门，根本不需要添加额外的元素。
*** before/after伪元素既可以作用于行内元素，又可以作用于块级元素，但有一种元素它是无效的，就是input这种根本没有闭合标签的元素，这种情况下before/after就无能为力了，只能添加在这种元素的外层其他元素上。
*** TIPS vertical-align————专门用来进行行内元素间对齐的样式，常用来进行单选/复选框按钮与文字的对齐，非常好用。
** 2017/03/15
*** promise的resolve回调实际上就是then的回调函数，所以当then返回一个promise并被resolve继续返回时，then方法就直接返回了一个promise，这样我们就能使用then使得回调继续下去了。
*** 函数有一种包装模式非常重要，比如
	一个函数长这样
	fn(argA,argB){
	    ...
	}
	我们使用另一个函数
	fnWrapper(argA,argB){
	    doSomethingBefore();
	    let retValue = fn(argA,argB);
		doSomethingAfter();
		return retValue;
	}
	这个函数就是原函数的封装函数，它能够行使原有函数的功能，同时还能够做一些其他事，同时又不用修改原有函数，是一种拓展函数功能非常好的做法。
	有一点需要注意的是参数，封装函数需要与原函数具有相同的函数参数，这样才能完美替代原函数。
*** angular中蕴含着这样的思想：$scope与模板是弱耦合的，我们并不需要为了展示数据而去构造额外的数据，模板中通过angular表达式与指令蕴含着自己的逻辑，它使用$scope的数据进行展示，同时不构造自己额外的数据，从而使得UI的数据变成了关联数据而不是源数据，这样就使得我们只需要改动数据，界面就能联动了。
*** Promise是在new的时候立即求值的，而不是在then的时候才开始求值，求值是异步的，这样就出现一个时间差，允许同步代码通过then方法传入回调函数，用来接收求值的结果，这就是Promise的原理。
*** IMPORTANT 强大的函数都应该返回封装数据类型，而不是基本数据类型，这样函数就不再仅仅只能处理值，而是处理类型，在类型间变换，这才是函数式编程。
*** 我们可以把函数也封装成一种数据类型，这样我们能够继续调用这种数据类型的方法，而不再是简简单单的a()()()这种柯里化的调用。
*** TODO 什么是函子？函子是函数式编程中非常重要的概念，用来实现范畴的转换。如何实现一个函子呢？你需要实现一个map方法，它能接受一个范畴里面的元素，通过map提供一个回调，使它将这个元素变成另外一个范畴中的元素。
** 2017/03/16
*** 任何领域，只要给予足够的关注，没有什么是不能做好的。无论是UI驱动、还是数据驱动、还是文档驱动、自顶向下设计、自定向上设计，都只是给予一个方面以足够的关注而已。
*** IMPORTANT 通过一个类给一个div添加一个图标，不增加额外的dom元素，要做到这一点比较常用的有两种方法：
	1. 通过background-image。这种方式非常简单，只是有一个缺陷，只能局限在元素边框的内部。
	2. 通过before/after伪元素。这是一种非常强大的方式，我们可以通过这种方式给任意一个元素的任意位置添加一个小装饰，跳出元素边界的限制。这种方式也需要利用到background-image，但比使用background-image更加灵活。更优雅的是它可以配合position使用，实现铺满元素，铺元素的哪一部分等等。
*** TIPS 关于css样式的前缀问题，不应该每一级css都写，这样很容易导致前缀过长，书写和调整都非常费劲，而应该先写到块，然后保证这个块里面所有元素类唯一，然后就可以通过"块 (子块，可选，如果块依然很大时使用) 元素{...}"这种写法来写，这样就能保证css选择器始终比较短，而且即使有层级的微调也不容易出现样式失效的情况。
*** TIPS ng-class不能在一个元素上写几个，但是可以通过将几个ng-class的方式合在一起来解决，合在一起有时候我们需要判断多变量，这个时候使用类名作为key，变量值作为value是最合适的选择。
** 2017/03/17
*** hook func
** 2017/03/19
*** 关于列编辑这个事对于emacs实际上是这样的，emacs并不支持列编辑，只支持矩形编辑。首先你需要在左上角做个标记(Ctrl-@),然后你移动光标到终点，注意不能使用上下左右箭头移动，你需要使用光标移动，然后打开列编辑模式(Ctrl+x r t)，emacs会把你做标记的矩形区域的文本删除并允许你在这块区域的每一行输入文本，实现列编辑。
*** TODO 使用子类的数据调用父类的方法，这也许才是继承吧。数据独有，方法共享。
*** 对三方函数封装一下有个显而易见的好处————可以打log了。
** 2017/03/20
*** sublime vs webstrom
	1. webstrom有localhistory,可以很方便的查看文件的修改，sublime没有，修改了哪些只能抓瞎。
	2. webstrom可以非常容易的diff两个文件，在左侧的资源管理器中选中这两个文件，右键选择diff就可以了，它是分屏显示的，远胜于sublime使用加减号显示diff结果的方式。美中不足的是当选择一个文件和另一个文件diff是，找另一个文件比较费劲，需要一级一级的去选，不如sublime直接搜索来的方便。
	3. sublime的文件模糊查询速度飞快，而且可以跨文件夹，跳转起来非常简单。webstrom不能跨文件夹。
	4. webstrom的列编辑比sublime好用，可以直接用鼠标拉框选出需要编辑的位置，sublime不行。
	5. 在代码的智能提示上，webstrom毫无疑问是强于sublime的。
	6. webstrom的代码折叠是强于sublime的，可以非常简单的折叠与展开任意大括号里面的内容。sublime只能折叠for循环以及函数，无法折叠if语句，而且需要将光标移动到行号上才显示折叠。
*** TIPS 清除缓存后如果想保留某些比较关键的的地址有这么个技巧————将它放到收藏夹。
*** layerBase layerSelector leftClick rightClick 管理
	compSwitch clickSelector layerSelector
** 2017/03/21
*** emacs中，可以使用Ctrl-x Ctrl-+ 或 Ctrl-x Ctrl-= 或Ctrl-x Ctrl-0可以打开字体大小编辑模式，然后就可以使用+-0调节字体大小了。
*** 不要直接使用三方库的方法（赋值实际上相当于直接使用语言内置的方法，也属于三方库），最好使用函数对这个方法进行封装，这样能够给我们调整这个函数功能的机会。
** 2017/03/23
*** 以功能为单位去做css样式，而不是一个个调。
*** 集中式的依赖管理好于分布式的，因为所有文件都依赖于同一个文件，而不是互相依赖。
*** 使用init或constructor接收数据，使用其他方法处理数据。
*** DONE 每加一个if条件判断，每加一个循环，系统的复杂度都会上升，要尽量避免。特别是避免在通用的业务里面增加特定业务的判断。如何避免条件与循环？
	对于循环：
	    1. 使用高阶函数map/filter/reduce
	对于条件：
	    1. 使用继承
	    2. 使用查表
*** TODO 什么是函数？IPO
*** IMPORTANT 对过程抽象而不是业务抽象。定义一个高层的规则，下层所有子项都需要去遵守，只有这样写出来的系统才是简单可维护的。实现这种抽象的的手段就是继承。通过继承，下层只需要实现下差异的部分，只需写好差异化的部分系统就可以跑起来了。
*** reduce(callback,initialValue)的initialValue默认使用第一个元素作为初始值，从第二个参数开始累积；如果设置了初始值，则从初始值开始，从第一个参数开始累积，要注意这个微妙的差别。
*** TIPS 对事件进行封装，管理几个事件的集合，一起添加，一起移除，这样比较便于管理。这就是OpenLayers interaction的精髓。
*** TODO behavior ~= interaction
	operation ~= switch
	mode ~= 
	action ~= 
** 2017/03/25
*** 不管是什么系统，都是先有数据，再有环境，然后是UI。对于angular，就是先加载数据，然后流入scope，然后流入tpl。这一过程不能乱。对于react+redux，就是先有数据流到redux，然后流入react。
** 2017/03/26
*** 函数实际上就是一个可以插电的盒子，这个盒子有自己的入口（插电）与出口，盒子里面还可以有其他盒子。盒子可以连着盒子。
*** 如何解决状态管理的问题，我们不应该直接改变数据，而应该将数据缓存起来，当做完之后统一一次合并到数据中，简而言之就是patch与merge。
** 2017/03/27
*** IMPORTANT 封装是一门非常强大的技术，也是一门艺术，使用封装，我们能够在不修改原有功能的情况下扩充功能，实现我们自己的逻辑。
	比如对于状态管理这个问题，直接赋值就失去了统计的机会，我们需要对赋值进行封装，这样我们队数据的修改才是可统计与追溯的。
*** TODO 函数式编程还有一个隐形的好处，防修改。
** 2017/03/28
*** TIPS cherry-pick将一个分支上的提交给取出来放到当前分支，非常适合于想要某个分支的某个提交却不想要整个分支的情形，可以说，它是一个提交的编辑器，可以让我们修改每一次的提交，而不是一个个分支，从而使得git对分支的修改能力提高了一个数量级。它最大的作用是使得我们能够在一个分支上同时工作，并保持一样的提交了。
*** IMPORTANT 实际上高性能的程序架构与CPU的架构是非常相似的，因为CPU本身就是一个高性能的程序，只不过它很多地方是用硬件实现的程序而已。CPU的架构有一个非常明显的机制————多级缓存机制，最常用的数据要放在寄存器，然后是一级缓存、二级缓存、三级缓存依此类推。要写出高性能的程序以必然是这样。
*** TIPS 使用callback来延续计算是非常常见的异步编程手法，其形式如下：
	function proc2(arg,cb){
	    console.log('proc2 be called');
		let result = ... arg ...;
		cb(result);
	}
	proc(xxx,result => ... );
	arg与result可以没有，仅表示顺序。
*** 切到足够小之后使用可变数据修改数据，并将新数据与源数据进行merge，这就是一般的功能开发的流程。
*** TIPS 何为框架？框架就是一套通用的流程，也就是一套通用的API，数据流。
*** 现阶段的webstrom(基于2017.1版本)有如下强大的智能提示功能？
	1. condition convertsion
	2. callback convertsion
	3. color convertsion
	4. 
	
** 2017/03/29
*** MVC架构这个名字虽然读起来很顺口，但却并不便于理解这个架构，更好的方式应该是VCM,分别表示视图控制模型，由视图驱动控制，由控制驱动模型，每级结构间都有自己的缓存，打包提交到下一步。使得数据流非常清晰。
*** 关于功能键的设计应该遵循这样的原则，Ctrl是第一功能键，Shift是第二功能键，Alt是第三功能键，这些功能键应该遵循越大的功能键或组合管越大的范围，比如代码折叠这个东西的快捷键设计，全文件折叠应该用Ctrl+Shift,函数折叠应该用Ctrl+Alt,普通的控制语句折叠直接用Ctrl就好了，这样能够给用户培养一种直觉，记忆起快捷键也会更加的轻松。
*** TODO 将深层的函数抽出来放到外层，在深层调用外层的函数来实现功能，以此来实现减少代码的层级。
*** TODO angular的长处在于模板与视图的双向数据绑定，但在具体的业务处理过程中，我们并没有模板，这个时候它的这个特性就没有什么用了。
*** 一个类的API要保持轻量，最多不能有十个以上的方法，如果有，就表示要拆分了。
*** IMPORTANT 优秀的架构应该有这样的规律，进入跟退出的代码在一起的，一层一层往下细分，，也可以说是对一个资源的读写都应该是在一起的，只有这样才能对一个资源获取最大的控制能力。
*** TIPS 通用的修改数据结构————patch与merge。对于js，patch与merge都可以通过assign来实现，使用assign来复制源数据，然后对这个新数据进行修改，修改完毕后通过assign合并进原对象。
*** Object.freeze可以冻结一个对象，不让它被修改，是用来模拟const的好方法。
*** TODO fuzzyMatch

** 2017/03/30
*** TIPS webstrom的文件跳转并非不能跨目录，只是它需要显示的加上/或\，才可以正常的往下找。
*** IMPORTANT 如果一个对象过大，它会有非常多的方法，使用与管理起来都会非常麻烦，我们可以把这个对象作为参数传递到其他函数，然后在其他函数里面给这个对象添加方法，并在外部调用这些方法，这样就可以达到类似public/private的效果。
*** 所有的任务处理都是这么个流程：
	理解 --> 核实 --> 作业 --> 提交 --> 质检 --> 抽检 --> 提交
	数据问题 产品问题
*** 函数实际上是一个关联数据，它能定义一个数据到另一个数据的转换规则，而不是直接的数据。
