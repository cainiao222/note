* 2014/07
** 2014/07/03
*** 很多文本编辑器带有修改检测功能，打开此文件后一旦此文件被修改会提示要重新加载，可以利用这一点来监测文件变化。最有用的是监测配置文件，修改配置文件内容后可以查看到底是修改了配置文件的哪一部分。
*** vs项目的设置修改后并不会马上被保存到项目文件，只有在编译前这些设置才会被保存。
*** vs不管怎样调整项目设置，实际上就是在调整sln与vcproj这两种xml配置文件，当项目出问题时，其实是可以直接查看这两个文件来排查错误。
*** 一旦看到一个参数是引用参数就要注意了，这个参数很可能是输出参数，类似于其他语言的返回值。实际上，这是c++语言用来返回多值的方式。
*** 关于常引用于引用作为参数的规则如下：作为输入参数最好用常引用，作为输出参数最好用引用。
** 2014/07/04
*** 使用哈希表来存储数据的原理实际上很简单，就是为每一份数据取个名字（key)，然后通过名字来找到数据(value)，实际上可以理解为一种动态的数组下标。但相比与数组下标，他以一种更加灵活的方式来使用下标，摆脱了普通数组的连续性限制（下标的连续性与内存空间的连续性）。使得数据可以放置在不同的内存区域，不同的机器上，从而非常有利于分布式，并行计算。通过这种对数据取名字来存取数据的方式，可以将很大的一份数据用一个标示符来表示，从而大大节省内存。实际上对于语言标示符的存取，一般采用的也是哈希表。哈希表实际上是在数据的表示（value)与数据的使用之间添加了一个抽象（key)，通过这层抽象能够实现非常强大的功能，动态语言之所以能够在运行时使用程序的类型信息，也是因为这些类型信息以哈希表的形式被保存了下来。还有，要实现自动化的垃圾回收，也要通过哈希表，使用标示来表示资源，从而将真正的资源托管给虚拟机，实现垃圾的自动化回收。
** 2014/07/07
*** 使用引用作为函数参数也是有缺陷的，就是不能自动构造对象，比如如果直接用实体std::string类型来作为参数是可以接受const char *类型参数来自动构造的，但如果使用引用的话就无法接受const char *类型来自动构造了，必须提前构造好了直接把对象传递过来，这样就麻烦了点。不过虽然麻烦了点，但当接受std::string对象的时候却而已少生成一个对象，从而有利于效率的提升。
*** vs设置里面的运行时库（Runtime Library）的选择实际上是对应着不同的dll,不同的dll大体相同但还是可能会有一些库多些函数，多些类之类的东西，如果选错，很有可能导致链接失败，报找不到函数定义的错误。
*** 追踪手机这一功能看起来很神秘，其实原理很简单，就是在手机上开启个需要账号的软件，打开手机的gps,然后实时将手机的位置信息上传到服务器，然后当用户异地登陆同一账号时，就可以拉取服务器上手机的位置信息，从而实现追踪。这实际上就是一种通过手机gps监视手机位置的行为，看似好用但会使用户时刻的位置时刻处于软件的监控之中。破解的方法很简单，关闭手机gps或是换掉一个账号登陆就可以避免了，其实这是一个非常华而不实的功能。如果要想让这一功能变得更实用方法也很简单————
1) 将账号与手机硬件绑定，使得用户无法更换账号，这个还比较好实现。
2) 不提供关闭gps的功能，使得用户无法关闭gps，这个要想实现前提是使得gps设备的耗电量降低到一定程度，使得用户可以常开而不会影响到续航，这一点在现有技术条件前提下还做不到。
*** 实际上在信息的流通上存在着这样一个道理：即别人其实无权得到你的信息，除非你主动向别人提供你的信息，但可以通过程序诱导的方式让别人在无意将主动将这个信息给你。简单点来说就是：根本没有所谓的推消息，只有拉消息。所有推消息的实现实际上都是在客户端开启了一个服务来接收消息来拉而实现的。这实际上是由登录的用户名决定的。用户名就是最基本的权限控制。
*** c++语言中#include后面接引号与尖括号的区别：使用尖括号是仅在指定的头文件目录中查找文件，而使用引号是在当当前目录和指定头文件目录中查找文件。引号比尖括号范围大，因为它是现在当前目录中查找文件，找不到再去找指定头文件目录。
*** 所有被加到vs的源代码文件都会被编译，不管这个文件的路径在哪。
*** 头文件跟源代码其实没什么关系，文件名都不用相同的，编译器其实是先检查所有头文件，找到所有的符号，然后再在所有的源文件中一个一个去找这些符号的实现，只在文件内容中找，而不管文件名称。这里面有个问题就是，在头文件中出现的符号，即使其根本没有被使用过，编译器也会去找其实现，找不到依然会报错。头文件可以被包含很多次但源文件只能被包含一次，不然会出现重复定义的错误。头文件被包含很多次也不会影响到最后生成的程序的。所以可以放心的随便include,想用某个函数就include，没事。
*** 其实文件系统的本质就是一个哈希表，文件名就是key,然后通过这个key找到文件内容。
*** 其实程序的本质就是一个个函数的嵌套，一个程序就是由一个个函数所组成的。数据应该依附于函数而不是应该是函数就是修改数据。
** 2014/07/08
*** 头文件可以随便引用，不用担心最终生成的程序中会有多余的函数，不用的函数即使引用了也会被编译器给去掉的，这个是编译器所应该解决的基本问题。
*** vs的Code Generation中的Runtime Library选项很重要，很多稀奇古怪的连接错误，程序崩溃得通过调节这个选项来解决。
*** 其实自己重新建立工程也很简单，将所有的头文件与源文件添加到工程，然后修改include目录，添加需要使用的库。只要使编译器能找到所有的符号与符号的实现，就可以成功地编译出程序。
*** 在函数与函数的调用之间是有着数据损失的，很容易在无意间丢失一些信息。要留意这种信息丢失，为了数据的完整新某些信息不要丢失了。
*** 最优秀的代码是当需求改变时需要改变最少部分的代码。要想写出这样的代码，要做的是尽可能地将不变的代码部分给分离出来，以后不管需求如何改变，也不会改变这些根本代码，而只需要改变几个经常变得部分就可以完成任务的代码。将这一点做到极致就是————完全不需要改变已有代码，而只需要添加新代码来拓展程序就能实现需求，不过这是不可能的。改动的级别有文件级别，这个很难做到。简单点的是函数级别，不要改变函数实现，要靠拓展函数来实现需求。
*** 函数应该尽可能地短小，一个函数只做一件事，只有在经历过很多次代码的锤炼才能深刻理解这句话的含义。要想真正做到这一点，最重要的是要对程序的逻辑，程序的流程有非常清晰的认识，透彻的理解，这样才有可能做到这一点。
*** 在格式装换中要尽量避免多对多的转化关系，因为m*n的多对多关系需要写m*n个函数，而且有很多重复代码。当碰到这种情况时，要写一个中间格式，先转化为中间格式，然后再转化为目标格式，这样就一共只需要写m+n个函数就可以了。
** 2014/07/09
*** 一个函数如果做了很多的事最直接的反应就是函数会很长，然后函数参数会很多，而且会有很多莫名其妙的参数，虽然全局变量可以消除这些参数，但这实际上是自欺欺人，会使代码的可重用性与可维护性大大降低，最好不要用，宁可牺牲效率也要提高代码的可重用性与可维护性。
*** 实际上用全局变量可以提高程序的效率，因为可以减少很多临时对象的生成，这一点在对象很大时效果尤为显著。但多数时候我们并不需要这种效率，因为多数时候我们只需要小对象，而且全局对象会使得程序的可读性，可重用性，可维护性大打折扣，严重影响到程序的维护。
*** 实际上代码的重构是一个不断转移代码位置的问题，先将本文件中重复的代码移动到单独的函数中，再将很长的代码移动到另外的文件中，这样不断的转移下去层次关系就出来了。
*** 多使用引用给变量取别名，反正不会生成新对象，既方便了自己，也不会给程序带来效率上的损失。
*** 一件事做起来比较复杂，暂时没有头绪，别急，先从简单的做起，做着做着逻辑就清晰了。
** 2014/07/11
*** 能够处理复杂情况的代码未必能够很容易地处理简单情况，有可能有这些代码来处理简单情况反而会变得很复杂。 
** 2014/07/15
*** 不要使用直接的数据，使用间接的数据，虽然损失了效率，但做到一切都可以改。lisp语言就是实现这种思想的典型。
*** 函数的本质就是求值，一切函数实际上都只是一个表达式而已。
*** 在smile,repl环境下输入函数名，再将光标移动到函数上，按M-.即可查看函数源代码。
*** windows控制台脚本要想将多个命令当做一个命令来写，连字符是&，并不像lisp中的(progn ...),通过使用这个连字符，很多只能写一条命令的地方可以写多条命令。
** 2014/07/16
*** 函数式编程最明显的特点就是不改变原有对象的值，通过返回新的对象来实现功能。这种实现程序的方法使得函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。从而做到了引用透明，便于调试。而且使得多个函数可以前后相连，便于理解。最重要的是其内部实现与外部无关，从而非常易于并发编程，非常易于升级（可以在运行状态下直接升级代码）。这是一种与语言无关的编程方式，任何语言都可以使用这种编程方式来写程序。
*** 实际上对于机器而言，它并不认识顺序，选择，循环这种结构，它其实只认识顺序与跳转。仅靠顺序与跳转就可以实现所有的功能。选择结构，循环结构，其本质都是通过跳转来实现的。
*** 编程语言的实现其实只有两种思路，一种是做大内核，让内核做更多的事，从而简化程序的编写，但同时也丧失了拓展性与灵活性。一种是做小内核，用最精简的内核来实现，从而使得这种语言更加强大，但同时也会丧失对用户的友好性。
** 2014/07/18
*** 关于到底是把处理业务的代码写在if语句内还是只在if语句内判断输入跳出处理这实际上是有讲究的，如果if语句不在循环体内部，将处理代码写在外面可以增强程序的可读性，避免多机嵌套。可是如果处理代码在循环体内，将处理代码放在外面容易导致if后面所有的处理代码一旦出错就会被全部跳过，如果你只想跳过某一段则做不到，此时正确的做法是将处理代码防止在if语句内，这样后面的语句就不会被跳过了。这其实只是一个作用域的问题。
*** 前缀，中缀，后缀表达式：前缀，后缀表达式是最容易求值的，中缀表达式需要向被转化为前缀或后缀表达式了才好进行求值。他们求值比较简单，只需一个栈来存储数字，从又往左碰到算符就运算压栈就行。
*** 现在我们见到的系统基本上都是由事件驱动的，但其实组织系统的方式不止事件驱动一种，比如时间驱动，声音驱动，流程驱动等，这其实都是可以实现的。如果有必要，完全可以定制符合当前系统需要的驱动系统来组织复杂的系统，这不是什么难事。
*** 对于文件，表格里面的每一行，每一格进行处理，再遍历处理所有，大多数时候我们碰到的就是这种问题。在这种情况下，将遍历的部分封装成回调函数，处理封装成函数参数是非常有效的处理方式。因为对特定格式，遍历往往是不变的，变得是处理逻辑，通过这种抽象，我只需关心处理逻辑，而不再需要一次又一次的重写遍历代码，大大减轻了工作量，提升了工作效率，同时大大提高程序的可拓展性。
** 2014/07/19
*** 蒙特，卡罗方法是一种利用概率论，通过多次模拟，随机实验，统计分析，得出结论的求解问题的方法。这是一种崭新的求解问题的思路，可以解决很多很复杂的问题，比如不会写图形的求面积等，牢记。
** 2014/07/21
*** 异常并不能用if代码完全代替，虽然很多时候确实可以，但异常具有强于if语句的独有优势，就是————它可以在函数调用失败，中途退出的时候依然保证程序不会整体崩溃。而使用if必须保证程序能够正常执行完毕并返回，不管返回成功还是失败，而由于种种原因这一点很多时候无法保证，比如内存分配，文件读写等。if是假设函数总是可以被执行完毕并返回，不管成功还是失败，而异常则放宽了限制，允许函数执行中途退出而不会直接崩溃，这显然是更符合客观世界规律的。当然，if语句比异常使用起来更简单方便这是不争的事实，所以，异常使用应该遵循以下原则————尽可能的使用if，只有在碰到if语句可能导致代码缺陷的时候才使用异常。
*** 可执行文件exe,dll等其实也只是一种普通的文件格式而已，有自己的格式编码，跟dbf，csv等等格式的文件一样,叫做pe格式。只要了解了这种格式，就可以实现任意修改程序了，这其实是黑客，外挂程序员的基础。这是一种为了程序的高速执行而设计并实现的一种格式，掌握这种格式非常有用。
*** 在定义一种文件格式时，应该尽可能地将能够确定字节数的字段定义在前面，如果碰到的确需要变长的字段，可以采取存放地址的方式来将变长转换为定长，这样能够避开复杂的解析过程，只需定义一个相对应的结构体，就能直接通过取成员获取各个字段的内容。如果由于具体情况无法使用这种方式来获取各个字段的内容，还可以通过ssanf，sprintf等函数来读写这种结构，非常方便。其实这两个函数的实现估计也是这样来的。
*** pe文件格式的设计是典型的已空间换时间的设计思路。它将各个区段的长度定死，从而实现了随机寻址，加快了定位的速度，但同时也造成了很大的空间浪费，文件里面有很多没有使用的空闲区域，但为了速度这点代价还是值得的。
*** 编写程序时如果对pe格式有一定的了解，程序的很多设置，全局变量，静态变量，函数等相关的很多问题就可以被很容易的理解，这远比看很多很多的关于这些东西的文字描述要来的有用的多。
*** 其实很多时候对于一个问题我们并不需要去仔细的去看关于这个问题的详细解释，只要知道个大概再自己思考下，然后配合别人的解释看看就可以大致了解这个问题的答案了。沉浸在别人如海一样的解释中而没有自己的思考反而不容易理解问题。
*** 有鸭子样的就是鸭子。不管一个东西其实质是怎么实现的，你要实现它，只要实现它所表现出来的功能，那么它就是这个东西。这个东西非常适合于用来指导实现复杂的系统，比如窗口界面。窗口界面是什么？不就是一个有界面，能够响应消息，分发任务的东西吗。所以要想实现一个窗口系统，只要实现界面以及消息就行了。
*** 大对象的生成与销毁要格外的注意，因为他们哪怕只生成几个，也会占用极大的内存，最好的方法是只生成一个全局的对象，然后不断的重用这个对象。
*** 在软件系统中过早地引入可有可无的模块只能是徒增复杂性，比如很多管理模块，但随着系统的演化，软件结构变得越来越复杂，这时再引入这些东西就能降低复杂性。所以引入的时机很重要，一个长期运行，运行良好的系统一定是这样渐渐的改出来的。就像一个物种一样，软件也会进化。良好的软件前期总是比较简单的，但随着后期开发的进行，他需要不断地调整结构以降低开发的难度，只有这样，才能始终走在可控的难度范围内。代码就是软件的DNA，功能就是软件的外表，只有良好的DNA结构才能保证功能的正常进行。
** 2014/07/22
*** 配置文件是一种需要经常修改的东西，跟代码一样，所以为了修改的方便，最好将配置文件也直接加入到代码的工程里面，这样就可以跟代码同步修改，避免麻烦了。总之，应当将配置文件与代码等同起来看。
*** 对大程序来说，很多时候一个程序是有很多个小程序组成的。为了降低开发的复杂度，这是必要的。但这种方式也有缺陷，就是它会增加部署的难度。为了解决这一问题，比较好的方法是自己编写部署脚本，实现快速部署。
*** 何为数据，数据实际上就是有结构的物质，所以，从这一点上来说，任何物质都可以存储数据，存储数据量的多少在于对其结构的了解。如果能深入了解一个原子的结构，那么，即使是一个原子，其可能能存放的数据量也可能可以放得下一个世界。怎样才算了解结构呢？了解结构的关键是要量化这种结构，就像现在计算机里的高电平表示1，低电平表示0一样。
*** 求知其实是一个从模糊了解到逐渐细化，不断假设，不断验证，在这种曲折中不断前行的过程。如果你只学结果，只是被动地接受，那么一旦你离开学校，你的知识就停滞不前了。但如果你养成了从模糊开始，不断探究，不断学习的意识，那么你就能终身学习了。
*** 内存窗口是一个探究函数实现的一个绝佳工具，通过这个工具，函数的实现根本无处可藏，非常强大。
*** 北京市经纬度范围，纬度399'26''到41'03''（141960~147780）,经度115'25''到1177'30''（415500~423000）。
** 2014/07/28
*** 如何利用好继承这个东西组织代码结构？往往我们看到很大的继承图表一般都会头疼，这是因为我们直接看到了结果而忽略了过程。其实按照过程来一点点理解是很容易的，而继承都是有顺序规律可循的，就是————一开始是单线，从上往下继承下来，渐渐添加函数，把函数分在几个类中，每当有新方法加入就考虑下加入到哪一层比较合适。当线长了之后再加节点成本会越来越高，因为会出现几个节点对象的交叉关系，为了继续简化，此时比较好的方法就是再开一条线，此时就是多线了，而线与线直接肯定是有关系的，此时就会出现分支合并，几次合并，这就是超大系统最后类图的组织形式了。
*** 在构造一个类的属性时，多用虚拟的类型，这样设计出来的类更灵活，可以很方便的组织类属性。
*** 在一开始设计系统时，使用高屋建瓴的形式设计好整体结构，然后叉出几个分支分别设计（分支），如果需要有额外的东西，再开另外的分支来附加到系统中来（合并），这样进行几次之后就可以形成很复杂的系统了。实际上大系统的设计就是一个分支与合并的过程，掌握好这个度就可以设计出非常优秀的系统。设计模式学习之难就在于它直接拿出了最后的设计结果，却忽略了这样结果的形成过程，忽略了分支与合并，没有基础理论的支撑，整个体系结构比较散乱，学习与理解起来自然也就复杂而且难以灵活变通。
*** 类设计的艺术。类是用来对属性和方法进行分类的，类最好功能单一，一个类里面不要有几种类型的方法。
** 2014/07/29
*** 在代码的执行主线上插入必要的处理函数，但是函数实现暂时留空，再在需要的时候将这一段函数实现补上，或是根据不同的情况补上不同的实现，这是一种非常良好的编码方式。使用c++实现这一种编程方式的方法有两种，一种是使用函数对象参数，传入不同的参数就可以产生不同的实现，但这种方法很可能会修改接口，很多时候这是不允许的。还有一种方法是使用工具类，把工具类对象放在函数里面来实现。这一种不会修改接口，显然更优秀些。
*** 函数对象的引入极大地增强了c++的功能，因为这个东西将函数也作为了对象，可以任意修改替换函数的实现，从而使得类的属性与方法都成为了可以修改的对象，真正实现了一切皆对象，一切皆可改，把原有c++语言中极大的一个空白给补上了。
*** 几个类中如果有共同的方法却不同的实现，可以考虑让这几个类共同继承自同一个父类，然后各自实现自己的方法，再利用多态就可以实现不同的类对同一个方法有不同的实现了。