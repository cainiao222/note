* 2015/12
** 2015/12/01
*** 每当一个东西的子项非常多的时候，就要考虑增加一个维度了。比如一个窗口的选项过多就要分页，相当于靠增加一个维度提高一倍的展示能力。实际上，树形结构就是典型的多维度的，维度嵌维度，正是靠着这种多维的控制力才能把复杂之极的代码管理得井井有条。
*** 可复用、模块化是多么的重要！！！
*** js的表达能力非常强大，你可以随意进行功能的组合，将函数与函数只有组合，非常有利于程序的模块化。
*** 关于函数式编程，有个很好玩的东西，过程式是从上往下执行，函数式是从左往右执行。
** 2015/12/07
*** 先实现一个稳定优秀的最小系统，然后向这个系统添加功能，每个功能都留一个开关，这样系统整体出了问题才好查。
*** 没有共享，就没有竞态，不用考虑加锁的问题。这就是函数式编程的精髓。实际上，即使是在非函数式编程的情况下，有意识的避免共享变量的使用也是非常有意义的，最大的好处就是可以避免多线程共享变量引发的冲突问题。这是一种消灭问题的做法，而不是使用锁这种解决问题的方法。
** 2015/12/09
*** 数据id就是最简单的延迟加载技术实现，分词加载数据，每次只加载最常用的数据，从而将数据量始终保持在可以控制的水平，减少卡顿。
*** get与post的区别很重要的一点是get是有缓存的，因为容量比较小，而post是没有缓存的。
*** 浏览器本身对javascript缓存就已经支持的很好。
*** 如何实现Partial Evaluation，实际上就是一个个参数的算函数，将已经给出的参数先给计算出来放到作用域当前函数作用域里面，返回剩余函数以及其作用域的闭包。实际上就是算函数返回函数。
** 2015/12/10
*** js本身就是树结构，可以任意对这个树进行各方面的调整而且随时可以看到最终的调整结果，其实已经比较接近于REPL了。
*** d3是一个自动生成html的函数库，它弥补了手写html费时费力的缺点，使用代码来自动生成html代码，而且实现了数据的存储于表现分离，大大提高了生产力。
*** 确实存在这种情况，武功越高，越难学会。因为武功越高，执念越深。
*** 配置文件实际上就是一个简化版的程序语言，程序发展的牛逼之后会产生配置文件，配置文件难度变高之后会发展成为程序语言，这就是一个环。
*** js自带map的特性使得它可以非常简单的实现查找。
** 2015/12/11
*** 当我点击程序中的某个按钮时要进行事件派发，事件派发需要做以下几件事情：
	1、从执行环境中找到所需要响应事件的对象，以及对这个对象的操作数据（I）。
	3、执行这个操作（P）。
	4、将产生的新对象重新放到环境中，完成状态刷新（放到内存、放到显示器、放到磁盘,O）。
	从上面可以看出，事实上，事件派发是最简单的IPO模型，有点技术含量的也许就是对象遍历以及状态刷新了。
*** 配置文件是一个很有趣的东西。程序写着写着会变成配置文件，为了分离变化。配置文件写着写着会变成程序，为了灵活。配置文件与程序最大的区别也许就是没有变量了。
*** 过程式语言没有充分利用变量这个好东西，没有将函数也当做变量，这使得它的表达能力大打折扣，实际上这也不能怪它。因为函数确实是一个非常特殊的变量，跟其他的变量相比，函数最大的特点在于它是数据，但却可以实现行为。
*** 变量确实是一个好东西，一切皆是变量，一切皆可变，这种思想可以为编程提供无与伦比的灵活性。
*** 编程就像是一个不断打磨珍珠的过程，由最开始的混沌状态不断的清理出杂质，不断的将不变的东西固化成模型，将变化的东西提取成配置，变得越来越短小精悍，最终靠配置就可以完成所有的业务逻辑，此时开发人员就可以离开了。
*** 在图形移动领域，移动坐标系往往比移动图形简单，计算量小，所以很多情况下图形移动实际上就是通过移动坐标系来实现的，使用这一方法有个要适应的地方就是坐标会反向。
*** css实际上就是html的一个拓展，它使用了一种几乎不需要修改html的方式来对html进行拓展，只需要浏览器支持css，只需要对原网页进行非常小的修改就可以改变网页的显示效果，你甚至可以完全不改变网页的内容只换个css文件来修改网页的效果。
** 2015/12/14
*** 最牛逼的人创造规则，使用规则来赚钱，这方面典型的例子就是游戏。
*** 优秀的代码总是可以在一个屏幕中放下，读者不需要去翻页就可以看出整个函数的意思。但现实情况是我们一般看到的代码达不到这个标准，但这个思想能够给我们一些启发――――看代码的时候要有层次的去看，不要一行一行的看代码，而要一级一级的去看。
*** js一个大函数里面返回一个小函数是什么意思？
*** 使用context表示上下文，将上层的参数传递到下层去。
** 2015/12/15
*** d3的选择实际上使用的是css，它提供了一个代码级别的封装，使得我们可以直接使用代码来操作dom树，而不是像直接写css一样像写配置文件一样操作dom树。相比于css，它最大的特点也许就是提供了函数，使得我们可以动态的操作dom元素吧。
*** d3的所有操作基本都是基于一组元素而不是一个元素的，这种想法非常有意思。
*** d3的data函数是一个很有意思的操作，这个操作实际上产生了两个数据集，一个select元素集，一个arguments参数集，然后我们可以使用其他函数用参数集来修改元素集。相当于这个函数产生了输入数据以及参数，然后只需要填函数就可以实现元素修改了。
*** js的data函数将在调用实体与参数之间打开一条调用通道，建立一个对应关系，将对应的输入作用于对应的函数。
*** d3实际上是一个自动生成html的工具，它的函数代码最终将生成一个html，然后浏览器通过渲染这个html来实现功能。
*** js从底层就被设计成为可拓展的，它在设计API时，采用的是如下的方式getData(building、cloor）这种方式而不是getBuilding，这样如果后期要加入City等就不需要修改API了。
** 2015/12/16
*** innerText与innerHTML的区别是前者会把文本原样插入到html而不会解释执行，而后者会先插入然后再解释执行一次，所以其实后者比前者的效率要低，不需要解释执行的话用前者会比后者好点。
*** js的apply与call为什么如此重要？因为这两个函数使得函数可变了，而传统的函数调用方式只能使得对象与输入参数可变，不能随意变换函数，从而把js的抽象能力提升了一个数量级。
*** 使用函数来进行延迟计算，开始仅将少量信息求出来，然后如果需要继续拓展，使用函数运算符进一步来获取。
*** 不知从什么时候开始，我有点渐渐丧失了自主思考的能力，如果这个能力没有，那么想要看懂代码的结构几乎没有可能。
*** Layer的SetOptions实际上是给layer添加了两个方法字段，style以及nodeStyle，然后当重绘被触发时，d3会依次调用每个方法字段，通过字段指定的参数值去修改地图对象。
*** webEditor特效实现原理――――当我点击开关特效时，会产生一份数据并把这个数据传递给渲染引擎，渲染引擎使用这份数据作用于指定对象，每次渲染的时候重新修改对象进行显示。实际上这种方式有个很大的缺陷就是重复修改对象，没有存储，效率会很受影响。
** 2015/12/17
*** chrome的底层是V8引擎，是通用的，虽然前端的写法千变万化，但其实最后都是转化成为了一样的对象（一般就是js对象），然后对这个对象进行操作的。
*** REPL的学习方式是非常重要的学习方式，因为它本质是边试验边学习的方式。
*** js中，一旦出错，代码就不会继续往下执行。注意是不再往下执行，并不是直接崩溃。这造成的结果就是如果这个出错的代码仅仅是某个末端函数，那么这个错误只会影响到这个功能的实现，并不会对其他地方产生什么印象，但是如果这个地方位于核心的区域，比如时间循环等，就会影响到其其它功能的运行了。所以，写程序时要多判空，为了程序的健壮性。
*** js取一个对象的子属性时，一定要先对这个属性进行判空。比如如果有这样的代码：a.b.c.d取属性，那么形式一定是a&&a.b&&a.b.c&&a.b.c.d这样才能保证不出错。
*** js的call与apply实际上是切换函数代码的一种行为，使用第一个参数指定的对象来调用函数代码，相当于给第一个参数对象添加了一个函数。
** 2015/12/21
*** 使用全局变量来标识一个功能，一个地方设置，到处都可以识别这个功能是否处于打开状态，然后根据这个状态进行渲染等动作。
*** 存储也许是前端的一个非常大的瓶颈，因为前端很多时候都是直接计算出最终的dom树，并没有将中途的dom树保存的功能。
*** 为什么js的代码比较难看懂呢？很大的一个原因也许是因为它看不到成员，无法让人理解实体。
*** iD的graph实际上就是一个树。
*** js的apply与call实际上做的是等价代换，用其他函数的代码来放在原函数中产生新的函数。
*** TODO 返回一个函数到底意味着什么？有什么意义？对一个函数做出一定的修改，由函数到函数，虽然类别上没有变化，但其实所做的事情已经有点不同了，纯函数式编程也不离不开这个东西，这种等价慢慢做事的方式非常奇特，值得被好好研究。
*** js要实现异步函数非常简单，直接返回函数就可以了。高阶函数并不一定是接受其他函数作为参数的函数，还有一种很常见的情况是函数返回一个经过修改后的函数。
** 2015/12/22
*** js除了可以使用"."这种通用的方式来操作对象属性以外，还可以使用"[]"数组运算符来操作属性，这其实是一个非常值得玩味的特性。因为前者是代码，后者是数据，这带来的好处就是我们可以使用数据来操作代码，相比于lisp那种使用宏来实现这一转化来说，这种方式实际上更加直观，更加易于使用。
*** js里面其实也有不少多余的东西，比如new，我们很容易使用函数调用来弥补，这个关键字没有啥作用。
*** TODO 实际上，设计模式并不是一个好的对代码划分总结方法，它太多，缺乏条理。正确的方式应该是着眼于抽象（*），从抽象上来对代码进行划分总结的方法。
*** 哪里情况复杂，就在哪里进行抽象。比如：
	1、如果状态复杂，我就应该抽象状态。（状态机）
	2、如果职责复杂，我就应该抽象责任。（责任链模式）
	3、如果构造复杂，我就应该抽象构造。（工厂模式）
	实际上，抽象――――就是固化变化的东西里面的不变的东西，使得变化的东西拥有更少的变数。这样就能简化复杂的东西，达到简化问题的目的。
*** 计算机与人相比，非常大的一个差别是计算机没有人一样的视觉，人可以一次看很多东西，而计算机，一次只能看到一个东西，所以，计算机只能通过遍历来找到自己想要的对象，而不像人一样也许一眼就可以找到自己的东西向。
*** dom树的每一个对象都不是轻量的，拥有太多的也许从来不会被使用的成员，尤其是“on...”这些事件成员，每当某个事件发生时，js会遍历事件成员对应事件的所有函数，转而去调用对应对象的对应方法。
