* 2017/05
** 2017/05/04
*** 我一般习惯于抽函数，将所有的重复代码都抽出来，这本没有错，但不能乱抽。如果抽的不合理，那么抽出的函数与函数之间就会出现过度耦合的情况，你修改了一个函数，另一个地方也使用到了这个函数，也意外的被修改了。应该抽跟业务逻辑没有关系的函数并形成一个函数库，实际上也就是函数式编程里的那些函数。
*** 关于async与await,它的原理实际上是当碰到await函数调用的时候，将这个调用以及前面的调用代码暂存到promise等待队列里面，然后当队列前面的函数返回的时候，将resolve的值给到函数的返回值继续往下执行，它将一个函数分成了好几段，然后一段一段执行，直到结束。它实际上只是promise的语法糖而已，但是它能极大简化promise，使得我们能够更轻易的写出更加复杂的逻辑。
*** async与await的最大意义是使得异步代码能够更好的与同步代码配合着去写代码，我们再也不需要一碰到异步就将这段异步代码单独放到一个函数中去处理，或者为了这个异步写一大堆无意义的重复代码，比如then()，比如catch()等。
*** TIPS 豆瓣开发API是测试异步接口的一套非常好的API接口，而且具有一定的实用性，可以用来写写爬虫之类的。
** 2017/05/06
*** IMPORTANT pandoc————使用haskell写的文档格式转换神器，能够让我们轻松的在docx、markdown、org-mode、pdf、odt、slide,甚至xml、json这些格式中互相转换，实在是写文档及演示的必备神奇啊。
*** TIPS pandoc将文档转换为pdf时，有两点需要注意，一是需要制定latex引擎，否则会报错，二是要不指定字体，否则中文是不会出现。所以，最后的转换命令需要多加点"料",形如：
	pandoc test.org -o test.pdf --latex-engine=xelatex -V mainfont="SimSun"
*** TIPS Latex到底是什么呢？它实际上是一门排版语言，也可以说是一门标记语言，与markdown差不多，不过比markdown更加的复杂强大，它主要用于生成具有印刷质量的文档。
*** IMPORTANT 工作只是生活的一部分，而且是很小的一部分，虽然它从时间上算真的占用了非常多的时间，但其实真的是这样。要想活得精彩，功夫在工作之外。
*** markdown语法总结：
	1. markdown最重要的语法元素类型实际上非常少，列表、链接、引用，基本上掌握了这几个就没什么了。
	2. 它实际上类似于去掉标签只有类的html，比如*、#、·、[]等这些实际上就是html里的class，表明文章的元素类型。通过这种简化，将具体类型的样式给定死，不开放给文档编写人员，这样我们就可以更加只专注于写文档。
	3. 推而广之，实际上不管是什么标记语言，html,markdown,emacs org mode,json,xml,它们的本质都只不过是将type与content写在一起，然后针对不同的type做不同的处理。这样有个问题就是转义，有些时候我们的内容里面有可能与样式标签出现碰撞的情况，这时就会出现转义符号。
*** 关于markdown与org-mode的比较，它们都是专注于纯文档写作的标记语言。但两者在抽象上有些区别，两者各有千秋吧。
	+ markdown的优点是引用格式设计的不错，比较简单。反引号、尖括号、中括号，带叹号的中括号、大于号这些比org-mode乱七八糟的"#begin_xxx ... #+end_xxx"要好记与好用，对文档内容的侵入也比较小。
	+ org-mode的优点是快捷键完善，不管插入什么类型的元素，都只需要一个快捷键就可以了。
*** TIPS markdown的入门教程看多了之后容易让人忘记markdown终究只是个转换器。使用它写出来的文本最终会被转换为html的标签，看这种转换关系实际上是更容易理解markdown的，官方文档就是这么写的，实际上也是最好的markdown教程。
*** TIPS 使用马克飞象写markdown文档，写完后查看打印预览，选择另存为pdf，这也许是最简单，效果最好的产生pdf文档的方式了。
*** 使用html写界面写的多了，很容易让人忘了html还有个很重要的能力————写文档，而这实际上是一个不能被忽略的缺失，虽然不会我们现在基本不会真正用到这些标签，但是理解这些标签对我们写出高质量的html是非常有好处的。
*** IMPORTANT 语义化标签的最大作用到底是什么呢？实际上就是写好html，即使离开了css，文档的结构依然要要清晰明了，它的作用可不仅仅是为了让机器识别，更是为了让人对文档有个清晰的认识。
*** IMPORTANT 我需要注意锻炼几项自己的核心竞争力，今年上半年，我着重锻炼了自己的读英文文档的能力，应该说基本上已经成功了。在下半年的时间里，我需要锻炼自己写文档的能力，包括文档中的图表，markdown、emacs-org-mode、graphviz都要补上来。
*** 使用pandoc进行文档格式转换尽管支持的格式最多，功能最为强大，但是它有个比较头疼的模板问题，需要良好的模板配合才能有比较好的效果，而这pandoc是不是那么完善的。这在html、pdf这种需要有模板才能有比较好的显示效果的时候表现得尤为明显。所以，一般用它来进行比较基础的转换比如org格式转markdown格式这种就可以了。
** 2017/05/07
*** TIPS 面向对象的编程手法需要你把握全局观，更是面向未来编程，适合于写外层用来分类的架子代码，没有经验比较难掌握好这种大局观；函数式编程手法擅长于写流程，适合于用来控制架子里面的流程，这两种编程手法是正交的。
*** IMPORTANT 写css绝对是一个技术活，绝对不是各自写自己的，拷来拷去再改改就可以了的，你需要从全局上考虑，尽量的将可以重用的，不会变得基础样式抽出来复用，而不是整体复用。
*** TIPS box-sizing是一个非常重要的属性，它会影响到宽高是内容的宽高还是边框的宽高，这非常重要。
*** naming命名的巨大作用————
	有了命名，我们才可以使用名字而不是具体的实现，从而只需要修改实现，所有用到这个名字的地方都会一起修改，实现面向接口编程，修改实现时只要接口不变，系统的其他地方完全不会受到影响。命名确实是一个极其伟大的发明，函数名实际上也只是一个naming而已。
*** 只有读懂了孤独，你才能读懂你的用户。
	————秦汉青
** 2017/05/08
*** 执行上下文（也叫作用域）是在函数调用的时候被创建的，this是组成执行上下文的一部分。如果直接调用一个函数，由于没有对象可以绑定到this，所以this是windows.
*** js是单线程的，但是它需要在每次主线程循环结束后检查下所有的异步回调，看是否有相应的回调需要调用，大致的代码如下：
	function mainLoopFunc(){
	    ...

		asyncFuncs.forEach(func => func.triggered ? func() : null);
	}
*** 原型链、作用域链。原型链用于对象的属性查找，作用域链用于函数求值时的变量查找，这两者非常相似但不是同一个东西。
*** IMPORTANT 什么是交互？交互实际上就是事件监听与处理，这也是组件最核心的东西，组件的本质就是抽象出组件逻辑以供业务逻辑调用，而这些组件逻辑实际上就是事件监听与处理。
*** 如何实现图层？图层实际上是一个数据的管理机制，通过图层，我们可以将不同类型的数据放在不同的图层中分别处理，大大简化了管理数据的难度。它实际上只是个数据分类机制而已。
*** TODO 变量实乃最重要的抽象手段，没有之一。一切抽象技术的本质实际上都只是将不变的东西拿出来设个变量，同时将变化的东西弄成参数（实际上也是变量），这样我们就可以实现重用了，而且只要接口不变，我们可以修改实现却不影响系统的功能。
** 2017/05/09
*** js的无类型有些时候并不方便，有些时候一个对象被传递过来后，你并不知道这个对象有哪些属性与方法以及这些属性与方法是如何使用的，这个时候通过Objecct.keys(obj)以及Object.keys(obj.__proto__)可以大致的看下，至于更详细的信息就要查API文档了，这个时候你就会发现对于js来说，文档是非常重要的。
*** IMPORTANT 不要小看下面这个函数，它是一个非常通用而且非常简单的遍历树的函数，不管是二叉还是更多的叉，使用它我们能够对树结构上的所有节点一个个的进行处理，比如统计dom树的节点，统计文件夹中的文件等，非常有用。
	function triverse(tree,cb){
	    cb(tree);
		for(let i = 0;i < $elem.children.length;++i){
		    triverse($elem.children[i],cb);
		}
	}
	
** 2017/05/10
*** IMPORTANT 不同的代码写法、语法糖等并不仅仅只是敲字符的多少而已，它还将深刻的影响我们的思维。比如async与await，它实际上是做到了返璞归真，以一种不阻塞主线程的方式实现了异步等待，我们再也不用将异步代码后面的代码专门抽到一个新的函数里面去实现异步续处理了，同步与异步的写法终于得到了统一。
*** promise的缺点：
	1. 非Lazy的，一旦新建，立即执行，无法中途取消。
	2. 在错误处理上有缺陷。promise内部抛出的错误，不会被外部的catch捕捉到。
	3. 复杂的异步场景下有缺陷，只能等待单值，如果是多值的话还是需要嵌套。
*** promise虽然比较好的抽象了异步的定义端，但是对异步的调用端的抽象却不怎么好。这会导致我们碰到比较复杂的promise调用时力不从心，比如等待多值的情况。真是为了解决这一问题，才有了generator与async/await。
** 2017/05/11
*** 递归并不总是低效率的代名词，有些问题用递归解决比循环要简单得多。大部分都是一些需要探测或者处理几个分支的情况（每个分支又有可能生成更多分支）的问题。
	————《Javascript编程精解》
*** TIPS 循环只是一种特殊情况下的递归，发明它是为了效率而不是必须。它只是递归的一种特殊情况，模式定死，无法改变，简单重复。在循环过程中，我们对过程的控制能力非常有限。想要获得更强的过程控制能力，就必须写递归。所有循环都可以轻松改写为递归，但递归改成循环却不是那么好办。
*** 使用异步callback加递归可以轻松实现异步循环等待，这样直接用原生的ES5就可以实现异步续处理的效果了，非常牛逼。比如：
	function wait(count){ //循环从1输出到10，每个一秒输出一个数
	    let timeId = setTimeout(function(){
		    clearTimeout(timeId);
			if(count < 10){
			    count++;
				console.log(count);
				return wait(count);
			}
			else{
			    return;
			}
		},1000);
	}
*** 去掉了循环，我们再来思考下条件判断这个东西，条件为什么不能是函数呢，当然是可以的，像lisp这样的语言，条件判断实际上就是一个函数。有了这点认知，我们可以得出如下结论：
	一切皆函数，不管是循环还是条件，通通都可以用函数来表示，编程得到了和谐的统一，没有什么语句，什么都是函数，仅仅使用函数就可以完成所有的事情。
*** 实际上可以这么理解，前++与后++的差别在于优先级，前++是高优先级，先加1了在进行其他计算，而后++是低优先级，先进行其他运算了再进行加1。比如fn(a++)与fn(++a)虽然最后a都是加了1，但在fn里面a的值是不一样的。
*** 交互的本质就是事件监听处理，这句话本身非常简单，但其实有着很多隐含的信息。比如：
	1. 事件监听是哪些？鼠标当然是时间监听，但是键盘就不是了吗？当然也是的，而键盘上的事件监听多数时候就是快捷键，所以，快捷键是交互上不可或缺的一环。特别是对于编辑器这种UI元素非常少的元素而已，快捷键是交互中极其重要的一部分，如何区分用户在不同的场景下点击某个按钮是表示的什么意思，是成败与否的关键。
*** 模块化的本质就是封装某个功能，而一个功能的核心实际上就是一组交互，有可能是鼠标交互，还有可能是键盘交互，每个交互得目的实际上都是修改数据。
*** 如何管理交互呢？交互的管理包括交互的创建/销毁、加载/卸载、启用/禁用、查询、查看这些都是需要考虑的问题。可以这么说，交互的管理绝对是一个非常复杂的问题，而且暂时好像没有什么库是瞄准这这一块问题在解决，是有非常大的改善空间的。
*** 不管是iD的operation，还是openlayer的interaction，它们的核心实际上都是交互，它们的本质都只是用来管理交互的而已。一个好的交互管理系统应该具有如下特性
** 2017/05/15
*** 实际上if与for语句只是函数的一个简写形式而已，我们完全可以不使用它们而直接使用普通函数来实现if和for。if和for只是函数的一种特例而已，简单的情况下使用它们就好了，复杂的情况下还得靠函数。
*** 函数极其强大，只使用函数就可以完成编程中的所有工作了，完全不需要使用到选择与循环（它们都可以用函数实现出来），所以才有了很多基于lambda演算的纯函数式语言。
*** 关于后端与前端开发的流程，其实基本上是一样的，区别只在于可能侧重点上有些不同而已。前端更加关注的是展示，而后端更加关注的是数据，可能就代码量上有些区别，它们的流程基本都是如下：
   	路由转发 --> 业务逻辑 --> 数据库读写
			   	^
			   	|
			   	v
			   	消息系统（事件）
*** TIPS emacs插入表格快捷键中有个很有用的插入表格的快捷键：C-c RET。当你输完表头以后按下这个快捷键，表格就被快速插入了，这个时候你就可以录入数据了。
*** TIPS 相比于markdown，org-mode更加的强大，也更加的复杂，主要表现在：
	1. 表格。markdown是不支持表格的，而org-mode不止支持表格，更支持表格上的运算，导出图片等更加强大的功能。
	2. 项标记。就是所谓的任务管理、TODOLIST。
	3. 插入各种语言的源码并执行。（其实比较复杂，因此比较鸡肋）
*** BFC是什么？BFC是块级格式上下文的缩写，它是一个独立的渲染区域，它规定了这个内部如何布局，并且这个区域与外部毫不相干。
*** 产生BFC的情况：
	1. 根元素
	2. float不为none
	3. position为absolute或fixed
	4. display为inline-block,table-cell,table-caption,flex,inline-flex
	5. overflow不为visible
*** BFC的作用：
	1. 清除浮动
	2. 防止margin叠加
	3. 产生一块独立的布局区域用来进行特殊布局
*** 实际上,FC是一块区域，它定义了内部元素的排布规则。IFC内的元素是水平排布，BFC是垂直排布，GFC是行列排布，FFC是伸缩排布。
*** TIPS js中最简单的数组求和的方法也许就是采用reduce了，如下：
	arr.reduce((preResult,next) => preResult + next)
** 2017/05/16
*** IMPORTANT sort是一个非常重要的API，它也许是唯一一个按照数组中一定规则调整数组中元素位置的API了。
*** CSRF（跨站请求伪造）简单理解：攻击者盗用了你的身份，已你的名义发送恶意请求。
	XSS（跨站脚本攻击）：通过插入恶意脚本，实现对用户浏览器的控制。
*** 对于算法问题，不要想着一步到位，很多时候，一步到位的算法不仅复杂，可维护性也非常差。很多时候，我们需要将它拆分成好几步来做，尽管会有些过程上的性能损耗，但无论是可读性还是可维护性都会大大提升。
*** TIPS Object.assign所做的事情实际上就是把对象栈上的信息复制一遍，如果字段的值是基本类型，直接就是值复制，如果值是引用类型，就是引用的指针复制了，所以，复制出来的新对象如果修改了某个引用数据类型的字段，原对象里面的数据也会跟着一起修改。
*** IMPORTANT 高阶函数map，当之无愧的最常用的高阶函数，它的作用实际上比一般认为的大得多，它能对数组中的所有项进行运算，得到结果，然后我们就可以使用filter筛选出我们所需要的结果进行继续处理了，它往往是处理数组的第一步。
*** reduce实际上是一个filter加map，先filter出需要处理的部分数据，然后map到成果数据。
*** npm最大的问题在于顺序问题，由于无法保证包的安装顺序，导致它所依赖的包的安装顺序也是不确定的，结果
** 2017/05/17
*** 回调有哪些作用呢？回调最大的作用是抽象中间过程，注意是抽象过程，普通的函数参数只能抽象数据，但是回调参数能够抽象过程，而且抽出的这一部分是支持异步的。正式基于这一点，回调函数可以用来：
    1. 处理异步。我们可以在回调中异步等待函数结果，从而实现异步处理。
    2. 实现钩子函数。各种框架中的生命周期钩子实际上都是回调。
    3. 实现事件处理。各种事件框架的EventHandler都是回调，因为这一部分无法事先确定，所以只能用回调。
	4. 实现通用的模型抽象。由于回调能够去除模型中各异的部分，因此通过将这些部分抽象成回调就可以实现通用的模型抽象了。比如事件就是这一用例的一个特例。
*** 关于js的异步。最开始，js处理异步的唯一手段就是回调。这一方法需要程序员手动将代码拆成几个部分，将异步操作结束后的代码提出来写在单独的函数里面，非常麻烦。后来有了Promise，promise将回调封装了下，使得我们能够实现链式调用，成功的将回调的层数限制在了一层，但是依然有回调，而且碰到复杂的情况（比如等待多个值，异常处理等）写起来依然很麻烦。再后来有了async/await，我们终于可以直接实现异步等待，不用借助于回调了，再也不用就为了在同步代码中加个异步就改好多代码了。
*** 关于Generator，Generator可以暂停与恢复函数的执行，从而实现异步等待，它可以成功的简化异步函数定义端的书写，但是对于调用端，由于需要使用者反复的去next，而且我们需要通过查看函数实现才能知道每次next的结果是什么，非常麻烦。
*** async/await的作用在于不止简化了定义端，调用端也被大大简化了，在调用端，async与await会自动的去调用next，不用用户去调用，写起来自然非常舒服。
*** 不管什么语言的函数，都必然有一个自己的执行器（实际上就是求值器的一部分），这个执行器并不一定要使用基于堆栈的结构，我们完全可以自己去写这个执行器，比如使用堆来进行计算等，不同语言的执行器可能有自己的特点，并不完全一样。
** 2017/05/20
*** 尽量少用循环，多使用函数抽象，因为这样能够在你的大脑中建立起一种映射关系，它会告诉你什么是可以做到的，而什么不可以
*** IMPORTANT 堆排序确实是一种非常巧妙的排序方法，它提供了一种看数组的全新的视角，并由这种视角让我们看到了重复子问题，从而可以使用递归进行问题求解，的确让人脑洞打开。
*** 关于排序算法的总结：
	1. 交换排序算法，比如冒泡排序、快速排序还是堆排序，每轮都只能排出一个数，然后总需要n轮才能完成排序，所以它们的时间复杂度总有个系数n。不同的地方在于排出一个数所使用的算法，冒泡排序需要比较n次，而快速排序与堆排序都只要log(n)次，相乘就是各自算法需要的时间复杂度了。
	2. 插入排序是一种非常好玩的排序算法，它并不是普通算法那样基于数字交换，而是基于创建一个新的数组，排序的过程中这个新数组越来越大，最后就得到了排好序的数组。
	3. 桶排序（基数排序）也是一种创建型的数组排序方法，与插入排序方法类似，不过它额外使用了桶来存放数据，而不是插入排序的一个普通的数组，由于特殊的结构，提前做好了准备工作，排起序来非常轻松，只需要n的时间复杂度，不过也正是因为这个特殊结构，使得它的使用比较受限。
	4. 归并排序，基于数组合并的排序算法。
** 2017/05/21
*** 关于写算法这个问题。写算法要想写的好，有很多需要注意的地方：
	1. 你需要擅于抽变量，这样才能言之有物，基于变量来思考，而不是纠结于细节。
	2. 你需要擅于抽函数，这是算法的基元，同抽变量一样，抽函数也是让我们站在更高的角度思考问题的极好方法。抽函数不同于抽变量的地方在于你需要仔细思考函数参数，需要思考使用哪些参数是必然可以算出什么的。至于怎么实现可以延后。
	3. 你需要擅于发现重复子问题。绝大多数的复杂算法都需要用到递归，只有找到了重复子问题才能使用递归。
*** 关于css的height,有两个事需要格外注意的，一个是clientHeight，是显示出来的height，它是会减去滚动条的；另一个是scrollHeight，它会加上滚动条隐藏的高度。
*** 几种常见的DOM元素排布规则：
	1. 块级元素是从上往下排，使用width、height设置宽高；
	2. 行内元素是从左往右排，使用margin/border/padding/content决定宽，使用font-size决定高；
	3. 行内块级元素是从左往右排，但是元素内部不是使用行内元素的宽高设定方式，而是块级元素的宽高设定方式。
	4. flex-item与行内块级元素宽高设定方式差不多，但是它元素与元素间的间距是可以自动分配的。
*** 常见的实现自适应的方法：
	1. media query。不同的设备屏幕使用不同的样式，实现自适应。
	2. flex布局。使用flex布局的justify-content,可以自动分配剩余空间，实现自适应。
	3. grid布局。grid布局能自动伸缩格子的宽高，实现自适应。
*** HTML是骨骼、架构，CSS是肌肉、美妆，JS是运动、表现。他们的互相配合才诞生了成千上万的网页。  ————《css3 flex流动自适应响应式布局设计》
*** TIPS 在递归中，return扮演者非常重要的作用，递归类似于浏览器中事件的捕获与冒泡，通过一层层递归，问题被向下分解为一个个子问题，这就是捕获，通过递归调用实现，然后子问题需要向上合并成结果，也就是冒泡，这就是return的工作了。
*** IMPORTANT 函数的本质就是用一句话代表一段话，使用参数作为输入，实现代码作为处理，返回值作为输出，输出可以作为其他函数的输入继续到其他函数处理，实现续处理。
** 2017/05/22
*** 实际上，各种标记语言写出的文档，不管是markdown、org mode、json、xml，甚至html、pdf、odt、doc等，它们都是一种结构化的文档（带语法树的文档），由于文档是结构化的，我们才可以对它的结构进行变换，由一种格式生成另一种格式，甚至生成图片这种非结构化文档的格式都是可以的。
*** IMPORTANT 实际上，把递归写成尾递归是非常容易的，只需要按照以下的规则来写就好了：
	1. 避免在函数中使用子递归的返回值进行其他计算，返回值应该被直接return出去。一旦使用了子递归后面就不要进行其他计算了。
	2. 很多时候我们确实需要递归后的结果进行其他计算，这个时候应该把计算后移到下一次递归中，具体做法是将这些数据放在函数参数中，下一次就能使用这些数据进行计算了。
	总之，就是————计算，递归，再计算，再递归，递归之后不要做其他的事，这样写出来的递归就是尾递归了。
*** 关于递归中的可变数据与不可变数据问题，应该遵循这样的规律：
	输入数据应该是不可变的，至于输出数据，在计算的过程中不断修改知道最后得出结果，这样是没有什么问题的。由于过程中并没有修改输入数据，所以副作用也没有什么问题。
*** Y组合子到底是个什么东西呢？是一个函数的变换器，一个高阶函数，输入一个函数输出一个函数。然后我们可以在这个过程中进行一些其他操作比如记忆化之类的。格式如下：
	Y(F) = F(λ x.(Y(F))(x))
	使用js实现如下：
	let Y = F => (x => F(y => (x(x))(y)))(x => F(y => (x(x))(y)))
	然后使用的时候：
	let FactGen = fact => n => n == 0 ? 1 : n * fact(n - 1);
	let Fact = Y(FactGen);
	这样就可以了。使用它可以实现匿名函数递归，记忆函数执行结果等。
*** 函子是函数式编程里面最重要的数据类型，也是基本的运算单位与功能单位。函数式编程就是通过先将数据封装到函子里面（of方法），然后通过各种函子变换（先将数据从函子取出并求值，求值结束后重新通过of封装）并返回新的函子的科学。为什么要把数据封装到函子里面呢？是为了给数据添加一些方法，不修改数据的同时又能处理数据。为了实现链式调用。
*** 函子实际上就是带数据的函数，数据位于函子的两端，函数使用函子作为参数处理数据然后返回一个新的函子，这样就能将副作用消弭于无形。
*** TODO Monad，Monad可以理解为一种函子的结合，因为函子在求值的时候只代表集合中的一个元素，需要一个东西来表示整个集合，因此就出现了Monad。
*** CPS只不过是一种代码风格，一种函数的写法而已。它实际上是一个高阶函数，函数的结果不使用return传出，而是接下来执行的函数，俗称continuation，它最大的作用就是用来实现控制流。
** 2017/05/23
*** 只有前端才有跨域问题，nodejs并没有跨域问题，这是多么的幸福，呵呵。
*** TIPS 关于async/await要注意，async函数总是会把return的值封装成一个promise对象然后返回，要想直接获取值的话要么使用then，要么使用async/await再包一层。
*** js中,与正则相关的方法有如下这么几个，exec、test、search、match、replace、split。其中，属于正则对象的方法只有exec与test，剩下的几个都是都是字符串的方法。当然，想用正则对象调用剩余的几个方法也是可以的，方法是使用Symbol，比如re[Symbol.match](str)这样。这几个函数无论是取名还是返回值都非常差，下面一个个说明：
	1. exec方法与match方法类似，但是exec方法只返回第一个匹配的对象，即使指定了g（但是制定了g之后下一次调用exec它会接着上一次的匹配结果继续匹配），这就使得这个方法没什么用了，还不如用match。
	2. test方法用于搜索字符串中是否有指定模式的字符串，返回bool值。这个方法与search非常类似，也没有什么用。所以，综上，挂在RegExp对象下的方法基本都没啥用，对js，使用正则可以理解为都挂在字符串的方法上。
	3. search会返回第一个匹配元素的下标。
	4. match返回匹配的一个或多个子串。
	5. replace会将字符串中匹配的子串替换成给定的字符串，可以替换一个或多个。
	6. split就是按照给定的模式进行字符串拆分了。这四个方法可以简单总结下，search是查找是不是有，match是找到并取出来，replace是找到并做一定的处理修改回字符串，split是找到并使用找到的子串打散字符串。
*** IMPORTANT js中，字符串拆分的方法，除了split以外，还有一个不能忽略的方法，就是match，它配合正则能够做到非常复杂的字符串拆分，甚至多重规则，非常强大，必须牢牢掌握。
*** IMPORTANT js中,这种格式的正则是非常容易碰到的，(pattern1)|(pattern2)|...，因为它能够实现匹配多种结构，实现复杂结构下的字符拆分，非常重要。
*** 回调函数是处理异步或延迟动作的通用方法，但是它们不是最好的选项。是否有其他方法来组织异步代码呢？事实上是有的，你所需要做的只是改变一下角度，如果你有一个类型代表异步计算的结果，你的代码就可以像传递值或变量一样传递它，好处是平整，流畅性和可读性。Promise就是这种思想的一种实现。
	————《用Monad替代嵌套回调》
*** 面向过程设计与面向对象设计的主要区别是：是否在业务逻辑层使用冗长的if else判断。如果你还在大量使用if else，即使你使用Java/C#这样完全面向对象的语言，也只能说明你的思维停留在传统的面向过程语言上。
	————板桥里人《你还在用if else吗》
** 2017/05/24
*** 关于正则有两个非常重要的东西要注意，一个是分组，也就是"()"，另一个是过滤器(专业术语叫预查)"(?=)或(?!)"。
*** TIPS 预查是正则表达式中非常重要的概念，它能过滤掉某个匹配单元前面或后面符合或不符合指定模式的匹配单元，是一个非常有用的功能，但比较遗憾的是，js并不支持反向预查，只能支持正向预查。也就是说，js的正则无法过滤掉以哪个模式开始的匹配单元，只能过滤以某个模式结尾的匹配单元。
*** TIPS 尽管js的正则不支持反向预查，但是是有变通方法的，方法就是写正则时将想要匹配的内容用括号括起来，匹配后使用RegExp.$1-$9这种形式来提取就可以了。注意，直接在控制台一行一行敲是有问题的，需要放在一起一次敲才可以看到效果。
*** 测试正则表达式的方法除了使用FE前端助手这种工具以外，还有个更简单的方法，就是直接在你的编辑器中输入要匹配的字符串，然后使用正则搜索，就能直接高亮出匹配的子串了，使用这种方法有个好处是不用自己费劲写"//img"这种无意义的前后缀。
*** input --> verify(filter) --> store,这就是所有交互的流程。
*** 关于新语法这个东西，新语法固然是都可以直接用老语法直接实现，但是多需要使用很多高阶函数才能实现，而大多数的程序员对高阶函数还是心存恐惧的，但通过新语法，我们可以忽略这些细节，这样就大大降低了使用门槛了，但要注意这也会加大语言的入门难度。
*** TIPS 关于Decorator，它实际上只不过是一个定义属性（方法）的钩子而已，允许我们对属性作出一些修改或。长久以来，我们定义属性的时候，如果想要对这个属性提前做一些事情，只能通过再包一层函数来做，这样使用起来非常麻烦，没啥人这么干，但是有了decorator后，我们可以很容易的做到这一点了。
