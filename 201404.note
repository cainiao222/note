* 2014/04
** 2014/04/03
*** 创建日期与修改日期不一样，创建日期是指新建那个文件的日期，修改日期是指修改所创建那个文件的内容的日期。前者相当与create（增）,后者相当于alter（改）。

** 2014/04/04
*** 在面向过程的c语言中，没有像其他语言一样的public,private等这样的可见性控制关键字，要实现类似的效果怎么办呢？其实很简单，在.h头文件中不要写出这些函数，而在.c文件中实现这些函数，这样外人就不知道这些函数的存在，相当于private了。

*** 数据结构的改变是会动根本的，会导致很多很多代码的修改，确实有必要把数据结构单独来作为一层来处理，否则会非常麻烦。

** 2014/04/08
*** 在程序运行时是可以打断点的，碰到程序长时间无法响应的情况时可以试试这一技巧。

** 2014/04/09
*** 使用ssh,telnet等远程登录的协议时，控制台是在当前主机，不是在远程。所以当使用printf,cin,getch,cout等从控制台读写数据的函数时可以直接从当前主机读写数据，而无需顾及远程主机。

*** mpiexec实际上就是一个多进程的程序，支持在本机甚至远程上开启多个进程执行程序。具体就是在程序调用之前加了一道流程用来转发消息，处理中间数据等这些，实现了程序的代理执行以及管理。实际上程序调试的原理也是这样的，提前截获程序的数据，也可以在程序运行时截获数据，当然截获的过多会造成程序运行缓慢。

** 2014/04/10
*** 何为云计算？一般的说法是程序运行前并不知道这个计算会在那台计算机上被处理。实际上很简单，云计算只是在普通多机运算的基础上增加了一个动态分配计算节点的能力，使得计算能够以一种更灵活的方式被处理，特别是增加删除节点非常方便。

** 2014/04/11
*** 想在类改变后不需要经过重新编译，直接使用以前的程序，这一点根本不可能在C++上实现。因为c++不是动态语言，无法在程序运行时改变其类结构。如果真要实现，只能玩弄内存游戏，自己生成类，但这样做必须建立在深入理解c++内存布局的基础上的，实现起来跟自己实现动态语言没什么两样，太过复杂。
*** 很多新技术（比如反射，元编程等）固然是比较厉害，但很多时候我们其实并不需要这些东西，直接使用原有的技术就可以解决问题。在这种情况下使用新技术只会徒增复杂性，不如不用。之所以会出现这种必须使用新技术的错觉很可能是因为我们对问题的划分有问题，实际上问题的划分是个大问题，很多时候会极大的影响解决问题的复杂度。当使用某种方法解决问题很麻烦时，可以考虑换个问题划分的方式，也许这个问题就能很简单的解决了。
*** 实际上二维图表一次只能表示表格里面的两行数据，反过来说表格里面的两列数据就对应一张二维图表。如果有三列及以上数据要表示在图表中，必然要有某一列作为横轴（或纵轴），其他的作为纵轴（横轴），一共会产生列数减一条线先出来。二维图表的表达能力仅此而已，只能表示表格的几列数据。
*** 即使是像课表这样复杂的表结构，都必然可以转化为数据库里面的那种只有一个轴表示列名的表结构，转化为这种表结构之后就可以很简单的转化为图表。反过来想想其实图表只是数据库里面的一条条记录而已，只不过是一个数据库行的对象数组。所有这些数据都是可以相互转换的。

** 2014/04/13
*** 在写函数时，最好在函数上面加上这个函数的说明，包括这个函数是干什么的以及每个函数参数与返回值的说明。注意，这种说明是可以被vs的智能提示识别出来的，以后自己调用这个函数时这部分说明就会弹出来，你就可以对这个函数怎么使用一目了然了。
*** 封装别人的代码库要注意尺度，就是要注意要封装的类到底有多少个，如果要封装的类过多，封装起来就会很麻烦，不如不封装。
*** 编程中，变量命名是一个很重要的问题，类名，变量名，函数名，这些会极大的印象程序的可读性，可不是小事。

*** 函数的名称本身就是一个短注释，很多时候可以将其代替掉。但函数长度是有限的，过长的函数名会让函数很费解，此时注释就是必须的了。
*** socket是接口的意思，到底是接的哪两个口？实际上接的是应用层与传输层的口，即把应用层与tcp或udp连接起来，通过他们来与底层通信实现信息的传送。并不是通常所理解的将两台电脑连接起来，这一工作实际上是有底层的链路层去做的，我们并不用去关心。在这种理解下，网络通信实际上可以这样理解，我们只需要给自己电脑的传输层（tcp，udp）数据，他自然会帮我们去传输数据，网络编程其实还是单机编程，我们一般只是在使用应用层的协议与自己电脑的传输层通信，具体的通信细节不需要我们去关心。
*** 通过网址浏览网页的过程：先讲网址发送给dns服务器，由服务器查询出目标网址的IP地址，然后向获取的ip地址发送请求，此时就要查询路由表了，根据路由表，一个一个寻找下一个路由，最终将请求发送给那个ip地址。
*** 有以下几个关键的查看网络状态的命令要记住：
+ nslookup 查看dns服务器地址
+ route print 查看路由表
+ tracert 追踪路由表
+ tracert IP 通过ip地址查主机名
+ ping 主机名 通过主机查ip
*** return此语句会释放局部变量的资源，注意。

** 2014/04/15
*** license原理：利用当前电脑所处的网络环境，比如ip地址，cpu时间，网卡mac地址，硬盘或cpu机器码等产生随机数，生成公私匙。用户执行程序时会先使用本机上的公匙文件验证身份，验证通过才允许执行，否则不允许程序执行。
*** 关于license验证，实际上就是一个类似于rsa远程登录的问题，公匙提供给别人，私匙自己保存，只有通过了这种公私匙的验证，才允许程序执行。
*** 整个计算机网络结构层层分组，弄出这么复杂的结构其实就是为了解决一个问题，如何在发送端把一个很大的数据拆成很多份在网络上传输，然后再在接收端重新将数据还原。由于网络的不稳定性而引发的一大堆问题是引发如此复杂网络结构的根源。具体过程如下：
1) 使用应用层协议与传输层通信，将数据拆分成报文（tcp或udp),在这一部分主要是以端口的形式封装了进程号。
2) 将传输层的报文送给网络层，将报文拆分成IP数据报（最大64k)，这一部分主要是添加了IP地址以使信息可以在网络上传输。再将数据报转交给链路层。
3) 链路层再将IP数据报封装成帧（最大MTU，1500字节）。
4) 然后链路层就可以将数据转交给物理层以脉冲信号传输了。

*** 要注意路由器的结构，路由器是不认识应用层与运输层的。它完成自己工作任务靠的是网络层的IP地址。它里面只有网络层，链路层与物理层三层结构。
*** hpp文件，这一将.h与.cpp文件写在一起的函数组织方式，一旦这种文件被多次包含，就很容易产生重定义的错误，因为两个cpp文件中都包含了这个文件中函数的实现。
*** 关于递归算法的理解问题，其实可以对照非递归算法来看。递归算法就是在非递归算法的基础上加了几行而已，理解了非递归算法，递归就是很多个符合条件的非递归算法而已。
*** 使用三个我——本我，自我，超我来待人处世。本我负责生活，自我负责相处，超我负责思考，三个我一同作用，才能活的精彩。
*** 程序效率秘诀：
1) 能够放在循环外面做的事不要放在循环里面做，尽量减轻循环的运算量。
2) 尽量减少磁盘IO,一次磁盘IO所花费的时间甚至比O(n3)复杂度算法所花费的时间更大。
3) 在循环里面尽量减少new与delete，malloc与free，因为在栈上开辟释放空间比在堆上大约快500倍左右。
** 2014/04/17
*** 在栈上开辟释放空间几乎不花费时间，因为空间是早就开辟好的，开辟释放空间仅仅只需要做一次加减法而已。而在堆上开辟释放空间是需要时间的，在i5上的试验结果，在堆上开辟释放1k的空间一百万次需要950毫秒左右，对比在堆上的0毫秒时间，速度差距可见一般。在栈上开辟释放空间一亿此需要200毫秒（对比堆上94秒），基本就是一个时钟周期就可以开辟释放一次。

*** 有时程序的自动优化反而会帮倒忙，不优化比优化运行起来还快些，要注意。优化与不优化最明显的区别就是如果开启了优化，已定义但没使用的变量不会被生成在输出文件里面了。

** 2014/04/18
*** google的go语言里面不需要继承，只要函数的头相同，就可以相互替换类，估计就是用类似于c++的bind与function来实现的。
*** 控制台程序使用MFC类的方法：
1) 包含afx.h或afxwin.h。
2) 在属性的运行时库选项上选择/MT或/MTD，默认的/MD或/MDD是不行的。根本不用将Use of MFC选中。
** 2014/04/19
*** 矩阵是一个非常重要的东西，是第二代的数学模型，几乎所有的数学问题到最后都可以转化为矩阵问题。矩阵的本质是运动，矩阵的乘法就是施加运动的过程。也可以说矩阵是一种变换，是一个对象从一种状态转变成另一种种状态的过程。矩阵实际上描述了一种坐标系，运动实际上等价于坐标变换。
*** 判断两个矩阵是否能够相乘有个很简单的判断方法，将前面那个矩阵转置，如果转置后的两个矩阵行数相同，也就是高度相同，就表示这两个矩阵是可以相乘的。
*** 不管是windows还是linux，其实都是通过用户和组来管理权限的，而用户是易变的，所以对管理者而言，管理用户是没有多大意义的。要实现高效管理，得从组上多做文章。windows下默认就会有几个常用的用户组。比如everyone组，guest组，remote user组，administrator组，当要给予某个用户某些权限的时候，将他添加到相应的组就可以了，这样就轻松实现了权限控制。
*** 矢量的分类非常复杂，在高数里面矢量是指有大小方向的量。线性代数里面也有矢量，但这里面的矢量是指行数或列数为一的矩阵，前者为行适量，后者为列矢量，若直接说矢量一般是指列矢量。这两个学科的矢量本来就是不同的东西，只是碰巧名字相同而已，不要搞混了。前者就是一个有大小有方向的东西，后者是一个一维的数阵，根本就是风马牛不相及的东西。
*** 打开windows自带的画图工具，先把画布调到最大，然后就可以把这东西当作草稿纸了。
*** 如果一个系统的流程基本固定，但却有很复杂的中间状态量，这些状态量每次数值的不同会得到不同的结果，这样的系统就适合于采用状态机来设计。最典型的例子就是OpenGL.状态机实际上是系统本省内置了很多全局的状态量，通过设置这些状态量即可完成系统的功能。这种方式有一个很突出的有点就是可以减少函数参数。
** 2014/04/23
*** 实际上不管是MFC，C#，qt等等，不管是哪一种编程系统（主要是框架）其核心都是消息传递的机制。为什么消息机制如此重要？因为就是通过消息，各种不同的代码单元（对象，类，模块，服务甚至是计算机的socket）之间可以相互通信了，庞大的系统得以细分，大大减轻了复杂度，大规模编程才成为了可能。理想的通信方式是互相通信时不需要知道代码单元的名称，因为未来添加模块的名称是不可预知，只需要知道模块中函数的接口（函数头）就可以通信。因为未来添加的代码单元的名称是不可预知的，但通用的函数头是可以简单提供的，这种方式就为模块的拓展性提供了无限可能，这才是一种完全解耦的代码单元间的通信方式。在最开始提到的框架中，MFC做的最差，必须知道类名才能委托实现，而要实现这个只有通过继承。c#与qt相对好点。

*** c++0x实际上增强最多的就是对象间的通信方式，比如
1) 右值引用，完美转发。
2) bind，function,lambda与auto。
3) ...
这些实际上都是为了做到函数灵活通信，实现转移，这样就能以一种更灵活的方式组织大型系统，极大提升代码通信的能力。

*** 什么叫做左值，什么叫做右值？左值是表达式结束之后值依然存在的持久变量，右值是表达式结束后就不服才在了的临时变量。到底是持久变量还是临时变量是左值与右值最本质的差别。对左值取地址是可以的，对右值取地址是危险的，因为马上会被销毁。

*** 其实数据库就是一个文件系统，他区别与操作系统的文件系统的地方主要在于他实现了加锁，事务以及查询机制，使得这几个部分对用户透明，用户不用关心这些就可以安全地使用数据。如果直接基于操作系统的文件系统来存放数据也不是不行，只是有比较麻烦的加锁要处理。

** 2014/04/25
*** 很多时候我们之所以觉得问题难以解决时因为我们对问题的划分有问题，也许该一种问题划分方式就会简单很多。
*** 看别人的东西最忌讳的就是不思考，不加以思考就接受别人的理论，你永远不能体会到别人设计的精妙之处，因为好的设计总是很容易让我们觉得理所当然而忽略掉精巧之处。其实你自己空想的话这种理所当然的东西你反而想不到的。
*** 存放在磁盘中的文件最好一次将其都读入到内存，这样可以减少磁盘IO次数，提高效率。配置文件一般都是使用的这种方式，以避免频繁读取磁盘。不要等到需要使用配置中的哪些数据了才去读那点数据，这样效率是很低的。
*** 将磁盘中的数据存放到硬盘中，这是一门艺术。这样才能高效利用内存。
** 2014/04/26
*** 实际上类成员就是类里面的全局变量，是为了便于类方法之间便于通信而设计的。与其他全局变量一样，这东西也最好少用，因为会加大类方法间的耦合性。在开始设计类时其实不需要这东西的存在，是渐渐开发到后期发现某些成员需要在几个方法间公用才将这些成员从类函数里面提取出去的。其中还有两个区分，类的non-static成员是类对象的方法间的全局变量，类的static成员是类对象间的全局变量。
*** 想要一个类只有一个对象很简单，将类的所有属性与方法全部声明为静态的，这样就保证了类本身就是一个对象而不再需要定义对象。很多时候就是这种情况，我们根本就不需要类，只需要对象。到底什么时候需要很多对象呢？完成一件事有很多个一样的对象的时候。如果一件事只需要一个对象，那么根本不需要定义出一个非static的类。
*** 面向对象的程序设计跟面向过程的程序设计根本就是两种不同的程序设计方法。前者设计一个系统时考虑的是系统有那几个对象所组成的，每个对象完成哪些功能。而后者考虑的是完成一件事是有哪几个步骤组成的。两者分别在不同的部分发挥自己的作用，是可以互相嵌套使用的。当然其实程序设计初期可以使用面向过程设计，后期觉得过于复杂，面向过程设计比较难以表达了再转化为面向对象的。
*** 类应当尽量小，因为类一旦大了之后可重用性就会很差，因为类之间方法的耦合性会非常高，无法轻易剥离部分功能出来。
*** 使用c#,java,python这类库丰富的语言在处理逻辑复杂的情况时还是很有优势的，c与c++更善于解决逻辑不复杂但算法复杂的情况。
** 2014/04/28
*** 代码的清晰性与代码的效率很多时候是个自相矛盾的东西，有时为了清晰易读必须牺牲掉效率，而有时为了效率又必须牺牲清晰性。典型的例子就是循环中的代码。编写时要注意多在这两个方面权衡，写出高质量的代码。
*** 专门写一个逻辑的处理类，将自己写的代码尽量与窗口代码分开，逻辑类的成员就是从窗口里面获取的参数外加一些在成员函数中共享的变量。
*** 写代码本来就是一个不断重构的过程，不断写不断改，没有绝对优秀的代码，只有最符合实际需要的代码。需求不断再变，代码也就不断在变。
*** 一切都在变化，真正不变的只有变化。
*** Logic层（业务层）是不断在变化的层，它处理的是就是具体事情的逻辑。由于两件事的逻辑肯定是不同的（如果相同就不需要你来写工具了），所以这一层的可重用性是非常差的，常用的工具不要写在这一层。一次使用，永不复用。
*** static变量的初始化是一个麻烦事，因为成员函数这一工具在static里面不使用了，所以可能需要另外的函数来初始化，这样就会出现init等不大好看的函数，所以一般还是少用这东西吧。
*** 类成员是类里面的全局变量，在任意函数里面对某个成员值的修改将影响到所有的类函数，而不仅是当前修改值的函数本身。
** 2014/04/29
*** 全局变量最好少用，这一条规则不止是谁他吗说的，很多需要在多个类中用到的资源比如错误输出等还真就得用全局变量，否则程序中到处都需要传递这个变量，会造成代码写的很丑。

*** 在头文件中最好不要定义全局变量，因为此头文件只要被其他文件包含，就必然会产生重复定义的错误。正确的方法是在源文件中定义，然后在其他需要的地方（头文件与源文件中均可）extern。一般的模式其实就是在一个源文件中声明，另一个源文件中extern就可以了。

*** 使用单例模式代替全局变量，这样写出来的代码就比使用全局变量extern好看得多。
*** 循环优化无非两种方法，一种是做并行，一种是循环展开。
*** hpp中不可有全局对象与全局函数，否则一旦被多次包含，将产生重复定义的错误，要避免这种情况，应该讲全局对象与全局函数封装为类的静态方法与函数。
** 2014/04/30
*** 管道实际上是一种在内存里面的文件，一般大小为内存里面的一页（4k左右）。在linux里面说一切皆文件，实际上可以说的更直白一点，一切皆内存，程序只有被加载到内存里面才能执行。
*** 使用管道加创建进程截获控制台程序的输出的方式实际上与使用文件方式是一样的，只不过添加了管道以后文件是被创建到内存里面的，不会显示地产生文件，没有磁盘IO，效率更高。不管使用哪种方式，都只有等到程序执行完毕才能获取结果，无法做到实时。要想真正做到实时，必须创建第三方的中介程序来监视输出，再返回给原程序。
*** 使用fopen,fread,fwrite读写文件时，使用二进制打开方式得到的才是文本源数据。使用文本方式打开得到的不是源程序，具体的区别说就是源数据中的\r\n会被替换为\n，所以如果不想源数据改变的话，一般都应该使用二进制打开的方式。
*** hpp不支持全局变量与全局函数是其最大的缺陷，这就使得很多工具函数必须以类的形式进行封装，就失去了其简洁性，不如放弃。
** 2014/05/02
*** Sleep函数的原理应该是挂起当前线程，当所指定的时间到了以后重新分配cpu时间，这样就避免了cpu空转。这实际上是挂起线程最简单的方法了，缺陷就是不能自己恢复。
*** 编写多线程程序是有一点有特别注意：绝对不要以为cpu会乖乖的执行完毕自己的线程函数然会再切换线程，很有可能cpu把你的线程函数只执行了一半就切换，去执行其他的线程，然后由于切换的时候有些中间变量没有存储，导致再次切换回来执行时出错，小函数还好，一般分配的cpu时间足够完成出错还少点，大函数很容易出错。这导致的最典型的错误就是执行结果时而对时而错。要想避免cpu做这种非常恶心的事情的关键是在线程函数里面加锁，这样cpu就会乖乖的执行完毕你的线程函数了再切换了。
*** 在unicode这样的字符集下，甚至连printf("%s",str)这样简单的语句都会出错，因为字符占两个字节65 00，这样必然导致输出一个a就结束了。
*** 在一个函数里面用std::thread开辟一个线程，只有在这个函数里面拥有这个线程对象，拥有对这个线程的管理权，至于在线程函数里面想要控制自己也行，方法就是std::this_thread来执行。
*** 使用lambda表达式的典型情况就是开线程。开线程本来就是相当于在一个函数开另一条执行通路执行语句，有时候强行将这一过程分离开去不如写在一起清晰。
*** 加锁的关键在于定义一个两个线程都可以访问到的全局变量。这样就可以对当cpu自动切换到另一个线程要执行冲突函数时就可以先判断下是否能够指向，已达到禁止切换的目的。
*** 使用const_cast<...>(...)进行强制转型去掉cosnt性质是有可能会失败的。比如如果是const char *sz = "abcd";const_cast<char *>(sz)就不能成功，因为sz是开辟在常量存储区的，这样做编译没问题，运行时就会崩溃了。这其实跟指针向下转型时一样的，并不是说强制转型就一定会成功。如果指针所指向的本来就是子类对象就没问题，而如果是父类对象向直接转成子类对象就会崩掉。
*** 关于元函数的返回值的问题。元函数只能通过两种方式返回值，一种是const static int value = ...;另一种是typedef ... value；这种形式使它能够轻松返回多个值以及做一些简单的运算。
*** 实际上进程通信基本上都是使用的如下原理：在一个进程中开辟另一个进程，指定子进程的某些参数与变量，这样子进程与父进程就都可以访问这些参数与变量了，从而实现了进程通信。典型的例子就是管道，使用它进程进程通信的原理就是指定子进程的标准输入输出对象。
*** 函数参数为指针可以传null,为对象或引用不能传null，不然会崩溃。
*** 从学校走入职场技术上有三道关卡需要过，首先是vs的使用，然后是文件与文件夹遍历，最后是进程通信。