* 2017/10
** 2017/10/09
*** 调研性质的东西时间最难估，因为永远不知道前方还有什么坑等着你。
*** What is complicated in unit tests is not the tests itself — it is the art of separating as much code as possible so that it is unit-testable. And code that is unit-testable is code that has little dependencies on other modules, and does no I/O.    ————Gil Tayar《Testing Your Frontend Code: Part II (Unit Testing)》
*** 前端测试的坑：
	* 移动端测试
	* mock
	* nightwatch custom-command
*** 关于发布订阅模式有三个核心的api————publish（发布，也叫trigger/dispatchEvent）、subscribe（订阅，也叫on/addEventLinstener）、unsubscribe（取消订阅，也叫unbind/removeEventLinsener）。注意没有取消发布，因为发布是同步的，瞬时的，当然无法取消，而订阅是异步的，它会一直等待发布的消息，当然可以取消了。
*** 关于mock，js最强的mock工具叫sinon，没有之一。
** 2017/10/10
*** 关于const，const只是表示引用不可修改，并不表示引用的对象不可修改，比如：
#+BEGIN_SRC javascript
const obj = {
	aaa: 111,
	bbb: 'aaa',
}

obj.aaa = 222; // 正确，可以修改const指向对象的数据
// obj = {} // 错误，不能修改常量引用
#+END_SRC
*** IMPORTANT sinon的核心在于监听与替换函数实现。spy是监听者，它可以监听到函数被调用的情况，比如函数参数、调用次数、this等，被监听的函数依然会被调用，只是会将调用信息记录下来以便做断言；stub不仅可以监听，还可以替换实现，它可以强制让函数返回某个值而不是原值，被替换的函数不会再被调用；mock是带断言的spy，它的作用也是监听，只不过它集成了断言，能够设置指定情况下的断言，仅仅用在特殊场合。
*** IMPORTANT 编程的过程中，保持单一入口或是几个入口是非常重要的，只有这样才会有最强的控制力。比如:
	1. react的render
	2. redux的store dispatch action to reducers
	3. vuex的store dispatch action, action getter state and commit mutation,mutation update state.
	4. koa的use middleware
	5. ajax的封装库等等
	这些都是尽量减少了入口实现了更好的控制力。
*** 什么是plugin？plugin实际上是一个定义好格式的配置对象，写好框架代码，读取配置对象中指定的属性与方法，就能将新功能集成到原系统中，用户对框架是完全黑盒的，这样才能保证代码安全，不出bug。
*** TODO 统一的Mock机制，比如一个开关，打开后使用mock的数据，关闭后使用接口的数据。当APP启动，所有接口请求前，如果mock处于打开状态，创建一个沙盒，使用mock的数据，后期可以自由控制mock开关，选择使用的数据。好处：
	1. 统一的mock机制，解除后端依赖，无需后端接口写好才开始开发。
	2. 代码规范，所有mock的代码一目了然，mock的代码与正式代码隔离。
*** 测试Tips：
	1. 重要的问题，复杂的逻辑，最可能出现问题的地方，只有写代码的人自己才清楚。
	2. 每次出现问题，把它写进测试用例，这样就能很大程度上减小再次出现的几率。
*** VIP、单点、用券 * 用户是否登陆套餐
** 2017/10/11
*** 默认情况下，使用sinon的stub的callsFake是会替换掉原有函数的，原函数不会被调用，这时候如果你还想调用原有函数，只需要使用一个闭包将原函数存起来然后在fake函数中重新调用一下就好了，如下：
#+BEGIN_SRC javascript
// stub
const originFunc = def.fn1;
sinon.stub(def,'fn1').callsFake(arg => 'ooo' + originFunc(arg));
#+END_SRC
	这一技巧同样适用于不想全函数替换，仅仅是想改变下调用参数的情况，如下：
#+BEGIN_SRC javascript
// stub
const originFunc = def.fn1;
sinon.stub(def,'fn1').callsFake(arg => originFunc(arg + '222'));
#+END_SRC
	总之，有了替换就有了一切，修改原始函数可以通过闭包来实现。
*** TODO sinon change this, change arguments
*** IMPORTANT 一个函数中调用了另一个函数，如果我们想要修改被调用的这个函数的实现，使用stub是一个好的选择。但并不是任何时候都是，我们完全可以不用sinon，直接使用修改函数实现也能达到目的，比如：
#+BEGIN_SRC javascript
// stub not use sinon
const originFunc = def.fn1;
def.fn1 = function(arg){
  return 'asdf'
};
console.log(abc());
def.fn1 = originFunc;
#+END_SRC
	这取决于你对js的掌握程度。这实际上也是sinon的stub的实现原理：
	1. 当我们stub一个函数时，sinon会把这个函数存起来，然后当我们调用stub对象的各种api的时候，sinon会帮我们去生成一个新的函数用来替换被stub函数的实现，然后当我们模拟完毕，调用restore的时候就重新将原函数还原为stub之前的，这样就实现了函数替换与恢复。
*** DONE 原生页面 vs h5页面：
	1. 原生页面具有性能好、可以调用各种底层传感器的优势，同时也有本地打包、适配困难的劣势。适合于一些比较复杂、对性能要求高的场景。
	2. h5页面具有热更新容易、适配简单的优势，同时也有性能差、无法调用底层传感器的劣势。适合于一些比较简单的页面、活动页、需要快速更新的场景。
	3. 两者优缺点正好是互补的，要根据实际情况选择合适的方式。
*** TIPS 在自动化测试中，我们经常会碰到由于API自己会输出信息干扰到了结果输出，导致生成的结果很难读的情况，这一问题实际上很好解决，在before hook中将console.log hook成空，然后在after hook中恢复就可以了。
*** IMPORTANT sinon的API设计中为什么要将obj与fn拆分开来而不是将他们写在一起呢？比如sinon.spy(obj,fn)而不是sinon.spy(obj.fn)呢？
	因为如果合并在一起的话是进行传递的话是形成了一个新的引用，然后改变了新引用的值，当函数返回时这个改变就恢复了，而拆开的话改变的是所引用对象的值。简而言之，前者改变的是引用，而后者才是所引用的值。
*** 何等的幸运，赶上了最好的时代，人的能力无限大。
*** IMPORTANT 我常常以为emacs具有极强的拓展性，便于定制什么的。但实际上网页本身也具有很强的拓展性，通过使用tempermonkey，我们能够对网页添加钩子，注入我们的自定义脚本。使用前端最熟悉的html+javascript+css对页面进行功能拓展，实现比如改变页面内容、页面样式、小窗口播放、去广告等各种功能。唯一不足的是我们只能操作网页，无法站在更高的层级，比如空白页面、浏览器等这些层面实现功能定制。
** 2017/10/12
*** TIPS 所有页面，基本都是差不多的逻辑：
	AndroidParams --> otherParams --> pageData --> renderPage --> bindEvents --> focusLogic --> goAndBack
*** TODO 关于Android与js间的相互通信，实际上很简单，只需要通过windows.Android这个公共对象就可以了。java端在这个对象上写入方法提供给js，然后js就可以调用了，反之亦然，这应该是最简单的方式了。
*** IMPORTANT focus逻辑如何写，如何与vue无缝结合？这么来写，将focus给单拎出来，我们只需要在需要focus的元素上加上一个focus-id,然后所有有关focus的问题围绕这个id来进行，单独放在某个地方。这样一方面是非常灵活，同时也不损失任何功能性，还可以使用缓存统一提高性能，因为focus逻辑本来就不跟其他东西相关，我们没有任何实现不了的东西，实在是非常完美。我们也可以在它实现方案上加上scope的概念，实现区域逻辑。id是关键，通过id，我们能够实现显示逻辑与focus逻辑解耦。
*** TODO browser-sync
*** getAndroidParams始终是一个变数，它使得我很难下断言。我必须搞清楚它的来源，对它坐下模拟用例才好写。是通过cookie来取的coupon，而cookie是在androidParams中的。当getAndroidParams时，如果不在安卓环境下，getParams必然会报错，这样会跳到函数的catch分支中去，此时返回用来测试的AndroidParams.
*** 写测试实际上非常类似于自问自答，自己设置问题，然后自己解答。
*** redux/vuex只不过是一套实现对数据增删查改的API而已，使用它们来进行数据管理格式比较统一，读起来比较简单，容易维护。并没有其他什么了不起的东西。
*** TIPS webtv-vue的webpack打包做了哪些事情呢？它只不过是将views下的二级目录下的main.js打包到了dist/static下对应的js与css，同时在dist目录下生成了对应的html而已。最后在dist下开了一个服务器，这样就可以在浏览器中打开对应页面了。
*** TIPS vuex中：
	1. dispatch触发set的唯一入口。为什么不直接set呢？因为直接set各自调用自己的set，会导致结果无法追踪。
	2. getters是state的唯一出口。我们当然可以直接从state中取数据。但这会导致关联数据的计算无处安放地方。比如某个状态在state中存的是1/2/3，但外部需要使用的是状态一/状态二/状态三这样的中文。我们需要对state进行下处理了然后暴露给外部，这时我们使用getters。还比如state中存了很多数据，但是我们需要提取出一个数据块给外部，这时也可以用getters。
	3. commit是mutation的唯一入口。它将数据提交到store存储。然后我们可以在vue中使用computed或是props取回来。
	4. TODO store往往是通过好几次mutation到正确状态的，如何模拟？
	这实际上是一个非常好用的编程技巧，将一堆函数使用同一个入口，是的这些函数的调用变得可追踪，这才是redux/vuex的核心思想。
*** IMPORTANT 写测试用例就是一个逐步去除依赖，一个个区块测试，然后把这些区块合并在一起的过程。最底层是工具函数，上层是MVC的模块（实际上就是数据、UI以及把这两者整合起来的部分），再上层是集成。写测试用例写多了对深入了解系统是非常有帮助的。
*** 将vue-cli-test使用vuex重构。
*** 测试用例之难难在哪里？
	1. 没有办法调试————不要使用PhatomJS,也不要开什么single-run,使用chrome，然后在chrome中调试,当修改源码的时候自动跑测试，美中不足的是需要手动刷新页面。
	2. 报告经常会混入一堆乱七八糟的输出————使用sinon mock掉console.log
** 2017/10/13
*** data props computed————vue组件数据的三大入口。
*** action是mutation的封装，它给予了mutation异步的能力。我们可以通过commit一个mutation或者dispatch一个action来修改store的数据，前者可以通过哦mapMutations来简化，后者可以通过mapActions来简化。修改后我们需要从store中取回数据，这时我们也有两种方法，一是使用state，获取原始数据，有个简化方法mapState。还有一种就是getters，获取衍生数据，也有一种简化方法mapGetters。这样两个入口、两个出口，是的vuex的API相当简单清晰。
*** 有时候，我们想要获取变量名，但变量名又获取不到，这时可以利用一个等价关系：
	abc.def等价于abc['def']
	注意：这两种形式并不完全等价，后者还可以包含特殊字符。
*** vue中，即使使用了单文件组件，依然需要在外层使用components来引入组件，然后用template字段触发渲染，然后在字段值中将data中的数据作为props传递过去，否则页面上什么也不会有的。
** 2017/10/16
*** 关于focus逻辑有两种实现方法，一种是提供数据与方法，然后在模块外调用提供的方法实现focus，一种是只提供数据，然后全部在模块内实现focus方法。第一种方法实现起来比较简单，但写出来的代码不大好看。第二种实现起来会复杂点，特别是数据格式的设计，但要是实现了可以最简单的实现focus逻辑。
*** 如果想在promise的异步调用链中如果想插入新的异步调用，有两种实现方式。一种是加个then，然后加上异步处理逻辑，另一种是在then中return一个promise，这样也可以把异步调用插入的现有的异步链中，我们甚至可以用promise把几个异步调用合成一个然后返回实现链合并。
*** parent/data/props这就是一个组件的三要素了，不管是vue还是react都遵循这个原则。
*** 将component与store完全分离，以便于分离测试component与store。一旦组件中出现了vuex的东西(最常见的是mapState/mapMutation/mapActions/mapGetters）,单元测试就很不好写。应该只将关键的数据流写进vuex，而不是将所有的数据统统写进vuex。尽量将数据以props的方式传入，而不从vuex。
*** TODO 为什么不能在模板中写表达式？
*** 关于async/await，await必须写在async里面，但是调用async函数的时候是不需要在外边再加一个async的。也就是说，当前仅当函数中出现了await时才需要加async，初次之外，即使调用了async的函数也是不需要加await的。这是我以前一直记错了的地方，经验害死人啊。
*** 在函数前加async并不代表将这个函数变成异步函数了，在你调用await之前它依然是同步函数，跟不加async时没有任何区别。但一旦碰到await，它会将当前context给保存起来转而去执行其他同步函数，也就是说，此时才变成异步的了。
** 2017/10/17
*** 现有的将容器组件与展示组件分开的方式对测试是很有好处的，展示组件是很好测试的，但容器组件就比较难了，需要通过各种mock手段，即使写出了测试用例作用也很有限。
*** 对开放出的api要有感觉，任何复杂的系统，其底层接口实际上就那么几个，我们在这些底层接口的基础上进行封装，一旦这些接口发生了改变，我们只需要修改这几个封装的地方就可以适配到我们的系统。同理，只要几个很少的API就可以做到很强大的事情，比如console.log，就那么点东西，但是基于它的封装却能使我们的系统异常强大。
*** chrome的控制台是一个非常强大的控制台，能够使用它就不要使用坑爹的cmd。
*** IMPORTANT 测试驱动开发有什么好处呢？它能让程序员自发的去除多余的依赖，以搭积木的方式来完成程序的开发，这样最后写出来的程序无论是测试还是维护都非常方便。
** 2017/10/18
*** TIPS 其实之前我已经有意无意的使用过多次测试驱动开发了，我一般会另外开一个空白的工程，排除其他影响，只试验我自己想要试验的部分，然后在把它集成进入系统，这实际上就是测试驱动开发，先写测试，然后开发，虽然与TDD的原意是不完全一致的，但其实思想是差不多的。
*** 维护一个数据结构总比维护一个算法容易，因为算法比数据结构易变得多，也容易出问题得多。但使用数据结构容易损失灵活性，要注意抽出本源数据组成数据结构，而不是关联数据，这样能够将对灵活性的影响减小对最低。
*** TODO 也许可以先将scope外使用老算法，将scope间使用新算法。
*** 组件应该只跟数据（在vue中就是props），给定数据，渲染出正确的输出，不应该在外部根据数据做多余的事情。应该是纯展示的，数据不一样，展示就不一样，数据变了，展示就变了，这是组件最大的作用。
*** TODO what is vue's mixin ? what is it's function ?
*** 测试驱动开发有什么好处呢？它强制我们以一种搭积木的方式来写程序，这样写出来的程序可复用性会非常好，一旦出现相似需求复用起来会非常容易。
*** 在vue中，我们可以直接调用组件的method中的方法，这是一种测试措施，我们可以通过这种方式来验证组件的功能是否符合预期，能否得到正确的结果。
*** 实际上，在vue中，将通过new Vue（{...}）得到的对象命名为vm是一种很差的命名，应该将它命名为组件的名字，它实际上就是组件对象，我们可以通过这个对象得到组件的模板、methods、state等并修改它们，得到新的数据，它就是组件嘛。
*** TIPS vue实际上并没有做很多的东西，它实际上就写了一个函数（new Vue(...)），然后通过复杂的配置，使得我们可以很轻松的配置与组合这个函数，实现我们自己的业务逻辑。
*** 如何理解抽象？抽象实际上就是一个盒子，它能在开发人员与用户间建立一个中间层，只要定义好接口，开发人员与用户都能有很好的自由度来实现自己的功能。用户需要新的功能时，开发无论把代码写成什么样子，只要呈现的方式符合用户预期，就没有任何问题，以往老的功能也不会受到影响。
*** 实际上，单单vue的组件或是vuex的数据是很好测试的，但是一旦将这两者合起来一起用，测试就变得困难了，即使使用了各种奇淫巧技mock的情况下。
*** IMPORTANT mock是一种虚拟的场景，它代表不了实际情况，强行使用过多的mock使得测试通过是一种自己骗自己的行为，应该尽量减少mock，只有在我们不想触发三方状态变化的时候才应该使用mock，比如网络请求、文件系统等。
*** 如何写可测试的代码？应该尽可能的让我们的代码函数化，变成一个个函数，或是函数块（类实际上就是一种函数块），分离块之间的依赖，这样每个单独的块都是可以直接测试的，给定什么输入，会有什么输出都会心中有数，外部将这些部分组合起来，功能就实现了。
*** 展示型的组件是一种死的组件，它像是一个纯函数，给定什么输入，就会有什么输出。
*** IMPORTANT 统一数据获取、统一loading展示、统一错误处理、统一focus处理、统一页面跳转、统一测试用例等等。为什么要这样呢？因为只有统一了才会有优化空间，才能实现一改全改，才能实现像换就换，才能实现hook处理。
*** 无交互的纯渲染组件、有状态有交互的智能控件
*** TODO 测试中有个层次问题，应该从哪个层次去测试组件呢？
** 2017/10/19
*** 减少props传入，只传源数据，不传关联数据。只有这样才能尽量避免因为源数据与关联数据不一致导致的错误。
*** vue组件如何处理loading状态？
*** 组件就像一个函数，props就是函数参数，应该尽量保持函数参数的简洁与清晰。
*** 写测试用例到底有什么意义？需求做完后去补确实意义很有限。它真正的意义在于开发前去写，它能指导开发，让开发者站在用户的角度去审视一个组件怎样才能易于使用，应该传什么东西，得到什么，这样做出来的东西接口就会比较清晰，耦合也比较小。
*** TODO 其实vuex中充满着一个思想，消灭this，使用函数参数。比如mutation、action。为什么这样呢？这样能把函数依赖清晰的表示出来，避免模块内依赖，进而大大方便测试。虽然这样有时候会损失方便性。
*** IMPORTANT 回头看vue/vuex的设计，实际上它测试之初就很好的考虑到了可测试性，可测试性的关键是解除依赖，使得所有的代码都能像工具函数一样，只要给定输入，就能得到输出，不需考虑其他问题，要做到这一点需要有函数式编程的思想，但又要兼顾当前程序员的书写习惯，在两者间取得一个平衡。vue的答案就是参数化依赖，不要使用全局变量（this实际上是类函数间的全局变量，甚至IO也是一种全局变量），把所有的依赖都用参数显示的表达出来，这样测试就会非常好写。甚至可以说，vue/vuex（特别是vuex）之所以这样设计很大程度上是为了便于测试。
*** 关于vuex的测试，主要有getters、mutations与actions的测试，由于actions、mutations是同步的，而且将所有的依赖参数化了，测试起来非常好测，直接用指定的参数调用就好了。测试action会稍微麻烦些，由于action会调用外部api，需要使用mock处理下，然后就可以测试了。
** 2017/10/20
*** vue有了vuex后为什么还是需要data呢？是为了存储一些临时性的数据，比如input框的输入，只有点击了确定以后这个输入才会被传递到vuex，在之前存在data里就好了。
*** vuex的computed是用来设置当一个数据发生变化的时候更新组件数据的，它的源数据可以来自于data，也可以来自于外部，这点要格外注意，这样就会造成一个问题，一个组件的输入除了props以外，还有个computed。
*** 有个编程技巧，如果一个函数在调用前必须先调用下另一个函数，这种设计多数情况下不是一个好的设计，因为函数调用间存在依赖了，这种情况下有个技巧：
#+BEGIN_SRC javascirpt
	fn2(){
	  if(!fn1Called){
	     fn1();
	  }

	  // fn2 logic
	  // ...
	}
#+END_SRC
	这样直接将fn1给隐藏起来，用户只需要调用fn2就自动完成了fn1调用，使用起来就简单多了。
*** 关于vue与vuex的输入与输出：
    1. vue：
	   1) 输入有两个————props与computed
	   2) 输出也有两个————methods与watch
	2. vuex:
	   1) 输入有两个————mutation与action
	   2) 输出有两个————state与getters
	3. 这两者的输入与输出正好是相反的，vue的输入一般与vuex的输出放在一起，vuex的输出一般与vue的输入放在一起，这样协同配合，共同完成业务需求。
*** 在vue中，我们可以在组件实例上直接访问computed/methods，如果是data，需要加上个$data前缀。
*** 写测试用例实际上对开发者要求还是比较高的，它要求开发者能够把系统拆成很散的一块块，去除多余的依赖，然后写测试用例，这需要开发者多系统的结构非常清晰，能够很快搭建起一个简单的测试环境。
*** es6的导出函数写法似乎专门是为导出函数准备的，它使得我们能够以非常简单的语法轻松导出多个函数，这样我们能非常方便的对单个函数进行测试。
*** 异步事件必须要有个通知机制来告诉上层事件完成了，promise就是这种机制，但是promise需要程序编写者的支持，否则你是不可能知道一个异步事件结束的。
** 2017/10/21
*** store dispatch action、action commit mutation、mutation change state.
*** 使用vue/vuex要注意，多数时候UI产生的数据还需要经过一定的处理再传递到vuex，这个时候直接把这个数据封装逻辑写在UI上是不合适的，更好的方式是UI调用自己的method，然后在method里面封装数据，最后在调用vuex的method将数据提交到vuex。除了在自己的method里面封装数据外，还有个封装数据的地方，通过vuex的action，
