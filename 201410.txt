* 2014/10
** 2014/10/01
*** 疯狂的IT业界市场，很多不符合常理的事情都会发生。比如赔钱都要做；雇佣水军黑对手，无论对方如何回击都是输。
*** DONE 何为灵感？首先要明白，灵感不是凭空想出来的，是建立在前人的创造基础上的。首先要大量观察别人的创造，然后对这些东西中的某个方面进行深挖。灵感只是在别人的创造物的基础上对某一个角度的深挖。艺术本来就是利用自己的见闻创造出一个虚拟的环境，然后刻意突出自己想要表现的部分，但其实有时候很多被刻意忽略掉的细节的价值甚至比主要的更加重要，要多问问自己这个地方如果更过激一点能碰撞出怎样的火花，这样多锻炼下去创造力就出来了，这都是可以训练的。
** 2014/10/03
*** 实际上exe就是导出main的dll。使用EXE与使用DLL来进行程序拓展的区别仅仅就在于后者有可以自由定义的导出函数格式而已。
** 2014/10/08
*** 不同解决方案，不同软件层次，不同程序之间要想通信，就必须进行对接，使用公共的接口定义才能互相识别对方从而通信。
*** 在Debug状态下，使用Alt+6可以查看内存，使用Alt+8可以查看当前程序的汇编代码，这两种都是非常常用的窗口，非常有利于错误状态下的排错。
*** 写lisp程序时，切忌代码层次不能太多，也就是括号嵌套的层次不能太多，一旦多了以后代码的可读性会大大下降。虽然lisp代码的层次允许太多，但不应该依赖于这一点。
*** lisp是一种非常适合于培养树形思维的语言。
** 2014/10/11
*** c++的模板实际上是一种将类型检查由编译期推迟到运行期，从而实现动态类型的技术。利用这一特性，c++摇身一变，拥有了动态类型的能力。
*** QProcess类通常是被用来启动外部程序，并与它们进行通信的。QProcess是把外部进程看成是一个有序的I/O设备，因此可通过write（）函数实现对进程标准输入的写操作，通过read（），readLine（）和getChar（）函数实现对标准输出的读操作。
*** 概括地说,计算机语言的发展正是一个从HOW型低级语言向WHAT型高级语言进化的过程.在HOW型语言中,程序编制者必须详细说明运算是怎样(HOW)一步一步进行的;而在WHAT型语言中,程序编制者只需简单说明要做的事情是什么(WHAT) 。 …现代的LISP语言是这些语言的佼佼者,因为采用Common Lisp格式的Lisp具有非凡的表现力,但是如何做某件事情仍然是有待于Lisp程序编制者来表达的东西.相反,Prolog是一种明显地冲破了HOW型语言陈规的语言, 它鼓励程序编制者去描述情况和问题,而不是那些用来解决问题的详细步骤。”一般来说,LISP可以称为人工智能的汇编语言, Prolog是人工智能更高级的语言。
*** 在用vs写程序时，点击程序右上角的关闭按钮结束程序与直接使用vs的结束调试按钮结束程序是不一样的，前者会正确的调用程序对象的析构函数再释放内存，而后者是直接除暴地释放内存，不析构，所以有时会导致程序状态得不到保存。
*** ruby最大的特点在于完全面向对象以及代码块，借助这两大核心工具，它结合了面向对象的灵活与表处理的运算能力，这两点一起造就了一门非常强大实用的语言。
*** 任何编程语言从本质上讲都是图灵等价的，可以用来解决任何问题。所不同的只是解决一个问题的难易程度，特定的语言由于所主要关注的地方，抽象点不同，导致解决同一问题的复杂度大不一样。比如java虽然也有反射能力，但使用起来非常不优雅，远远不如ruby灵活，所以要求强大的反射能力用java就不合适了。语言与语言之间的差异，莫不如是。面对特定的问题，选择最适合于解决这一问题的语言才是正确的选择。
*** 不同语言设计思路与优缺点：
1） c：结构式的程序设计语言，规范化了程序的各种基本组成元素：数据与代码，各种控制结构。从而实现了强大的控制调试能力，但也因为这种规范化，大大限制了这种语言的灵活性，不适用于解决非常灵活的问题。
2） lisp：lisp语言的核心实际上是数学，它非常接近于数学解决问题的思想，适合于用来做演算。
3） java：一门纯粹的面向对象语言，除去对象以外基本不掺杂其它花哨的语言特性，这种强制粗暴的规则非常适合于团队开发，但同时也限制了程序的灵活性。
4） ruby：一门在对象的基础上赋予对象很强数学演算能力的语言，相当于在java的基础上加入了lisp强大的运算能力，这种相加虽然给予了对象强大的运算能力，但也给程序的并发带来了很大的困难。
** 2014/10/13
*** 实际上编程语言追求的是以一种最简洁清晰的方式来描述和解决问题。设计语言可以从其他语言借鉴出一些思想，借以指导自己的思路，但不能强行杂糅到自己的系统里面。编程语言实际上才是建立在计算机硬件基础上的第一层抽象，再往上才是操作系统。
*** 治大国如烹小鲜，只有抱着这样的想法才能做好事情。把任何事情当玩具。
*** 不做屠夫，便为羔羊。
** 2014/10/14
*** 只要有通信，就不可避免地需要通信协议。
*** list的add-to-list函数的功能实际上很简单，它跟push基本上一样，都是添加一个元素到一个list顶部，并没有什么神秘的地方。
*** 既然不与别人接触有时会让我感到郁闷，接触会让我感到快乐，我为什么不多接触一下别人呢。则是一笔稳赚不赔的买卖。我绝对达不到那种说话太多得罪人的地步。
*** 为什么emacs的拓展性如此强大，因为它首先实现出了一种动态脚本语言，并用这种语言写出了这个系统。由于是脚本语言，因而内置了解析器，不需要额外编译；由于是动态语言，因而可以在运行时修改程序的结构。由于是用这门语言实现的系统，因而可以最大化地暴露出程序接口。它暴露出了全套的环境（函数与变量，数据与代码）与规则（解释器），使得用户可以基于这些规则重新去构建自己的世界，因而拥有了令所有软件艳羡的拓展能力。它根本就是一门语言的ide。由于是一门语言，因而无所不能。它能被称为神的编辑器而其他的ide不能是因为它不仅仅是一个ide，还是最轻量级的ide，拥有媲美其他编辑器的能力。编辑器与编程语言的结合成就了这个如此强大的编辑器。也就是说，想要拓展性强，就得内置一门语言，其实vs也内置了javascript作为其配置语言的。
*** 随着软件的更新频率越来越高以及网络的越来越发达，在个人电脑上保存安装包变得越来越没有必要，未来很可能人们不会在自己电脑上存放软件安装包了，要么是直接用浏览器调用远程的程序，要么是直接通过网络安装某些必要的软件。视频影音也一样，随着清晰度越来越高，再也不用将这些保存在个人电脑上了。未来人们可能只需要一份清单，记录自己需要哪些软件，哪些影片，除此之外就是个人的照片，视频，通讯录等这些信息了。更广泛的共享使得信息的冗余度大大降低了，超大容量的存储在个人领域上将变得不再重要。
*** 最近数据的多端同步非常火，几乎每个人都或多或少的要用到云盘。其实真正要一起同步的不仅仅是数据，还有程序，甚至网页。也就是说，真正需要同步的其实是一个环境，有了这个环境，在任何终端上都能获得一致的体验，这样就大大减少了用户的学习和记忆负担，可以将精力放在其他更需要解决的事情上。
*** 其实随着人们的磁卡越来越多，这些磁卡会给人们带来非常大的携带负担，迫切需要一种同一的管理方案来管理这些磁卡，一棒子打死这些磁卡不大现实，需要一种对所有类型的卡都能接受的中间解决方案，渐渐的再发展到一卡走天下。现在可以考虑的中间解决方案是在一张卡上集成多张卡的芯片，再渐渐根据这些芯片各自的特新将某几种芯片融合，渐渐发展就能弄到一个芯片上了，微型化了以后甚至都不会是一张卡了，而是一块很小的可植入芯片，这就是可穿戴设备。
*** 其实这个社会所需要的并不是最聪明的人，而是最懂得思考生活的人，如何以一种最简单的方式来简化我们的生活，使得生活变得非常简单，这才是正确的道路。并不是会解决矩阵运算，图像算法等这些问题才是最牛的人。
** 2014/10/15
*** 随着云端化的趋势越来越明显，未来很可能需要这样的程序——真正直接跨平台的程序，不需要经过重新编译，真正直接将程序文件拷贝到不同平台，点击就能直接运行，这才是真正的跨平台。windows目前好像就在做这个事，我们并不需要一堆操作系统，一个操作系统就可以在各种设备上运行了。
*** 要想打通所有设备，需要从以下几个方面来做——使用云盘打通存储，使用跨平台的通用可执行文件格式打通平台。这样就能实现全平台环境共享。
*** 何为搜索？搜索实际上只是一个数据库查询而已。先对所有的数据进行检索形成数据库，然后当用户搜索时从数据库中检索出所需要的数据显示在网页上，这就是搜索。这样说起来其实百度也是一个做数据的公司。
*** 网页实际上是一种文件显示的方式，不同于传统的文件夹显示方式，使用网页给了用户一个基于网页的文本文件来对文件的显示方式进行拓展的机会，用户完全可以通过自己定义的标签以及基于此标签的程序来对显示哪些数据，怎样显示进行自己的自定义，从而使得文件显示的可拓展性，可定制性大大提升了。
*** 其实不管是什么软件公司从本质上将都是是数据公司，他们都有自己内部统一的数据存储格式，都有自己海量的数据，他们所做的事只是根据不同的业务需求，选择所需要的数据以特定的方式来将这些数据显示出来供人们使用而已。任何公司都需要做数据以及数据的显示，然后这中间有个非常重要的过程——搜索。任何公司当数据量上去的时候都无法回避这个问题。
*** 实际上数据的存储形式只有一维存储与多维存储这两种。一维存储包括传统的数组，链表，甚至还有哈希表。多维存储基本指树形存储。由于一维存储不便于对数据进行分类管理。所以现在多数重要的场合都是采用的树形存储的结构，比如操作系统的文件系统，网页，很多数据库，还有程序代码解析后等都是采用的树形结构进行存储的。
*** 既然树形结构如此普遍，那么对树形的遍历就成了一个非常重要的问题。其实树形结构的遍历只有深度优先与广度优先两种。
    首先说明一个问题，树形结构数据的两种基本组层要素——数据以及链接。数据是具体存储的数据，链接指向其他的数据。正式这两种基本的元素组成了树这种结构。
    回到深度优先与广度优先的话题。深度优先是碰到数据链接先去搜索链接到的数据，广度优先是碰到数据链接先忽略，先把本节点的数据搜索完毕，再去搜索链接的数据的过程。这样的结构是前者便于搜索位于树下方的数据，后者便于搜索树上方的数据。

** 2014/10/20
*** 做一个东西的成本很多时候最大的决定因素是这件东西的精细程度，而不是大小。精细程度决定了复杂度，也就是所需要的人力成本，进而决定了最终的成本。典型的例子就是手机。当然，通过成熟的制作工艺以及生产规模能够降低精细程度，进而降低成本。
*** 传统的控制台程序使用main参数来传递程序所需要的参数信息，这种方式在参数比较少的时候还比较有效，能够简单方便地处理一些小问题。但这种方式不能保存程序的运行状态，当情况复杂时，就需要传递大量的参数信息，导致参数冗长，难记难用。在这种情况下，使用REPL将程序写成交互式的就非常有必要了，这种方式就能够保存程序的运行状态，不需要每次调用某个部分的一个小功能就传递一大堆状态信息给程序了，从而大大减轻了用户的学习与使用负担。
*** 最简单的控制台程序直接用控制台参数就可以完成任务了，如果情况变得复杂，就需要使用REPL交互式的控制台程序了，如果再复杂，甚至连用来交互的语法也需要留心定义，在这种情况下，程序就上升到了DSL语言高度了，再复杂，这门语言就是通用的交互式的语言了，Lisp，Python,Ruby，Io都属于此类。
*** 设计模式到底是什么？是一种类的组织方式？这样想就大错特错了。设计模式是面对特定的问题所采用的一种解决方案，是一种设计的方法与思路。它是用来解决问题的，并不仅仅是用来规划类的，还可以用来设计语言，设计程序结构等。比如Io语言。设计模式也远不止常见的那23种，还有很多其他的，比如REPL就是一种设计模式。关于这个词的误解实际上是来自这个词语的误用。
*** REPL是一种简化交互的模式。它通过提供一个环境达到简化交互的效果。大环境，小交互是此模式的核心。现实生活中的很多东西实际上都是这样，通过上下文提供一个环境，其中的人就可以用很简单的方式进行交互，因此这一模式具有特别大的意义，要多加利用。
*** c++与c相比，增强了语言的很多方面，具体表现在以下几点：
1） 使用新的IO流系统，使得不管对于文件流，字符串留，甚至是对象流都能有统一的输入输出形式。
2） STL区分了数据以及算法，使得他们能够分别变化。
3） 泛型的引入增强了c的动态能力。
4） 允许类实现运算符，这样就使得类能够表达出对某个操作符的具体行为。
5） 命名空间的引入限制了变量的作用域，避免命名冲突。
*** 提供一个虚拟化的文件索引解决方案，再一次扩大你的硬盘容量，从此存储不用受容量限制。一个指向网络资源的快捷方式，由专人来帮你负责维护链接的有效性。
*** 技术前进的方向我们无法预测，但有一点是肯定的，技术应该是让我们的生活变得简单，这个大方向绝对错不了。技术的发展使得我们要做的事越来越多，比如以前我们根本不用关心一大堆银行卡怎么管理，一大堆账号密码如何记住，还有租房，甚至购物，这些东西都远比以前要复杂得多。但技术同时也在不断地简化着我们的生活，如网上购票，租车，支付宝等。这本身就是一种博弈，我们提出方法想要简化生活，但同时这些大堆的方法又在复杂我们的生活，我们所能做的只是尽量然简化的部分大于复杂的部分而已。
*** 未来人们的生活肯定会越来越简单，与此同时，劳动的成本将会变得越来越高，也许你只是请别人做一点点事，但你必须付出很高的报酬才会有人去帮你做这件事。之所以以前银行转账需要收受那么高的利息但现在借助于余额宝却可以实现0利息是以为现在完成转账这件事所需要付出的人力成本比以前大大降低了。
** 2014/10/21
*** qmake是构建前一步的步骤，作用是基于pro工程文件生成makefile文件，构建是基于这个makefile文件的。所以每次改动pro工程文件以后都必须先qmake一次，然后再构建才能生效。
*** 基于虚拟化的文件索引解决方案，首先实现自己的数据上云，使用云盘将自己的文件上云。
*** 如何将软件服务化？服务化首先是要将界面与逻辑分离，也就是分成server与client，然后将server与client分别放到不同的机器上，通过服务器来进行两者之间的通信，当然，详细的通信接口还需要server与client进行协商，服务器只能负责如何传数据，但这个数据的请求格式以及返回格式是需要server端与client端进行协商的。这样将一个程序分成了两个部分，当程序多的时候就会出现很多的server与client，需要一个统一的平台来统一管理这些软件。server端的管理很好理解，就是http服务器的事。client端管理也需要一个平台，这个比较少被人提及，典型的例子是微信公众号，各种平台的语音输入引擎，微软小冰，甚至我自己调用程序所采用的link快捷方式，浏览器其实也是也是其中的例子。client,server，服务器，管理平台，这四者共同实现了软件服务化。
*** 伴随着软件的服务化，编写软件所需要做的工作会越来越向着桌面端软件靠拢，互联网软件的重要性将大大降低。实现软件的功能将越来越重要，而所使用的语言将不再重要，只要实现功能就行。在这种情况下，像c++这种语言由于擅长与操作系统交互将变得越来越重要，脚本语言由于其强大的灵活性也将更加普及。
*** slime启动原理——slime有一个自己的服务器swank,这个服务器会调用lisp的解析器。它是通过建立一个从emacs到这个服务器之间的socket连接，然后通过服务器来与解释器进行通信的，典型的云架构。
*** lisp语言整体本身就是一个基于lisp核心的程序环境。在任何时候你都可以向这个环境中加入新的全局变量，函数，程序，然后你可以随时在任意一个buffer中检索，添加，删除，修改到这些东西。这种强大的灵活性使得这个环境非常容易扩充，新的环境直接跟原来的环境是一体的，根本就不存在程序与程序之间的隔阂与通信问题。
*** 程序环境是一个非常重要的东西，包括常见的环境变量，还有比较少见的环境函数。程序环境是一个程序与程序之间进行通信的极好的传输媒介，这个环境中的所有信息将被所有此环境中的程序共享，任何一个程序都可以随意修改这个环境并被环境中的其他程序感知。这一特性是只有操作系统才有的特性啊！lisp正是因为有了这一特点才被人称作为可以扩展出一个操作系统。
*** 正是基于程序环境这一牛逼的特性，lisp支持热升级，不需要重启软件就可以扩充软件的功能。因为对于lisp而言，扩充软件的功能就相当于在操作系统上装了一个软件，哪见过给操作系统安装软件还需要重启系统的（驱动一类系统紧密相关的软件除外）。
** 2014/10/23
*** 面向对象的要点不在于代码的书写形式，而在于所谓的封装与多态性的概念。
** 2014/10/24
*** 全局变量并不是洪水猛兽，我们经常说的环境变量实际上就是全局变量。所有的全局变量实际上共同构成了程序的运行环境，就是它使得在运行期动态的添加删除修改函数与变量成为了可能。lisp的实现必定是加入了一堆环境变量。它的坏处之所以经常被夸大是因为老版本的c++实现里面没有命名空间这个东西，导致经常重名。自从有了全局变量，这个坏处就不存在了。当然，全局变量确实会破坏模块化与封装，使得代码的维护变得困难。但实现一个可修改的程序环境所带来的好处是远远大于这一缺陷的。至于代码的可维护性，定义良好的全局变量实际上是很好维护的，不存在维护困难问题。
** 2014/10/27
*** 尽量减少需求变化时所需要改动代码的位置数目，这其实才是编程最基本的原则。我们一直在与可拓展性，可维护性（这两个词其实基本等价）作斗争，不管是面向对象也好，面向函数也好，其本质都是寻求一种有效的方式来组织和分类代码，来提高这两种性质。那么，如何评估一份代码这两种特性好不好呢？其实最简单的方法是看每当需求变化时，你到底需要改动多少地方就行了。如果你需要改动的地方很少，那么代码的可维护性与可拓展性就必然很高。当你面对一个业务需求，你首先应该分析哪些地方是易变的，哪些是不变的，并把这两部分分离开来，并尽量通过自己的抽象，使得易变的变为不变的，这才是根本途径。面向过程与面向函数等这些只是给你提供了一种思路可以这样来抽象，万变不离其宗，只要通过你的抽象，将易变的与不变的分离了出来，使用哪种方法是无所谓的。
*** c++里面什么是基本数据类型，什么是对象这个得分清。基本数据类型之间互转是不需要构造函数的，这是由编译器实现的。但基本数据类型转换为对象或者一种对象转化为其他类型的对象是需要构造函数的，如果没有构造函数，即使使用强制类型转换也是无法成功的。要特别注意，指针也是基本数据类型，指针是不能转换为函数对象的。
*** C++里面的数据类型分为基本数据类型与对象，基本数据类型并不是对象，所以说，c++不是一门纯的面向对象的语言。这一点很重要，不是纯对象的意味着很多时候你需要分清楚是哪种类型，因为类型不同性质也是大不相同的。
** 2014/10/29
*** 在源文件中定义全局变量，再在相应的头文件中extern这个变量。这样就对外界开放了这个全局变量，外界只要include这个头文件就可以使用这个变量，避免了在外界extern一个可能不知道的变量的尴尬。
*** 使用命名空间包住全局变量，再马上在下面using这个命名空间，可以避免全局变量跟其他源文件里面的全局变量产生命名冲突而又不不需要改动下面的代码（不需要加上”XXX::“这样的前缀）。
*** namespace有一个很重要的特性就是它是可以复用的，你可以用同一个namespace在一个文件里面添加对象a，然后在另一个地方再给这个namespace添加对象b却不需要知道对象a的存在。编译器会自动根据namespace的名字来对变量与函数进行分组。
*** 一个函数里面一旦使用到了全局变量，那么这个函数的可重用性就基本丧失了。但是要清楚，很多代码是根本不需要可重用性的。如果在这种函数中某些代码确实需要可重用性，比较好的办法是将这部分代码单独写在其他的函数，最好直接写在其他的文件里面。
*** 两个类之间要想通信却又想完全解耦怎么办？通过第三个类？不，这样不好。比如类A与类B通信，但后来变成了类A与类C通信，就需要更改这第三个类，确实如果再加上继承就不需要改了，但这样一来复杂度就大大上升了。其实比较简单的方法是根本不需要第三方类，就直接在一个类中约定好另一个类中必须有哪些方法，然后利用成员函数模板就可以调用另一个类中的属性与方法了。这样即使这个类需要换成其他类，只要这个类里面有模板函数里面使用到的那几个属性与方法，就可以通信，实现了调用与被调用者的解耦。
*** 模板，不管是模板函数还是模板类，其声明定义与调用必须在一个文件里面。常见的做法就是声明与定义都放在头文件里面，然后再在需要使用这个模板的地方include这个文件。不能像普通的函数那样，声明跟定义分开写。
*** main函数所在的文件就像是一块试验田，在这里面的代码是可以随意修改实验的，就是所谓的用户使用者的代码。而其他已经写好的代码就不要随便动了。最好的情况是当需求变化或有新需求时，只需要自己重新写点代码添加进实验代码中程序就可以正常跑了。一旦需要改动自己以前写的代码，就可以认为这是代码编写者的一次失败。
*** 如果你只用到一个命名空间的话那么“using namespace xxx;”这样是合适的，但如果你用到了几个命名空间，再这样使用就不大好了。一样会导致这几个命名空间相互污染。
** 2014/10/31
*** 关于图层的实现，有两种思路。
1） 每一层使用一个容器，然后每绘制一个对象就将这个对象添加到这个容器里面去。
2） 对每个对象使用一个所属图层的编号，编号相同的对象就属于同一层级。
*** 类似的东西有两个就可能有多个，就需要使用一个统一的管理中心来应对这种变化。
*** 使用dll的动态加载机制，在程序运行时加载dll并注册给命令中心，可以实现在程序运行时动态地向程序添加函数牛逼特性，使得程序像一个动态语言一样。这样可以实现将dll中的函数动态添加进程序。如果更近一步，将c++的编译器也集成进系统，甚至可以更牛逼一点，直接将用c++写的函数添加进系统。