* 2017/01
** 2017/01/03
*** TIPS html实际上与XML、JSON一样，是一种数据结构，而且是一种可以自定义的数据结构，非常灵活强大。
*** angular的controller由两部分组成，一部分是dom树，又叫做模板template;另一部分是scope代码。这两个部分缺一不可。
*** 在angular中，我们可以先只注册一个controller但是并不展现出来，只在需要的时候再展示，至于具体的展示方法有好几种，一种是通过ng-show，这种是最差的；第二种是通过ui-router；还有一种是通过uib-modal。后面这两种方法就相对来说好些了。
*** angularjs确实有很多含混不清的多余概念，学习成本居高不下。
*** 如果把数据的管理与存储放在后端，由于与前端数据呈现距离变远了，那么通信成本就会升高。如果后端维护所有数据，那么随便修改一点什么东西，就需要后端重新返回所有数据，这显然会极大浪费带宽，造成卡顿。
*** TODO 正则表达式模式与模式之间的连接问题
*** 正则表达式是一个字符一个字符判断的语法，从前往后一个个进行写。
*** TODO 进的时候检查OR出的时候检查？展示的时候校验OR提交的时候校验？
*** html的form标签是html为了解决表单验证这个问题所专门设计的标签，它相对于传统的div具有以下优势：
	1. 语义化。一看到form标签开发者就能直接知道这是个表单，比div+class的方案显然可读性要更好。
	2. 支持表单验证。我们可以直接在form的表单元素上直接写上一些验证信息，比如必填非必填、标签的正则模式等，在表单提交前自定义一些验证信息，避免手写js，提高开发效率。
*** TODO 研究下HTML的表单及其验证。表单验证是一个水非常深的活。
** 2017/01/04
*** IMPORTANT 如何遍历一个集合中的所有排列与组合?
我们首先考虑两元排列组合问题。
	1. 首先是排列算法，排列算法只需要两层遍历，然后过滤到自己与自己就可以了，算法如下：
function arrange(collection){
  for(let i = 0;i < collection.length;++i){
    for(let j = 0;j < collection.length;++j){
      if(i === j){
        continue;
      }
      let item1 = collection[i];
      let item2 = collection[j];
      console.log(item1,item2);
    }
  }
}

//arrange([1,2,3,4]);
    2. 然后是组合算法，组合算法也是两层遍历，然后过滤掉自己以及自己前面的元素就可以了，算法如下：
function combination(collection){
  for(let i = 0;i < collection.length;++i){
    for(let j = i + 1;j < collection.length;++j){
      let item1 = collection[i];
      let item2 = collection[j];

      console.log(item1,item2);
    }
  }
}

//combination([1,2,3,4]);
再推广到多元，
其实还是一样的道理。
   1. 首先还是排列问题，n元排列需要经过n层遍历，然后过滤掉这n个元素之间两两相等的情况，比如对于三元的，算法如下：
function arrange(collection) {
    for (let i = 0; i < collection.length; ++i) {
        for (let j = 0; j < collection.length; ++j) {
            for(let k = 0; k < collection.length;++k){
                if (i !== j && j !== k && i !== k) {
                    let item1 = collection[i];
                    let item2 = collection[j];
                    let item3 = collection[k];
                    console.log(item1, item2, item3);
                }
            }
        }
    }
}

//arrange([1, 2, 3, 4]);
    2. 然后是组合问题，n元组合需要经过n层遍历，然后过滤掉自己以及自己前面的，也就是i,j,k依次递增，算法如下：
function combination(collection) {
    for (let i = 0; i < collection.length; ++i) {
        for (let j = i + 1; j < collection.length; ++j) {
            for (let k = j + 1; k < collection.length; ++k){
                let item1 = collection[i];
                let item2 = collection[j];
                let item3 = collection[k];
                console.log(item1, item2, item3);
            }
        }
    }
}

//combination([1, 2, 3, 4]);
*** TIPS 重新思考多数组求交问题。多数组求交实际上除了将所有剩余数组与第一个数组求交以外，还有种算法就是两两组合求交，实际上就变成了一个组合问题了。
*** git的revert只是恢复成本地最后一个版本，并不是恢复成服务器的最后一个版本，想要恢复成服务器版本还需要pull一下。
*** TIPS ES6的解构赋值本质上是一个一对多的转化，能够从一个数据集中一次抽出多个信息赋值给变量，弥补了js一次只能从一个数据集中提取一个数据的缺陷。
*** substr与stbstring区别只在于它们的参数不一样，他们都不会改变原数组，只会生成一个新的数组。
*** form/from、model/modal、date/data...无语了！！！
** 2017/01/05
*** 事件最大的问题在于对调试的伤害，一旦使用了事件，调试起来就会非常费劲，但其实也没有那么麻烦，事件调试的关键在于找到事件处理数组所在的地方，然后一个元素一个元素的去跟就行了。
*** js中，多个变量名指向同一个对象时，你将任意一个或几个变量置为空，其他变量的值都不会改变。但是如果你通过任意一个变量改变了它指向的对象，那么所有变量的值都会跟着一起变。
*** 数组实际上也可以看成一个面，一个一维的面，一些面的性质实际上也可以用在数组上。
*** 使用overflow需要注意，需要先在父容器上设置宽度与高度，然后当子元素移除父元素时overflow才回起作用。
*** IMPORTANT 前后端应该怎样正确的交互数据呢？应该尽可能的控制交互的数据量，不管是发到后端的数据还是后端返回的数据都应当尽量小。绝对不能随便改点东西就全量的将数据返回，虽然这样前期会比较方便，但是后期会让系统卡顿不堪。前端应该有自己的数据管理，当修改发生时，只需要传输所修改的那一丁点数据，后端也应该只返回自己修改的那一点数据，前端需要将新数据合并进老数据并展示，这样就能以最小的宽带损耗完成交互，获得最好的用户体验。
*** DONE 表单验证的原理无非是监听控件的input事件，在用户输入或删除的过程中不断进行值有效性的判断，如果失败，就在附近提示出来。
** 2017/01/06
*** TODO 如何解决组合真假判断问题，所有的正确才是正确，只要有一个错误，就算错误。
*** TODO 数学也是一种语言，它与编程语言实际上是可以相互转化的。探索数学语言与编程语言中间的对应关系，在编程问题于编程问题之间互相转换。
	要解决这个问题，首先需要思考加法与乘法。加法与乘法的编程表示。初步的认识是乘法是for循环嵌套，加法是什么呢？
*** IMPORTANT 数学归纳法原本只是数学中的概念，但被拿到编程中来却异常好用。很多编程问题只要能够写出递推公司，那么多半可以使用递归来编程实现。原因在于它并不只是一个递推公式，它是一种思想。用来大事化小、小事化了的思想，而思想是不分领域的。
*** IMPORTANT 递归的过程中，往往有很多中间状态需要存储，这个时候，增加一个额外的参数常常是非常好的做法，通过这个参数，我们可以在开始传入一个初始状态，然后在递归进行的过程中不断更新它，直到递归结束。
*** 函数实际上是一个容器，可以携带参数的容器。
*** C语言的思维实际上是副作用式的思维，每当我们需要一个什么东西的时候，我们首先需要创建一个容器来装结果，然后对问题集进行穷举遍历，将符合条件的元素放到结果集中，然后就得到了结果，这就是用C语言写算法的思维。
** 2017/01/09
*** IMPORTANT 使用递归算法解决问题非常重要的一点就是我们需要将大递归与小递归结合起来，需要对小递归的返回值进行处理并返回。
*** angularjs的表达式与原生javascript最大的不同在于它支持过滤器，用来解决展示逻辑的问题。
** 2017/01/10
*** 不要直接使用GET/POST，多数情况下，使用封装下的GET/POST，先对请求以及返回做个基础的数据校验是非常有必要的。
*** 开放API与内部API不同的地方在于开放API并不会将内部的数据展现给你，它的处理逻辑是
	接受请求 --> 获取数据 --> 展现数据
	它多做了一步————展现数据，这样你就直接得到处理的结果了，虽然简化了操作，但是却丧失了修改数据的灵活性。
*** 指数级算法————循环加递归。
*** 单例模式有个需要格外注意的问题————资源释放，由于单例对象不会被释放，该对象上持有的子对象上的资源是并不会随着离开页面跳转释放掉的，你可以不管大单例对象上的资源，但有些子资源你还是得自己维护的。
*** TIPS 在chrome中，我们想要查看某个元素下绑定的所有事件有个简单的方法，定位到该元素下，然后查看Event Linstener TAB页，所有绑定在该元素下的事件，不管是通过onXXX还是addEventLinsenter添加的事件你都能很清楚的看到了。
