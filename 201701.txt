* 2017/01
** 2017/01/03
*** TIPS html实际上与XML、JSON一样，是一种数据结构，而且是一种可以自定义的数据结构，非常灵活强大。
*** angular的controller由两部分组成，一部分是dom树，又叫做模板template;另一部分是scope代码。这两个部分缺一不可。
*** 在angular中，我们可以先只注册一个controller但是并不展现出来，只在需要的时候再展示，至于具体的展示方法有好几种，一种是通过ng-show，这种是最差的；第二种是通过ui-router；还有一种是通过uib-modal。后面这两种方法就相对来说好些了。
*** angularjs确实有很多含混不清的多余概念，学习成本居高不下。
*** 如果把数据的管理与存储放在后端，由于与前端数据呈现距离变远了，那么通信成本就会升高。如果后端维护所有数据，那么随便修改一点什么东西，就需要后端重新返回所有数据，这显然会极大浪费带宽，造成卡顿。
*** TODO 正则表达式模式与模式之间的连接问题
*** 正则表达式是一个字符一个字符判断的语法，从前往后一个个进行写。
*** TODO 进的时候检查OR出的时候检查？展示的时候校验OR提交的时候校验？
*** html的form标签是html为了解决表单验证这个问题所专门设计的标签，它相对于传统的div具有以下优势：
	1. 语义化。一看到form标签开发者就能直接知道这是个表单，比div+class的方案显然可读性要更好。
	2. 支持表单验证。我们可以直接在form的表单元素上直接写上一些验证信息，比如必填非必填、标签的正则模式等，在表单提交前自定义一些验证信息，避免手写js，提高开发效率。
*** TODO 研究下HTML的表单及其验证。表单验证是一个水非常深的活。
** 2017/01/04
*** IMPORTANT 如何遍历一个集合中的所有排列与组合?
我们首先考虑两元排列组合问题。
	1. 首先是排列算法，排列算法只需要两层遍历，然后过滤到自己与自己就可以了，算法如下：
function arrange(collection){
	for(let i = 0;i < collection.length;++i){
		for(let j = 0;j < collection.length;++j){
			if(i === j){
				continue;
			}
			let item1 = collection[i];
			let item2 = collection[j];
			console.log(item1,item2);
		}
	}
}

//arrange([1,2,3,4]);
    2. 然后是组合算法，组合算法也是两层遍历，然后过滤掉自己以及自己前面的元素就可以了，算法如下：
function combination(collection){
	for(let i = 0;i < collection.length;++i){
		for(let j = i + 1;j < collection.length;++j){
			let item1 = collection[i];
			let item2 = collection[j];

			console.log(item1,item2);
		}
	}
}

//combination([1,2,3,4]);
再推广到多元，
其实还是一样的道理。
   1. 首先还是排列问题，n元排列需要经过n层遍历，然后过滤掉这n个元素之间两两相等的情况，比如对于三元的，算法如下：
function arrange(collection) {
    for (let i = 0; i < collection.length; ++i) {
        for (let j = 0; j < collection.length; ++j) {
            for(let k = 0; k < collection.length;++k){
                if (i !== j && j !== k && i !== k) {
                    let item1 = collection[i];
                    let item2 = collection[j];
                    let item3 = collection[k];
                    console.log(item1, item2, item3);
                }
            }
        }
    }
}

//arrange([1, 2, 3, 4]);
    2. 然后是组合问题，n元组合需要经过n层遍历，然后过滤掉自己以及自己前面的，也就是i,j,k依次递增，算法如下：
function combination(collection) {
    for (let i = 0; i < collection.length; ++i) {
        for (let j = i + 1; j < collection.length; ++j) {
            for (let k = j + 1; k < collection.length; ++k){
                let item1 = collection[i];
                let item2 = collection[j];
                let item3 = collection[k];
                console.log(item1, item2, item3);
            }
        }
    }
}

//combination([1, 2, 3, 4]);
*** TIPS 重新思考多数组求交问题。多数组求交实际上除了将所有剩余数组与第一个数组求交以外，还有种算法就是两两组合求交，实际上就变成了一个组合问题了。
*** git的revert只是恢复成本地最后一个版本，并不是恢复成服务器的最后一个版本，想要恢复成服务器版本还需要pull一下。
*** TIPS ES6的解构赋值本质上是一个一对多的转化，能够从一个数据集中一次抽出多个信息赋值给变量，弥补了js一次只能从一个数据集中提取一个数据的缺陷。
*** substr与stbstring区别只在于它们的参数不一样，他们都不会改变原数组，只会生成一个新的数组。
*** form/from、model/modal、date/data...无语了！！！
** 2017/01/05
*** 事件最大的问题在于对调试的伤害，一旦使用了事件，调试起来就会非常费劲，但其实也没有那么麻烦，事件调试的关键在于找到事件处理数组所在的地方，然后一个元素一个元素的去跟就行了。
*** js中，多个变量名指向同一个对象时，你将任意一个或几个变量置为空，其他变量的值都不会改变。但是如果你通过任意一个变量改变了它指向的对象，那么所有变量的值都会跟着一起变。
*** 数组实际上也可以看成一个面，一个一维的面，一些面的性质实际上也可以用在数组上。
*** 使用overflow需要注意，需要先在父容器上设置宽度与高度，然后当子元素移除父元素时overflow才回起作用。
*** IMPORTANT 前后端应该怎样正确的交互数据呢？应该尽可能的控制交互的数据量，不管是发到后端的数据还是后端返回的数据都应当尽量小。绝对不能随便改点东西就全量的将数据返回，虽然这样前期会比较方便，但是后期会让系统卡顿不堪。前端应该有自己的数据管理，当修改发生时，只需要传输所修改的那一丁点数据，后端也应该只返回自己修改的那一点数据，前端需要将新数据合并进老数据并展示，这样就能以最小的宽带损耗完成交互，获得最好的用户体验。
*** DONE 表单验证的原理无非是监听控件的input事件，在用户输入或删除的过程中不断进行值有效性的判断，如果失败，就在附近提示出来。
** 2017/01/06
*** TODO 如何解决组合真假判断问题，所有的正确才是正确，只要有一个错误，就算错误。
*** TODO 数学也是一种语言，它与编程语言实际上是可以相互转化的。探索数学语言与编程语言中间的对应关系，在编程问题于编程问题之间互相转换。
	要解决这个问题，首先需要思考加法与乘法。加法与乘法的编程表示。初步的认识是乘法是for循环嵌套，加法是什么呢？
*** IMPORTANT 数学归纳法原本只是数学中的概念，但被拿到编程中来却异常好用。很多编程问题只要能够写出递推公司，那么多半可以使用递归来编程实现。原因在于它并不只是一个递推公式，它是一种思想。用来大事化小、小事化了的思想，而思想是不分领域的。
*** IMPORTANT 递归的过程中，往往有很多中间状态需要存储，这个时候，增加一个额外的参数常常是非常好的做法，通过这个参数，我们可以在开始传入一个初始状态，然后在递归进行的过程中不断更新它，直到递归结束。
*** 函数实际上是一个容器，可以携带参数的容器。
*** C语言的思维实际上是副作用式的思维，每当我们需要一个什么东西的时候，我们首先需要创建一个容器来装结果，然后对问题集进行穷举遍历，将符合条件的元素放到结果集中，然后就得到了结果，这就是用C语言写算法的思维。
** 2017/01/09
*** IMPORTANT 使用递归算法解决问题非常重要的一点就是我们需要将大递归与小递归结合起来，需要对小递归的返回值进行处理并返回。
*** angularjs的表达式与原生javascript最大的不同在于它支持过滤器，用来解决展示逻辑的问题。
** 2017/01/10
*** 不要直接使用GET/POST，多数情况下，使用封装下的GET/POST，先对请求以及返回做个基础的数据校验是非常有必要的。
*** 开放API与内部API不同的地方在于开放API并不会将内部的数据展现给你，它的处理逻辑是
	接受请求 --> 获取数据 --> 展现数据
	它多做了一步————展现数据，这样你就直接得到处理的结果了，虽然简化了操作，但是却丧失了修改数据的灵活性。
*** 指数级算法————循环加递归。
*** 单例模式有个需要格外注意的问题————资源释放，由于单例对象不会被释放，该对象上持有的子对象上的资源是并不会随着离开页面跳转释放掉的，你可以不管大单例对象上的资源，但有些子资源你还是得自己维护的。
*** TIPS 在chrome中，我们想要查看某个元素下绑定的所有事件有个简单的方法，定位到该元素下，然后查看Event Linstener TAB页，所有绑定在该元素下的事件，不管是通过onXXX还是addEventLinsenter添加的事件你都能很清楚的看到了。
** 2017/01/11
*** 编程语言中的或（也就是||）用在if条件中的时候，相当于把两个if分支中的语句合在一个分支，这在两个分支中的语句一样的时候是有用的，例如：
if(bCondA){
	//...someCode1
}
else if(bCondB){
	//...someCode1
}
else{
	//...someCode2
}
等价于
if(bCondA || bCondB){
	//...someCode1
}
else{
	//...someCode2
}
同理，编程语言中的且（也就是&&）用在if条件中的时候，相当于把两层if分支中的语句合成一个层，例如：
if(bCondA){
	if(bCondB){
		//...someCode1
	}
}
等价于
if(bCondA && bCondB){
	//...someCode1
}
注意前者是两个，后者是两层。
*** TIPS emacs的org-mode有个easy templates功能，允许我们快速插入模板代码，只需要我们输入<(template selector)然后按tab就行了，这个功能非常方便，比如：
s	#+BEGIN_SRC ... #+END_SRC 
e	#+BEGIN_EXAMPLE ... #+END_EXAMPLE
q	#+BEGIN_QUOTE ... #+END_QUOTE 
v	#+BEGIN_VERSE ... #+END_VERSE 
c	#+BEGIN_CENTER ... #+END_CENTER 
l	#+BEGIN_LaTeX ... #+END_LaTeX 
L	#+LaTeX: 
h	#+BEGIN_HTML ... #+END_HTML 
H	#+HTML: 
a	#+BEGIN_ASCII ... #+END_ASCII 
A	#+ASCII: 
i	#+INDEX: line 
I	#+INCLUDE: line
非常方便。
*** IMPORTANT 什么是元编程？元编程就是自己写解释器Parser，它不同于一般编程只是写数据的是，它会在数据里面包含动作，每当碰到动作的时候，需要执行特定的指定的函数，这就对我们的写程序提出了更高的要求，但由此带来的好处是惊人的，就是我们可以用更短的数据表述更加复杂的问题了，而且能够更灵活的表述问题，而不是一滩死的数据。
*** IMPORTANT org-mode实际上追求的是一种纯文本的网页，写文档实际上是一种非常纯粹的事情，我们并不需要在文档中插入很多图片、图表等乱七八糟的东西，我们并不需要在各种强大的编辑器之间切来切去，所有的这些东西都可以通过简单的文本来表述，这就是org-mode所追求的东西，我们只需要写好自己的文本，专注于真正需要专注的东西，在需要对外发布的时候转换成对外的格式就行了，由于是纯文本，管理维护起来非常简单。
*** 实际上emacs所追求的又何尝不是强大的纯文本编辑能力呢，只做文本编辑，不做其他的事情，这些事情交给各种强大三方拓展去做，它们做的更好，我们只需要安安静静的做做文本编辑就行了。要做到这一点，首先必须提供极其强大的编辑能力，然后是极强的拓展性，兼容各种三方插件与程序，让它们可以被很容易的集成进编辑器，拓展编辑器在其他方面的能力，这样各种各样的工作就完成了。
*** TODO 使用callback处理不断的异步回调，而不是promise.
*** IMPORTANT BOOTCDN，测试新的第三方函数库的神器。当我们只是想测试下某个库却又不想去走复杂的quickStart流程的时候，这个神器就出场了，打开这个网站找到我们需要的库，复制出库标签，添加到html文件中就可以愉快的测试了，非常简单。
*** TODO 我需要高屋建瓴式的思维，把问题想得简单，不能有畏难情绪。
*** TODO 有两种封装，一种是函数封装，一种是对象封装。对象封装是比函数封装更难的东西。
*** TODO 将ajax封装进请求
*** js函数有两种写法，一种是处理函数写法，一种是类函数写法。
*** TIPS 面向对象重数据的管理而不是处理过程，因此适合于用来做一些数据管理的工作，而不是复杂的过程，复杂的过程应该使用函数式编程方法来做。
*** TODO what is pipe?pipe is just a process which called a function many times and in a same object,it is very powerful.用中文来说就是调用同一个对象上的同一个方法多次，并且将前一次调用的结果返回给后一个过程的过程。
*** what is autocomplate?autocomplate is a function which accept a keyword and return a array of word,by this way,we can select a similar word by a word,improve our ability of input word.
** 2017/01/12
*** 如何给一个回调函数传递参数，一种非常常见的方式是通过在函数外再包一层函数并返回这个函数，然后在外层函数中传递参数，这样就能实现外层传递参数并传递函数，然后在函数中进行处理了，代码如下：
#+BEGIN_SRC js
  function test1(...arg) {
      return function test(callback) {
          callback(...arg);
      }
  }

  test1(100,200,300,'abc')((...arg) => console.log(arg)); //output: [100, 200, 300, "abc"]
#+END_SRC
这种方式极其有用，用这种方式写出来的代码输入、处理于输出都非常清晰，从前到后，非常符合人们的思维习惯。
*** JSONP实现原理：资源请求方为A，被请求方为B,我们需要在A中定义一个函数，然后通过脚本请求在B中调用这个函数，然后函数参数就会进入A中的函数体，这样我们就要到了我们需要的资源。使用JSONP进行跨域请求时，请求数据就是定义特定的函数然后通过加载script标签调用这个函数，函数参数就是我们需要的数据。
*** dom元素压盖总结，父元素层级高的元素在上面（拼爹，由于fixed是相对于浏览器窗口定位，层级最高，所以它总是在上面），如果父元素相同，比较是采用的哪种定位，绝对定位=相对定位>静态定位。
*** 块级元素静态定位元素的宽度是占满父元素的，但是如果使用relative与absolute的话，它的父元素就没有了，这样它的宽度就只是到内容就没有了。
*** 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
说明：（概念解释）学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。
*** IMPORTANT 再次强调一下，callback实际上是输出，跟return是一样的东西，只不过return一般用来输出同步调用的结果，callback用来输出异步调用的结果。或者更进一步说不管是同步的结果还是异步的结果都可以用callback来输出，它实际上是通用的。
*** IMPORTANT 使用callback可以继续抽象函数，尤其是异步函数，而且是这一种强有力的抽象方法。通过它，我们可以封装异步请求了，再也不用将一步步异步请求写在一个函数里面了。
*** TIPS 通过定义函数，我们可以延长函数的参数，传入更多的参数给一个多参的函数，同时暴露更短的函数接口，将具体的求值过程隐藏给用户，简化问题的规模，让问题变得简单。
** 2017/01/13
*** 要想函数返回多值除了将多值封装在一个对象里面通过return返回外，还有个方法就是使用callback，而且使用callback更通用。
*** 在一个渲染引擎中计算的时机非常重要，如果引擎动了而它上面的东西没有跟着动，很有可能就是渲染的时机不对。
*** openlayer的最大分辨率（maxResolution）表示在最小比例尺下，比如dynamic_limit是4，一像素代表多少米。同理，推广开来，resolution
*** IMPORTANT 什么是公式？公式实际上是用户在不断求解问题的过程中发现的一种简记法，类似于缓存，这样当我们再次碰到同样的问题的时候，就可以快速反应出来它实际上是等价于另一种写法的，在这种变换的过程中我们往往能够能够改变问题的规模，将复杂的问题变得简单，将简单的问题变得更简单，进而得到问题的解。其实，定义一个问题只是为了描述这一问题，但便于描述却并不一定便于求解，因此才会有各种形形色色的性质以及公式，有了它们，我们便可以直接利用这些性质或是公式，快速得到问题的解了。
** 2017/01/16
*** RxJS全名Reactive Extensions for JavaScript，Javascript的响应式扩展。响应式的思路是把随时间不断变化的数据、状态、事件等等转成可被观察的序列(Observable Sequence)，然后订阅序列中那些Observable对象的变化，一旦变化，就会执行事先安排好的各种转换和操作。
	在这个概念中，需要格外注意的词一个是“时间”。
*** 数组 + 时间轴 = Observable
*** IMPORTANT 实际上，我们一直以来定义函数的方式也许是错误的，正确的写函数方法也许是：
	args --> funcName --> retValue，而不是我们平常的写法
	retValue --> funcName --> args，正好是个相反的关系
	为什么这样写是更好的方式呢？
	因为这样写是输入 --> 处理 --> 输出的处理流，更符合人们的思维习惯。
	如何实现这一编程模式呢？
	答案是使用回调参数，将函数的返回值写到后面去，这样函数的结果就被放到了最后。
	下面看看使用案例:
	1. Promise。只不过它还多封装了一层，将回调函数封装在Promise对象的参数中。
	2. requirejs。它把依赖写在前面，依赖完成后通过回调函数取依赖的结果。
	3. PIPE。
	4. RxJS。
*** TODO 编程过程中异步问题（或者说时序问题）是个极其不好弄的东西，需要好好的思考下。RxJS就是对于这个问题的一种解决方案。
*** 将一个函数封装在回调函数中可以实现后处理，在函数调用前做一些事情，这是一种非常常用的方式。
** 2017/01/17
*** 如今事件系统受到了越来越多的重视，其根本原因在于它并不简简单单是一个用来在在全局传递消息的工具，更是一个很好的异步处理黏合剂，是异步模型中非常重要的一环。
*** 延迟加载的问题不解决，图层加载的问题就很难解决。
*** requirejs的加载顺序问题是个很坑的问题，容易出错。如果不能正确理清依赖加载顺序，那么出错在所难免。
*** IMPORTANT requirejs只能提前把所有的js依赖都加载完毕了执行，但是如果这个依赖并不是个js文件，比如是某个时间点，某个事件，某个函数调用，这种依赖加载方式就无能为力了，我们急需要一种按需加载的能力，在我们需要的时候加载文件，这本是seajs所追求的，但是如果你想保持requirejs为主加载器，不想引入seajs的话，lazyRequire可以帮助你，它通过对requirejs进行简单封装，实现了按需加载，只有真正调用到它的require函数的时候才会加载依赖，大大拓展了requirejs的灵活性。
*** DONE 其实requirejs而言，单纯的异步加载是很容易做到的，但是不好弄的是异步的异步，有些文件需要在某个文件的某个函数执行完毕之后再加载，这个问题怎么弄？答案是按需加载，也就是真正调用require的时候才进行模块加载，这就是lazyRequire所干的事情了。
*** 提前加载，延后执行，这就是requirejs。真是天坑，擅自将代码提前加载，代码的真正执行顺序并不由写的顺序决定，这是一个非常愚蠢的决定。代码并不以写代码的顺序进行加载，这种反用户自觉的功能必然引发无尽的bug。
*** TIPS 写函数库优于写框架，因为函数库会限定死程序的上层结构，这在重构时会造成很大的麻烦，应该尽可能的写函数库，给开发人员自己组织结构的自由，这样后期的拓展性才会更好。
*** IMPORTANT 其实web编辑器重构之后，代码纵向的拆分是不错的，但是横向拆分就很差了，远远不如事件平台，事件平台的内核是非常小的，最核心的也就这几点：
	1. 一个类机制(god.js实现)
	2. 一个图层管理机制(switchLayer.js  --> layer-amap.js --> Layers.js --> layerSelector.js,由switchLayer作为起点，加载所有的图层)，然后所有的功能都做在图层上，而且单个图层跟其他图层是基本没有耦合，可以非常轻松的把这个图层启用、取消以及移植到其他平台，这样它的可维护性就非常好了。由于代码结构简单，可以很容易的与其他框架进行组合，比如angularjs、bootstrap等（其实react、redux、vue也应该是非常容易引入的）。这是它的精髓。
	3. 交互抽象，比如LeftClick、RightClick、OperationMap等这些公共的、以拓展的服务。即插即用。
*** TODO 其实除了callback hell以外，还有if else hell（switch case也属于此类），那么如何解决if else hell呢？其实面向对象的很多思想其本质是用来解决这个问题的，比如：
	1. 通过类继承，我们可以将核心流程抽象出来，封装成一个父类（基类），然后各个子类（派生类）继承自这个类，然后实现具有特异功能的部分函数，这样就可以利用类型系统自身的类型判断能力根据不同的情况作出不同的处理，将if else消弭与无形，而且使用这种方法还有个突出的好处是符合开闭原则，我们可以无限扩充子类而不必去修改父类。
	2. 使用组合，继承是一条贼船，只能在特定的场景有限的使用下，不能过度使用。比继承更好的方式是通过组合，使用鸭子类型的方式，可以假定另一个类一定具有某些函数，然后在自己本类中实现各个特异的部分，与继承的方式一致，但是通过这种方式带来的是更低的耦合性，可以更好的进行组合。
*** TODO operationMap.js是干啥的呢？什么时候加载的？还有Link.js?
** 2017/01/18
*** 其实requirejs与seajs或者说amd与cmd的差别非常简单，一个是eager evaluation，一个是lazy evaluation，前者会在系统启动之前加载所有的依赖项，需要的时候直接取结果就行了，而后者只有真正需要（也就是require）的时候才去加载，前者以更长的启动时间获取更好的启动后体验，后者有更均匀的交互。
*** 到底什么是模块加载，什么是模块使用呢？模块加载是指调用模块外部的函数，也就是定义模块；模块使用是指使用模块内部的函数或对象，也就是模块调用。比如一个普通的模块：
define(function(require){  //模块加载函数，也是模块定义函数
  require('xxx');

  let module = {};
  //或这样
  function module(){

  }

  module.fn1 = function(){
  
  }

  module.fn2 = function(){
  
  }

  ...

  return module;  //模块返回值，也就是模块调用
})
*** 其实规范的模块写法是不推荐在模块加载的过程中使用这个模块的，这样有可能导致这个模块所依赖的其他东西还没有准备好，但是有时候如果模块的使用者并没有提供调用模块的方法，将模块使用直接放在模块定义的阶段也是没有办法的事情。
*** TODO 尽量少在模块中存储状态，所有状态都尽量从外部传入，这样程序的状态比较集中，纯函数比较多，比较好维护与管理。
*** 定义模块的代码与调用模块的代码混在一起，使得调用发生了错乱。
*** TODO 一般而言，写一个模块既可以用一个对象，又可以使用一个函数，但使用对象没有使用函数的方式灵活，因为使用函数是可以定制的，而对象不行。
*** 实际上不管是amd还是cmd写法写出来的模块，我们可以不借助requirejs或者seajs的帮助，直接自己写个加载器出来加载。加载器的本质是数组，我们需要自己维护一个所有依赖的数组，调整数组中项的顺序，然后从前往后一个个加载，并将已经加载好的模块放进一个新的数组，供下次查找依赖的时候使用，从前到后，实际上就是一个流处理，并没有什么很复杂的东西。
*** DONE 一般我们认为，函数最重要的优点在于重用，但其实它还有个非常重要的作用就是————延迟求值。正式因为有了函数，我们才可以将非常复杂的计算拆分成很多块，每次只初始化我们需要的那一部分，实现资源与效率的双赢。
*** 如果说函数的作用在于延迟计算的话，函数参数的作用就是提前使用，这两者的关系好像正好是相反的，但又不是，延迟计算很多时候等价于提早定义，既然提早了必然会有很多数值暂时拿不到，那么就需要真正计算的时候再传递过来了，这就是函数参数，发明函数的人真是个天才。
*** 函数是从数学中引入的，编程语言完美引入并实现了这个概念，不得不说是一个创举。
*** requirejs实际上是一个三层结构，最外层是一个函数调用，中间层是一个callback定义，最里层是callback返回值。函数调用在文件加载的时候调用，函数定义在模块加载的时候调用，函数返回在模块使用的时候调用。通过一层层的callback，使得它有时机在中间做出一些操作，从而实现了模块机制。
** 2017/01/19
*** fetch API是一套新的API，是脱胎于XHR重新设计的一套API，优于ajax，在chrome42版本以上就获得了支持。所以以后如果仅仅是想发送个异步请求的话再也不需要单独引入jquery了，使用它就可以了。
*** fetch API有三个对象以及一个函数组成，Headers/Response/Request以及fetch函数，通过这些API我们可以轻松收发get与post等各种请求，非常容易使用。
*** JavaScript 通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说它很有用，但它不是最佳API。它在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近JavaScript流行的Promise以及基于生成器的异步编程模型不太搭（事件模型在处理异步上有点过时了——译者注）。
	————Javascript Fetch API
*** TODO 传统XHR API的最大缺点在于它将异步请求的输入与输出封装在了一个对象里，这种做法首先是不符合职责分离原则，更为关键的是它将一个过程混杂在了一起，这样用户就无法将这两个过程与其他过程只有组合了，大大限制了异步请求的灵活性。
*** 使用Promise有许多好处：
	1. 它既可以封装同步操作，也可以封装异步操作，使得两者在形式上得到了统一。
	2. 在核心流程上我们不用关心错误处理的情况，这些已经在Promise中封装好了，我们只需关心我们需要的数据，任意一步出错了流程都直接会到最后的异常处理环节上。
	3. 我们可以随意流程的执行顺序，将某些操作提前或延后。
*** mobx实际上也就是实现了一个观察者模式，通过将每一个源数据作为观察者，每当这个数据变化的时候就调用提前注册号的衍生函数，实现衍生数据的更新。实际上，我们可以把UI也看成是一种数据，把ui的render看成是ui数据的重新计算，然后将ui render连在数据变动之后，这样每当数据变动的时候，就能直接触发UI的更新了。
*** IMPORTANT 把UI也看成是一种数据这个想法实际上是相当先进的。这样之后，一切东西，不管是后端还是前端，实际上都是数据，后端的数据是源数据，中间的控制层实际上就是在做数据转发，然后前端把这些数据渲染出来，当有用户进行UI交互的时候，界面数据发生了改变，同时这个改变会波及到后端，这样，整个模型就非常完美了。后端数据是源数据，前端数据是衍生数据，衍生数据可以影响到源数据，造成数据的更新，以此来进行数据的同步。
** 2017/01/20
*** 人们往往认为编程是创造性的劳动，但是实际上编程也存在着非常多的无效、重复劳动，比如插入html模板、变量改名、方法提取、重构等。甚至可以说，编程的重复劳动一定也不必其他劳动少，这就是Intelli系列IDE的核心思想，它通过各种快捷操作，尽量避免编程过程中的重复劳动，大大提高了开发效率。使用这一系列的IDE时，要重点锻炼学习下各种快捷操作，这会然你减少很多重复劳动。
*** 关于重复劳动这个事，实际上，不管是什么行业，重复劳动都是一种常态，即使是编程这种创造性的劳动。你每天都在写代码，每天写的代码都不一样，看似不是重复劳动，但实际上，重复劳动每时每刻都在发生，比如：
	1. 我们把数据从数据库倒腾到中转站再倒腾到UI，然后再从UI倒腾到中转站然后再倒腾到数据库。M <--> C <--> V。
	2. 我们提取、遍历、处理数据。map/filter/reduce。
	3. 我们处理函数。decrator。
	甚至可以这么说，编程整体就是一个重复劳动，所有的劳动都已经被前人做过了，我们只不过是拿来用而已。但是，牛逼的人知道哪些是重复劳动，哪些可以重复利用，该怎样组合这些工具，常人只知道一遍又一遍的重复做而已。
*** Decorator实际上不过是一个语法糖，它是对defineProperty的二次抽象，defineProperty的出现使得我们拥有了控制对象属性的能力，但是远谈不上好用，因为一个个字段定义很麻烦，我们需要将这些属性组抽象出来方便重用，这就是Decorator出现的原因。
*** TODO what is extend?
*** 实际上babel并不需要webpack，它只是需要一个require函数，由于这个函数的实现太复杂，babel并没有将这个函数内置进babel，因此想流畅使用babel写es6的代码还是需要一个库，用来给我们定义require函数，这就是我们经常看到babel是配合webpack来使用的原因。
*** 实际上webpack的抽象与XHR的抽象非常相似，它将很多过程抽象在一个配置文件中，这样就限制了变换的灵活性，一旦配置越来越复杂之后就没法完了。
