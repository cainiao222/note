* 2017/09
** 2017/09/02
*** 目前三星台湾版有如下重复：
	+ header栏
	  - home/topBar
	  - 
	+ ul-item
	  - common/epg-item
	  - list/ul-item
	  - item/baseItem
*** TIPS 不要直接复用模板，应该复用将模板封装好后的函数。
*** 关于组件化与模块化：
	1. 组件化是为了复用，而模块化是为了维护。
	2. 组件是根据代码实现找出重复部分，以实现代码复用，是一个重复的实现单元。而模块是根据页面结构进行划分，这样对系统不了解的人比较好找代码的位置。
	3. 组件与模块在复杂系统中必然存在，没有做严格区分时，组件常表现为工具函数，以带tool的文件名结尾。模块一般以带header/body/footer这样的文件名结尾。
	4. 一般系统早期，模块化做的会比较早，但成熟的久经维护的系统必然有成熟的组件系统。
*** 其实我特别希望团队之间能够创造出一种乐于分享的氛围，每个人每周分享些自己最近发现的小技巧、好的文章、想法之类的。遗憾的是，这种氛围的团队还是比较少的。
** 2017/09/05
*** git实际上是可以用来直接管理代码文件夹的，而不仅仅是一个中央仓库托管，只需要在远程代码库设置git config receive.denyCurrentBranch ignore，这样我们就可以向远程push代码了，然后再在远程git checkout -f更新下代码文件夹就好了。当然，更好的方式是使用git的hook更能，在.git/hooks下新建一个post-receive文件并输入如下内容：
#+BEGIN_SRC shell
#!/bin/sh
unset GITDIR
cd ..
git checkout -f
#+END_SRC
	然后chmod +x post-receive,这样，以后push的代码就可以自动更新了。
	综上，使用receive.denyCurrentBranch与post-receive钩子，可以完美实现文件夹同步，而且是增量同步，速度快，出错少。
*** git中把本地代码库搞乱之后想恢复有两种方法（恢复到最后一次本地提交，不是恢复到远程版本库），一种是git add . --> git reset --hard,另一种是git add . --> git checkout -f,两种方法都差不多，从表意上来说，git reset更好一点。
** 2017/09/07
*** TIPS 把路由逻辑与处理逻辑分开，路由逻辑应该放在单独的一个或几个函数里，处理逻辑应该作为函数开放出来，这样比较好维护。
*** 循环对代码可读性的影响很大，但条件判断对代码的伤害更大，当碰到大量的条件判断时，尤其是状态量很多且或且夹杂的时候，无论你代码水平多高也无法很快理清楚细节逻辑，要尽量避免写出这种代码。
*** TODO 生成函数调用关系图
*** 最简单的代理模式代码：
#+BEGIN_SRC javascript
function proxy(fn){
    return function(...args){
        //our code
        //...
        return fn(...args)
    }
}
#+END_SRC
** 2017/09/08
*** TIPS 将从外部传进来的数据与内部的数据分开是一个非常好的编程经验。
** 2017/09/09
*** TODO 虽然直接从dom上去状态量的行为不好，但是它却可以减少状态量，实在是很矛盾。
*** TODO abort方法
*** 编程的时候要善于划分问题，在各自的问题域内解决问题，不要将几个问题掺杂在一个域去解决，这样会互相影响，导致后期哪个都难以维护。
*** 没有偶现的bug，只有还没有找到复现规律的bug，只要找到了复现规律，解决起来并不困难。
*** 一个请求尚未结束，立刻切换到另一个tab，然后切换回来，再次发送了一个相同的请求，两次请求的数据发生了叠加，导致card被渲染了两次。
*** 切换到其他tab时还缓存之前tab的数据，导致过滤的时候多出了一部分内容，后期使用这部分缓存数据的时候没有意思到这个问题，导致内部计算错误。
*** IMPORTANT 关于条件断点，我以前也知道有这个功能。但始终没办法把这个功能应用到具体的使用场景，今天才发现这是一个解决偶发性bug的神器。只需要在偶发bug的必经之路上打下一个错误的断点，然后随意操作，尽可能的复现bug，一旦发生，你就可以在错误之前停下而不是直接报错，你可以查看bug出现的整个调用栈，还有所有数据的值等，找到有问题的数据，思考下原因，问题就解决了，非常好用。
*** IMPORTANT 在函数式编程中，有一个非常重要但是非常容易被忽略的东西，就是context数据维护。在流式写法中，通常会有个名叫context的参数，这个参数代表的就是流中的数据，这个数据是需要被好好维护起来的，我们会往其中添加东西，适当的时候也需要删除里面的东西，这样才能实现我们想要的功能。
** 2017/09/11
*** 关于文本框，包括单行（text）、多行（textarea）、contenteditable的，css给我们的控制其中内容样式的属性非常少，但是非常重要，如果搞不清你对样式控制就永远谈不上精细，常见的有以下几个：
	1. line-height，行高
	2. vertical-align，对齐
*** 什么是DSL？DSL针对具体使用场景而设计的语言，实际上我们经常碰到。比如：
	1. css实际上就是一个用来布局与排版的DSL
	2. html就是一个用来编写结构化文档（就是带结构的文档）的DSL
	使用DSL我们能够*隔离*内部具体逻辑，只需要用规定的方式去写"配置文件"就能实现功能，通过what去做事而不是通过how，极大提高效率。
*** vinyl-fs能够把不同类型的文件，比如
** 2017/09/12
*** 开发、测试、上线，三套环境。这三套环境可以简要理解为部署在三个服务器下的三份代码或统一服务器下的三个目录下的三份代码，彼此类似却又有些许差别。任何稍显复杂的软件都必须有这三套东西，并且提供平滑升级的脚本。
	1. 开发环境给开发人员进行新功能开发与bug修复，这个环境有sourcemap，调试起来会比较方便。
	2. 测试环境给测试人员进行测试。由于开发人员在开发或改bug的时候很容易破坏掉当前环境，如果开发环境与测试环境在一起就会阻塞测试，所以测试环境是必须的。测试环境也可以有sourcemap，便于当场定位问题。
	3. 至于上线环境，这个时候会有保密与解决缓存需求，需要对代码进行压缩与加版本号等。
	4. 一般来说，开发环境可以升级为测试环境，然后测试环境可以升级为线上环境，最好不要直接用开发升级到线上环境。
*** TIPS 在node中弹出窗口消息非常简单，直接使用node-notifier,然后直接通过一个函数就能跨平台的调起对应平台的气泡了，非常简单。
*** IMPORTANT 一个页面加载过程中，这个页面的http请求尚未结束时如果切换到其他页面，要记得先取消掉这个页面的http请求，不然在其他页面会收到之前页面的数据，由于页面上下文已经切换了，无法预料会对新页面造成什么影响。
*** 不要太依赖于gc的垃圾自动回收，总有些gc照顾不到的地方，最典型的就是异步的场景，比如事件、http请求、尚未完成的用户交互，当context上下文发生改变的时候，要想一下这些东西是否能被正常回收，如果不能，这些东西会影响到新的context的功能。
*** IMPORTANT 编程这么多年，渐渐能体会到构造、析构以及context之间的联系和各自的作用。
	1. 构造用来在实现功能之前建立起一个context上下文环境，为context中的函数建立起数据支撑（这个数据包括函数，但重点在数据上）。
	2. 用户使用context中函数，完成提供的功能，同时更新context中的数据。
	3. 当功能模块使用完毕，context需要被销毁，这里面的一部分工作可以由gc来完成，但还有些gc顾及不到的地方，就是异步场景，比如事件资源、API请求、用户交互等需要用户手动去释放，这就是析构的意义。遗憾的是，js至今还没有一个合适的析构函数，这不得不说是一大遗憾。
*** 为什么要面向对象？这实际上是为了简化我们的工作量。当我们需要一个新的与之前对象功能类似的东西时，我们无需过多关心清理旧对象资源的问题，直接重新生成一个新的对象去做我们的事情往往会更加简单，这也就是面向对象出现的源初动力。
*** TIPS gulp是可以直接用命令行打印出当前所有的任务的，方法是
	1. gulp --tasks 以树结构打印任务列表
	2. gulp --tasks-simple 以列表形式打印任务列表
** 2017/09/13
*** IMPORTANT 为什么要面向对象？可以这么说，面向对象是为了建立起一个context，用来给功能函数提供一个环境。即使不使用面向对象，也避免不了环境问题，而且会更糟。
*** TODO 异步请求错乱的问题。
*** TODO 将包括用户操作、接口返回、socket事件等异步操作全部promise化。
*** TIPS 跨文档通信实际上很简单，只需要双方同时接收（监听）另一方的消息，当收到消息后将对象需要的信息返回回去，这样就能互相通信了。这是一个典型的异步操作，我们当然能够将它给promise化，只需要监听到的时候resolve就好了。
** 2017/09/14
*** TODO IO is a very important issue.Many things can be regard as a IO operation.Such as network request、user interactive(user Event)、socket Event、timeoutEvent...
*** TIPS 以id作为数据续处理的中介。从一个过程流转到下一个过程，一步步继续处理，这就是盒子程序运转的关键。
*** TIPS 事实上，直接使用js来操作dom具有最好的灵活性，最有利于写出最优雅的代码，但需要解决一个关键的问题，也就是dom的更新（增加、删除、查找都没有问题）。jsx就是解决了这一问题才得以流行的。所以，更新是一个非常重要的问题，它与效率关乎最大，是解决io问题的一个神兵利器。
** 2017/09/15
*** TIPS 如果不断以重复的方式做某事，不但不会进步，还有下滑的危险。――――爱利克*埃里克森
	这句话非常重要。熟练掌握某项技能的标志虽然很多时候在条件反射，但仅仅靠条件反射是无法提高的，甚至会阻碍你去提高从而造成下滑。就比如我打dota，虽然打了很多年，但多数时候只是在一遍遍的重复同一个套路，不去思考哪里做的不好，怎么提升等问题，打的再久也只能原地踏步甚至退步。比如写代码，如果每次来个需求，就按部就班、使用同样的套路去写，不去想想可以怎么优化，编程水平也就止步于此了。还有一件事你做了很久然后放下一段时间之后重新去做，很多时候会有做的比以前更好了的感觉，就是因为你在重拾过去技能的过程中去总结与思考了这个技能，从而能够做的比以前更好。
*** 关于mocha测试：
	1. 使用describe组织目录结构
	2. 使用it组织测试项
	3. 使用assert判断相等
	4. 使用done判断异步请求成功或失败
*** TODO 数据流
*** 实际上实现系统维护中非常简单，只需要在请求入口处将所有的页面暂时导向维护中的页面，然后恢复结束后再取消掉就好了，在koa中，这也就是一个middleware的事。
** 2017/09/18
*** 异步函数作为参数与普通函数并没有什么不同，所需要注意的只是需要在调用的时候需要加上async与await，koa的use就是这么来的。
*** 关于mocha测试的返回值，实际上与gulp是非常想的，有两种返回方式，一种是使用return一个promise（gulp是return一个stream），一种是使用callback参数。
*** TIPS 最好的查看源代码的方式并不是直接上github上去看，而是直接在ide里面看，特别是在当你使用一个库的时候想查看下源代码的时候，此时代码已经被你下载下来了，直接查看就好了，还可以随时试验，你甚至可以调试运行一下以验证自己的想法。
*** 如何获取callback（cb1）的callback(cb2)参数,答案是在cb1的定义中放上cb2的定义，然后已cb2作为参数调用cb1,在cb1的调用过程中cb2倍调用，此时控制权就进入到了定义中，你就可以使用cb2做很多自己想干的事情了，比如：
#+BEGIN_SRC javascript
function test(cb1){
   function cb2(msg){
      console.log(msg);
   }

   cb1(cb2);
}

test(function （cb）{
   let x = 100;
   if(x === 100){
      cb('done')
   }
   else {
      cb('error');
   }
})
#+END_SRC
*** TODO 函数调用的本质是执行控制权与context的转移，函数参数就是当前context中的部分context。当函数被调用，执行控制权从调用部分转向控制部分，同时使用函数参数带走部分context，然后在新的context中执行，当函数调用完毕，可以使用return或是回调函数将新context中的执行结果带回到原context。
*** 关于nodejs代码调试，现在已经被内置到node里面了，方法如下：
	node --inspect-brk xxx.js
	然后你就可以使用about:inspect找到并调试xxx.js，如果你连这一步都不想做的话，使用NIM可以自动打开调试窗口，这样就更加方便了。
*** 教育是社会的杠杆，网络是教育的杠杆。
*** mocha/jasmine/jest/karma
*** istanbul自动执行js代码，测试代码覆盖率的神器，使用它可以查看某个代码中的执行到了哪些分支，哪些地方没有覆盖到，
*** 关于js的数字与字符串比较，字符串会先被转化为数字然后与数字比较，如果转化失败，会得到NAN，NAN与任意数字比较都返回false，不管是大于比较还是小于比较。
** 2017/09/20
*** TIPS 将html元素作为参数传入到js中有什么好处呢？这实际上是一种将html与js分离的一种手段，好处是如果UI需要重写，我们只需要保证这些关键元素都在，就可以轻松重写UI了。实际上，想彻底分离html与js，但靠这一方法是不行的，其中非常重要的一点就是――――js中不可避免会经常出现操作html的代码，这些东西会使得两者出现紧密耦合。要想做到这一点，需要将这部分逻辑放到html中，也就是要增强html的能力，这就是jsx出现的原因。
*** TIPS PhantomJS,无头浏览器，它最大的作用是用来做什么呢？网页截图。相比于nightmare。
*** TIPS nock，mock神器，有如下功能：
	+ 请求模拟，提前设定好请求返回的数据，当发出相应的请求时，直接使用预设的数据作为请求的返回值。
	+ 请求保存，将请求返回的数据保存起来，然后你可以重新load，这样你的程序甚至可以脱机运行。
	+ 请求回放与代理。
** 2017/09/21
*** TIPS 关于网页的简单部署，实际上非常简单，只需要将网页拷贝到服务器上，然后到对应的目录打开http-server就行，根本不需要什么nginx、apache这种复杂的东西，改配置改半天。直接网页部署在服务器上测试有什么作用呢？作用如下：
	1. 无需修改host（但是需要修改domain），可以避免有些盒子上出现的host修改不生效的情况。
	2. 可以解决缓存问题，因为自己服务器上的文件名是可以随便改的，这样你就无需做一大堆清除缓存的工作了。
*** 关于安卓设备root，其核心原理就是把su和supersu写入system。至于如何写入，有如下几种方式：
	1. 利用系统漏洞，获取root权限，然后写入这两文件。
	2. 有些设备厂家没有锁死，可以在刷机时（bootloader）获取root权限，将文件写入。
	3. 如果手段高明，你甚至可以在刷机前修改刷机程序，将文件写入。
*** 关于安卓apk包的安装流程，实际上就是一个文件拷贝的过程，有三个目录：
	1. system/app（系统应用）或data/app（用于应用）目录，用来放程序代码。
	2. data/data用来存放应用数据。
	3. Data/dalvik-cache程序缓存。
	安装程序时安装引导程序会将包中的内容按文件夹分别放到这三个目录下，完成程序安装。
*** css能做什么，哪些需要js协助？能够做对象的平移、旋转、缩放、倾斜、渐隐，不能做对象切换、时间轴控制、动画组合。
*** What is a test spy?A test spy is a function that records arguments, return value, the value of this and exception thrown (if any) for all its calls. There are two types of spies: Some are anonymous functions, while others wrap methods that already exist in the system under test.   ――――Sinon Documention
*** What are stubs?Test stubs are functions (spies) with pre-programmed behavior.Use a stub when you want to:
   1. Control a method’s behavior from a test to force the code down a specific path. Examples include forcing a method to throw an error in order to test error handling.
   2. When you want to prevent a specific method from being called directly (possibly because it triggers undesired behavior, such as a XMLHttpRequest or similar).
	  ――――Sinon Documention
*** TODO sinon是一个非常牛逼的高阶函数库，underscore/lodash这些库的高阶函数在它面前都非常小儿科了。也就ramda稍微好点，但还是没法与它相比。它可以让我们在不修改函数实现的情况下改写函数的行为，强制让函数做我们像做的任何事情，一般用来做测试，但实际上，它的能量绝不仅于此。
** 2017/09/22
*** TIPS 为什么要用框架，把代码搞的那么复杂？最主要的原因是便于维护，一段代码写好之后的维护时间是远远大于开发时间的，如果不用写方法手段对代码分分类的话，当发现问题时，你无法第一时间反应出出现问题的在哪一部分，这样代码就无法维护了。
*** 很多时候新功能的加入是以加入新状态为代价的，状态过多是软件难以维护的一个主要原因，所以我们需要定期对状态进行清理与归类。
*** IMPORTANT 关于前端数据管理：
	1. 数据在哪里定义的，就应该在哪里维护。不应该将数据传递给子组件然后在子组件中去修改。
	2. 组件应该接受数据而不是从额外的接口获取数据，换言之，获取数据这种事不应该在组件内部去做,应该在app这种将组件组装起来的地方去做。
	3. 接口数据与UI数据应该分开管理，更进一步说，接口数据应该在UI之外管理，UI数据应该在UI内部管理，还是那条原则，数据是从哪来的，就在哪管理。
	4. 虽然接口数据必然要传递给UI用来显示，但只是显示，不应该修改，也就是说，在UI中，接口数据是只读的，如果要修改，应该通过发消息的形式让数据提供者自己去修改，这样数据始终是可追溯的。
*** vue组件的data函数非常坑爹，不要在这个函数里面写任何其他的逻辑，它里面应该只写数据的初始值，然后在其他的生命周期函数中去修改这些值。
** 2017/09/26
*** TIPS 安卓开发其实也是用配置文件来管理界面的（xml，位于res/xml文件夹下，与前端的html是一回事），然后安卓使用java面向对象开发，前端实际上程序写多了之后也不得不面向对象来进行开发以降低维护成本。然后安卓不如前端的地方在于它没有css。
*** TIPS 安卓开发与前端开发非常相似，其实不仅于此，像c++开发实际上也是一样，使用xml做界面，上层是路由，以及基本的UI数据管理，下层是实现逻辑，以及模型数据的管理。
** 2017/09/27
*** 页面跳转实际上就是一个函数调用，是需要参数的。
*** TODO EventEmittet――――nightwatch的底层驱动库，是一个非常有用的库，它可以用来管理任意的异步处理。将事件机制配合timeout才是更好的异步处理方法。
*** TIPS 关于arrow function与普通fucntion的选择，如果你的实现中没有用到this的话，最好写成arrow function，更短可读性更好。
*** TIPS 原来自动将let转成const或let真的是可以的。还有将字符串相加自动转成模板字符串。eslint就可以轻松做到。
** 2017/09/28
*** 只有普通function（不包括箭头函数）调用的时候才会绑定this，所以下面的写法是不行的：
#+BEGIN_QUOTE javascript
let x = {
	a: 111,
	b: `${this.a}222`
}
#+END_QUOTE
	因为此时没有函数调用this依然为原值windows，这样也是不行的，因为此时x并未定义完毕：
#+BEGIN_SRC javascript
let x = {
	a: 111,
	b: `${x.a}222`
}
#+END_SRC
	这样也是不行的，因为箭头函数不改变this：
#+BEGIN_SRC javascript
let x = {
	a: 111,
	b() => `${this.a}222`
}
#+END_SRC
	这样是可以的：
#+BEGIN_SRC javascript
let x = {
	a: 111,
	b(){
		return `${this.a}222`
	}
}
#+END_SRC
** 2017/09/29
*** TODO vue中组件使用class与style是难以测试的。因为class/style这些属性并不是传递给子组件的props，而是组件本身的东西。无法从外部传入进行测试。
*** TODO 拒绝低效的勤奋，花了大量的时间却没有什么产出。
*** 把数据处理的部分集中
