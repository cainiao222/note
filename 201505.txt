* 2015/05
** 2015/05/05
*** 这是一个悲伤的故事。仙剑、大宇、姚壮宪、张毅君。其实所有人都没有错，大宇只是想不被时代淘汰，转型网游，但命运不济，转型失败，亏损严重，继续资金来弥补。此时，张毅君的单机团队创造下的丰厚利润正好弥补了这个缺口，大宇终于可以继续支持下去，但同时也坑苦了张毅君的单机队伍。面对新技术，大宇选择了尽快去拥抱，而不是像柯达一样固守老技术不放。两种不同的选择，一样的结果，这不得不引起我们的深思。看到了柯达的故事，也许绝大多数人的想法就是要拥抱新技术，不能固守成规。但仙剑的故事打了这些人一个大大的耳光，大宇拥抱了变化了啊，却依然悲剧收场。其实重要的不是拥抱变化，而是思考，是面对变化一颗始终不变的思考的心，世界每天都在变，我们根本没有能力去拥抱所有的变化，必须通过我们的思考过滤掉不必要的变化，选择自己认为正确的路走下去，这才是正确的路。
*** 我们的思维很容易被流行的东西所误导，认为某些其实不是正确的东西是正确的。如果意识不到这一点的话这一点表现的更为严重。如果意识到了同时要避免这一点的话必须通过思考，去掉流行蒙蔽的思考。
*** 我们心里认为什么是正确的，就会无意识的去寻找与这个观点对应的资料，最后得出好像我们自己的观点是正确的结论。其实这是片面的，因为我们寻找的资料其实是片面的。世界如此大，各种各样的资料其实都有，如果总是按照这种证明手段的话你会发现所有的观点都是正确的。其实真实的情况非常可笑，根本没有非常客观的证明观点正确的方法，我们只能靠自己的感觉，自己感觉对其实就可以了，想证明基本都是徒劳的。
** 2015/05/06
*** 何时需要自定义事件？事件的出现其实是给予这样一个源动力。当发生某种情况时，我们很可能需要对这种情况进行处理，但暂时还不确定怎么处理。这时我们就需要使用事件了。但是对于可拖动面板我们是否需要拖动事件这件事情的处理上，其实当拖动发生的时候，我们知道要对面板进行拖动，而不是不知道要怎么处理，这种已经知道怎么操作的情况是不需要事件的，使用事件只会徒增复杂性。
*** 必须尊重编程老手，很多时候面对问题即使我们已经有了自己的想法，也最好去问下编程老手们的意见，他们的解决方案也许有时候比较蠢，但也有的时候能够让我们眼前一亮，原来这个问题还可以这样解决。不要不管不问就按照自己的想法去解决，这样有时候是非常不明智了。自己的想法要有，但同时也不能忽略别人的想法。
** 2015/05/07
*** 也许，照耀大地的永远是在众恒星中普普通通的太阳，人们永远不会知道在宇宙的某个角落里曾经诞生过一颗绝美无比的小星星。这个世界是不完美的，否则如果它是完善的，缺少了不完美，它还完美吗？这个世界是不公平的，流星划过苍穹，带给多少人希望，而它自己却身殒，不留下一点痕迹。
*** 每个配置文件最终都会变成一门编程语言。一开始你可能只会用它表示一点点东西，慢慢地你便会想要一些规则，而这些规则则变成了表达式，后来你可能还会定义变量，进行条件判断等，而最终它就变成了一种奇怪的编程语言。――James Gosling
*** 目前常见的编程语言大都是命令式(Imperative)的，例如C#、Java或C++等。这些语言的特征在于，代码里不仅表现了“做什么(What)”，而更多表现出“如何(How)完成工作”这样的实现细节，例如for循环、i += 1等，甚至这部分细节会掩盖我们的最终目标。在Anders看来，命令式编程通常会让代码变得十分冗余，更重要的是由于它提供了过于具体的指令，这样执行代码的基础设施(如CLR或JVM)没有太多发挥空间，只能老老实实地根据指令一步步地向目标前进。例如，并行执行程序会变得十分困难，因为像“执行目的”这样更高层次的信息已经丢失了。因此，编程语言的趋势之一，便是能让代码包含更多的“What”，而不是“How”，这样执行环境便可以更加聪明地去适应当前的执行要求。――Anders Hejlsberg
*** 如今影响力较大的趋势主要有三个(如图2)，分别是声明式的编程风格(包括领域特定语言、函数式编程)、动态语言(最重要的方面是元编程能力)以及多核环境下的并发编程。此外随着语言的发展，原本常用的面向对象语言、动态语言或是函数式等边界也变得越来越模糊，例如各种主要的编程语言都受到函数式语言的影响。因此，多范式程序设计语言也是一个愈发明显的趋势。――Anders Hejlsberg
*** 工具与服务是不一样的。同样的一件事，如果使用工具来解决的话会要求所有的机器上都安装上相应的环境，然后将工具给拷贝过去，这样就可以运行了，这样虽然不需要联网就可以运行而且运行效率高，但会给部署和维护带来沉重的负担。
*** 异步调用程序虽然会带来效率提升，但同时也容易引起同步问题，有利有弊。
*** 每当碰到某个功能在其他语言中有，但在这种语言中没有的时候，就要思考一下比较一下这两种设计哪一种更好，亦或是两者都好，都不好。设计思维就是这样一点一点练就出来的。
*** 多多封装别人的接口，使之变成自己感觉满意的接口，这种习惯对于后期自己设计接口是非常有好处的。
** 2015/05/08
*** 使用defvar定义变量与使用setf定义变量的不同之处在于defvar不能重复定义变量，重复定义的时候变量的值不会被改变，这样能够防止意外的修改已经存在的变量，而setf不会管这些，不管有没有，它都会将变量设置为新的值。
*** 关于音频播放的接口问题其实非常简单，最基本的格式是wav，wav格式的音频文件是可以直接播放的，不需要额外的编解码工作，而其他所有的格式都是基于wav的，播放这些格式时需要先将这些文件解码成为wav格式，然后才能播放。所以，一个软件要想留出音频接口非常简单，只要支持最基本的wav格式播放就可以了。其他格式只要由程序员自己去编写编解码就可以播放，而不需要额外的接口。同样的道理也适用于视频，视频的基本格式是avi，其他格式都要先解码成avi才能播放。同样的道理也适用于图片，图片的基本格式是bmp，其他格式都需要先解码成bmp才能显示。
*** 不管是哪种硬件，往往都只能处理最简单的原始数据格式，如果你想让它支持其他格式的数据，就必须要先转化为原始数据格式，然后再送给它去处理。比如bmp,wav,avi等。
*** 关于接口的设计其实非常简单，要抓住重点，提供最基本的功能就可以了，至于什么是最基本的功能这就需要自己去思考了，只要提供了方方面面的最基本的功能，那么这门语言就是设计非常良好的语言了。
*** 学会写解释器非常的重要的。只要会写了解释器，大多数的问题都能非常容易的解决。从某种意义上来讲，计算的本质就是解释器。因为解释器实际就是规则，它就是DSL，它允许先自行设计一套语法规范，然后用这套规范去解决问题，由于可以避开语言的限制，所以绝大多数情况下都能设计出非常简单的解决方案。
*** 解释器的核心只有两个，模式匹配以及递归，只要掌握了这两个，就可以很轻易的定义规则，实现自己的DSL。
*** 解释器能够实现规则，但其实解释器无非就模式匹配以及递归两个关键点，还是非常容易实现的。DSL中难的是定义规则，也就是语义学，只有掌握了语义学，才能比较好的定义规则。
*** 学习一个东西之前，搞清楚自己到底学的是什么东西是非常重要的，因为只有你知道了自己到底在学什么东西，解决一个什么问题，你才能自己去思考解决这个东西会遇到哪些困难，然后有针对性的去看别人是怎么解决这个问题的。这样学习才能抓住重点，最快最好的学会这个东西。
*** 环境变量的重要性也许被大大的低估了，环境变量就是变量，而变量对编程的重要性是不言而喻的。
** 2015/05/09
*** 一个软件做出来，反映的是整个软件制作团队的平均水平，不管某几个人的水平有多高，最后的产品肯定是一个平均值。所以，开发一个软件的人越多，这个软件就越趋向于平庸，真正牛逼的软件都是非常少数牛逼的人一起开发出来的。
*** 一个框架、一个软件设计的好坏，很大程度上取决于它能否对系统进行良好的分类。将关联关系紧密的东西放在一起，将没有关联的东西区分开，同时尽可能的去掉重复的东西，使得这个东西尽可能的容易被理解，被维护，被使用。
** 2015/05/11
*** 关于孩子的教育问题，孩子教育的首要目标是培养孩子的独立人格，让孩子学会思考，懂道理，识礼仪，对万事万物有自己的意见与看法。教育并不是大人经验的复制，而是让孩子懂得选择，吸收大人的精华经验并转化为自己的经验。
*** 现实世界跟计算机世界真的非常像。所谓生小孩就是重写，所谓教育也就是继承并重构（也就是选择性复制粘贴）。通过生小孩并教育他，我们重写了我们的系统，使它能在某些方面运行的更好。所谓工作就是把自己通过教育换得的知识投入实际使用，并由此发明或发展出新的知识，这些知识又会被下一代继承。所谓死亡就是对象的作用域到头了，如果没有小孩或是徒弟自己的经验就很有可能消失了。生活就是不断重写，以继续生存的问题。
*** 孩子有没有重构或者是自己选择的能力非常重要，这决定了我们的系统能不能进步，同时也是孩子聪明与否的重要指标。不管是否正确一股脑接受这不是聪明的孩子，聪明的孩子应该有自己的看法有选择性的去接收知识。
*** 很多看似只有两个答案的问题其实存在第三答案，这个答案能够取前两个答案中的精华部分并加上自己的一些修饰与改良，很多时候这个才是正确的答案。比如编程是面向过程好还是面向对象好？孩子教育是穷养好还是富养好？
** 2015/05/12
*** 复杂的系统总是通过几个全局变量来全局管理整个系统，可以通过指针留出这些对象的子对象的指针，这样就不用额外建立对象，然后还能很好的控制系统，这是一种使用指针的方法，也是一种构造系统的有效手段。
*** 兼容绝对是一个非常沉重的负担，特别是在没有一个全局的版本号控制的时候，MFC就是缺少像.NET那样的版本号控制才创造出了一堆xxx，xxx_s,wxxx,wxxx_s,xxxEx这样乱七八糟特别难记的方法。其实只要使用了版本号，通过版本号来区分，实现同样功能的代码使用相同的函数名，这样程序员的记忆负担就会小很多很多。
*** 知北游广播剧
*** 水仙
*** svn的缺陷跟云盘的缺陷一样，不能同时修改同一个文件。某个人对某个文件的修改必须先传上去，下一个人才能继续对这个文件进行修改，不然就会丢失前一个人的改动。
*** MFC消息映射的实现原理实际上就是一张简单的key、value表格，表格的key为消息ID，value为消息映射函数。不是map或是set这种复杂的表，就是一张用最简单的数组表示的表，从前往后查找，一旦找到消息ID对应的函数，就调用ID对应的函数，而且不再继续查找表。这种方式虽然能带来比较高的运行效率，但却使得一个消息只能对应一个函数了，一个消息只能被处理一次而不能为多次。其实为了那么微末的效率提升，这种做法很多情况下是得不偿失的。
*** MFC就是sicp中所提到的数据导向程序设计框架设计（又叫记忆法，表格法）的典型。主框架中使用查表法来处理各种情况并留出表格对象的接口，然后对于各种情况，只需要添加相应的情况类型以及对应的函数到主框架，就能使主框架能应对各种情况而不用更改主框架代码，实现了高拓展性。这就是基于这种框架的牛逼之处。
** 2015/05/13
*** svn里面如果两个人同时修改同一个文件，第一个人可以提交成功，第二个人无法直接提交成功，因为提交的时候svn会先检查当前提交的版本是否是基于最新版本进行的修改，如果不是，会要求先更新，然后才能提交。但是即使是这样依然会发生提交冲突，因为svn很难将对文件的两次修改合并，还是只能由提交者自己来解决冲突，非常恶心。还不如这个问题的出现本质上是由于svn的核心机制――集中式管理，将所有代码都放在一台机器上。
*** svn只适合于几个人的小团队管理代码，当一个项目确实需要很多很多人去写的时候，冲突非常难以避免，难以解决。特别是在一些公用的配置文件上更是如此。如果真要用svn来管理超大项目的话，必须先将超大项目拆分成小项目，然后每个小项目由有限的几个人去负责，当冲突出现的时候可以互相沟通，这样工作效率还行。这个人数大致在10人以内是合适的。
*** TODO 代码的管理是一个非常复杂的问题，需要被仔细考虑。
*** 接口是什么，接口就是一种类约定，接口的调用者与接口的实现者之间必须共同遵守的规范。它最关键的作用是使得类的调用者不用关心类的实现细节就可以使用这个类，来编写自己的框架。
*** 其实KPI工作模型已经悄悄的渗透进了我们工作的每时每刻，我们每周都要写的周报就是典型的KPI模型。向上面汇报每一周做了什么以及下一周要做什么实际上大大限制了小组成员的创造性，即使他们有好的点子也会迫于KPI的压力而不去做。而OKR模型是基于一个共同的愿景而不是像KPI一样是基于一项项任务，这样每当小组成员碰到问题的时候，往往会有一堆成员前去帮忙，因为没有KPI的压力，往往问题能很快得到解决，非常有利于团队整体水平的提高。但OKR问题容易让员工养成懒散的毛病，不做事，只救火，需要人监督。
*** 你真的理解面向对象编程吗？虚函数是什么，继承是什么，模板是什么，也许能够真正理解的人不多。
** 2015/05/14
*** KPI是针对于个人的，OKR是针对项目的，前者的着眼点是管好人，顺便管好人，后者的着眼点是做好事，随便管好人。
*** 加法是加一的累积，乘法是加法的累积，幂是乘法的累积；
*** 实际上会员就是一种流量把控手段，资源是有限的，当资源满足不了需求的时候，为了尽可能的满足高需求的用户，会员就是必须的了，实际上就是一种会员分类手段。这一点可以推广开来，为什么中国的房价那么贵，因为中国用户对房的需求高，房子不足，所以就有了各种限制买房的手段来让需求强的用户先满足，这是自然的规律，无法抵挡，但关键问题是谁才是真正需求强的用户，并不是钱多的才是，这就是问题所在了。
*** 实际上，写出一个好的长篇小说并不像想象中的那么难，只需要构思好一个好的背景与人物性格，让其自然而然发展就好了。
*** 函数式变成不同于过程式编程的地方在于函数式变成更侧重于描述问题是什么，只要描述清楚问题，基本上这个问题就被解出来了；而过程式编程更侧重于描述问题怎么做，必须指明详细的步骤才能把问题给做出来。
** 2015/05/15
*** 底图分块加载的原理实际上非常简单，就是对各层次的图片进行标号，最终给每个图片都编出一个三维的坐标，然后用户只需要给出这三个坐标值，就能获取对应的图片，没什么难的。这种编号的方法非常有启发意义，值得我们在很多地方借鉴。至少很容易被推广到繁杂对象的选择性显示，对于像激光点云这样的数据是非常有必要的。
*** 敌对的双方虽然为敌对关系，但在见招拆招的过程中是很容易产生惺惺相惜的感情的，知己难求，尤其是在牛逼的人眼里尤其是这样。
** 2015/05/16
*** 感受身体的呼吸，对自己好一点。只要用心，真的可以感受得到。
*** 用心去感受身边的一切，真的可以感受到很多很多的东西。也许我们真的只接收到了流过自己身边信息的1%，而让绝大多数的信息无声无息的流走了。
** 2015/05/18
*** 如何实现图层？实际上非常简单，只要引入将坐标系由二维变成三维，引入z轴的概念，然后在加载的时候按照z轴坐标来进行加载。特别要注意的是，这个z轴并不代表具体位置，而是一个属性标识。有了这个概念，给每个对象的z轴赋一个值，然后按照z轴的大小进行渲染，就实现了图层。
*** 书籍让你记住了现成的“事实”，却不能让你拥有产生出这些知识的能力。它们只是把你“训练”（train）成了循规蹈矩的流水线工人，而不能让你受到真正的“教育”（education）。――王垠
*** 真正的好书都是很薄的，“把厚书读薄”这句话其实是误导的。厚书本来就不应该拿来读，最多可以拿来当字典查。所以我的建议是：如果你想成为天才，就避免去读厚书。去寻找简短的书来入门，然后就可以自己思考了。――王垠
*** 要成为天才，你必须使用直觉（或者图形），而不是符号（或者文字）进行思考。这是很显然的事情，因为人脑根本不是用符号进行思考的。符号只是不同的人脑之间进行信息交互的媒体，就像电脑之间的网线上传输的信号，它并不存在于思维活动中。有些人可能会告诉你，直觉是不可靠的。这些人并不是天才，所以不用听他们说什么。直觉可靠与否，是由你自己的造诣决定的。这些人没有得到可靠的直觉，所以他们就连直觉的价值一起给抹杀了。――王垠
*** 真正的天才，比如 Nash 和 Feynman，都是用直觉思考的。别人的公式在进入他们头脑里时，首先被翻译成某种“思维模型”，然后他们的头脑对这种模型进行思考。他们通过直觉对这些模型进行变换操作，得出结果。然后他们用符号把这结果表示出来，为的是给其他人看。那些完全用公式进行推导的人，往往是纸上谈兵，只能做出衍生的结果，而不能做出突破性的发现。――王垠
*** 面对一个问题，不要直接看结果，要先自己对这个问题进行下思考，搞清楚这个问题的难点在哪里，再去针对性的看那一部分，其他的粗略扫一眼就可以了。如果可以的话，甚至可以自己直接推导出这个问题的解，都不用看了。
*** 要对问题进行建模，依据这个模型，靠自己的直觉去思考，而不是靠公式去思考。
*** 不要忽视直觉的强大能力，多使用直觉去思考。
*** 仔细检查自己头脑里的思想。他翻出自己所有的想法，寻找它们的最初的“来源”，然后审视它们。这种来源有可能是父母，有可能是传统，有可能是学术权威。当他发现某个来源有问题的时候，他就抛弃从这个来源获得所有想法。你可能很难想到，一个不知不觉窜到你头脑里的错误想法，会导致你永远无法发现更好的东西，甚至会毁掉你的一生。――王垠
*** 很多人都把天才和“聪明”混为一谈，以为天才就是非常聪明，头脑特别快，或者记性特别好的人。可是天才往往并不显得聪明，想问题也并不快，而且记不住很多东西。天才的价值并不在于快，而在于他们能想出其他人都想不出来的东西。――王垠
*** 思考能力远比学习能力来得重要，遇到问题要先思考，而不是直接去看答案。看答案只能让你不断重复别人的结论，而无法摒弃别人思想中的糟粕，重新发明答案。
*** 感觉,感受
** 2015/05/19
*** 知北游中林飞对鸠丹媚的爱，是欲望之爱；对海姬的爱，是生活之爱；而对甘柠真的爱，是精神之爱。对鸠丹媚，林飞更多想的是欲望，是想上她；对海姬的爱最接地气，非常像我们生活中常见的情侣，他们会打情骂俏，有时候会不理智，斗嘴吵架并乐此不疲；而对甘柠真说给予的，是源源不断的精神呵护与支持，她懂得林飞真正想要什么，蕙质兰心，完美得不像话。
*** 关于知北游中九重天的设计本身就像是一个精美的艺术品，洛大把这九重天设计出来本身就故意预留了缺陷，最后北境之所以会消亡实际上就是因为这个缺陷。九重天中，除去虚无缥缈的自在天、死亡归宿黄泉天与人妖各自飞升到达的色欲天与灵宝天这几个不怎么重要的天以外，主要还有五重天――低级人妖混杂的红尘天，中级妖所在的魔刹天，中级人所在的清虚天与罗生天，高级人妖所在的吉祥天。注意，中级人有两重天，这也就注定了他们之间必定会纷争不断，因为他们争夺相同的资源，最后这两重天就是因为内斗而被魔刹天钻了空子，北境的灭亡由此开始。而吉祥天自诩为世界警察的角色，凡是哪个地方冒出了头就要打压，这也导致了公子樱与楚度的结盟反抗。其实公子樱与楚度的结盟真的是一步非常精妙的棋，既打压了竞争对手罗生天，又可以进一步合作对抗吉祥天。严格来讲，北境祸乱的最大源头是楚度，第二源头其实是公子樱，林飞仅仅是陪太子读书，根本左右不了局势。虽然楚度作乱的原因是因为林飞，但其实林飞什么也没做，他只是给楚度设置了一下障碍，迫使楚度前进而已。而对于北境的灭亡，其实未必是一种灾祸，虽然现有的世界毁灭了，但没有毁灭，哪有新生，也许毁灭是为了新的未来。带着现在这个世界经验的精英跑到了其他世界，是很有可能创造出一个新的更好的世界出来的。
*** 学习尽可能的先从简单的东西学起，渐渐的再往深入去学，一开始就试图啃精深的知识，只能是学习的又痛苦，学习效果又不好。
** 2015/05/20
*** c#使用export/import属性实现了代码级别的复用，而不是将代码封装成为库以来做代码复用，这是非常的有启发意义的。其实我们真正要复用的只是代码而已，为啥要强行引入库这个概念，然后做一堆乱七八糟的额外的事情呢。
*** 关于程序复用，使用exe是全程序复用，使用dll是函数级复用，使用代码是行级复用，当然一下复制一个函数的代码就跟dll复用差不多了。
** 2015/05/21
*** 元代表开始，代表拥有最少的工具与设计，同时也拥有最大的灵活性。现实生活中元设计非常重要，初期设计应该尽可能的简洁，避免引入错误与复杂性。复杂的特性应该是由那些初期的显然正确没有错误的设计推导出来的而不应该是定义出来的。元设计应该是刚好能解决问题的最小工具集，尽管使用这些基本工具解决起来问题可能会比较麻烦，但只要能够解决就行了。后期才应该进行工具优化，利用这些小工具推导出高级工具，然后比较容易的解决问题。初期就追求高级特性往往导致很多纠缠不清的问题。
*** 很多公司有这样一种现象，他们关心的不是怎么将东西做好，而是需求人员的意见。需求人员怎么说，他们就怎么做，最后做出一个连需求人员都不满意的产品。
*** 全局变量的最根本问题是它的作用域太大了，以致于非常容易导致误用，冲突，逻辑混乱，难以拆分到多线程。其实这并不仅仅是全局变量的问题，任何一个变量，不管是全局变量还是局部变量，只要作用域太大了都会出现这个问题。很多语言的设计虽然可以用“{}”来指明变量的作用域但却不是必须的，这很可能是一个设计失误。
*** 全局变量不支持多线程这是一个耐人寻味的缺陷，也许就是由于这个缺陷，最终导致了面向对象模型在并发上的困境。
*** 实际上，为了避免使用全局变量而使用类里面的静态变量这种做法是没有意义的。这样做这个变量其实依然全局可见，依然有全局变量的各种问题，最多就是加了个类头不容易导致重名错误罢了。
*** TODO 关于函数应不应该使用return提前返回值是一个非常值得思考的问题。
*** 在C++中，想要缩短参数的长度除了将参数组成结构体以外只能用全局变量，而像lisp这样的语言还可以使用let来做到。
*** 一种语言，只要能够完成变量、函数以及函数调用的定义，那么这就是一门完整的语言了。这种语言叫基于lambda演算的语言。
*** “设计软件有两种策略，一是做的非常的简单，以至于明显没有缺陷。二是做的非常的复杂，以至于没有明显的缺陷。” C C.A.R. Hoare
*** 代码即文档，而且是最好的文档。这句话很多人都知道，但这句话还要补充下，代码配合搜索才是最好的文档，想要了解一个类或是一个方法的使用方法，直接用全解决方案搜索，找到使用这个类或方法的位置看别人是怎么使用这个类的，就可以很容易的了解到这个类的使用方法了。
** 2015/05/22
*** 如何查看复杂开源库的代码？复杂的开源库一般代码动辄上百万行，如何最快的找到自己想要查看的部分是个技术活，需要经验与技巧。下面是我总结的比较有用的技巧：
1、不运行，只静态查看代码必然是效率低下的，最好的查看方法就是边运行边查看。
2、堆栈是个好东西，查看代码的时候先想想自己所要查看的部分可能会调用什么函数，然后在那个地方打下断点，然后通过堆栈就可以很容易的查看到自己整个调用流程了。
3、全局的搜索很重要，你想知道某个类或函数的用法，最简单的方法不是网上去搜教程，而是直接在整个工程里面搜索出现这个函数或类的地方，看别人是怎样调用的。可以配合方法2来查看怎么调用的。
4、要动脑子，要做某个功能时，首先需要在脑海对这个功能进行建模，这个功能大概会有哪些东西，需要调用某些函数，可能的函数名称是什么，然后使用方法3。
5、关键部分的类或函数最好把所有的接口都看一下，配合函数上面的注释，如果还不懂的话，很简单，打断点，就可以很容易的知道函数是干嘛的了。
*** 双缓冲的原理实际上非常简单，就是延迟写入罢了。要知道，直接在屏幕上绘制的话绘制一次就是一次IO啊，双缓冲是先不直接绘制到屏幕，而是暂存在内存里面，只有在需要重绘的时候才重新绘制，这样既保证了效率，又保证了不会出现因为窗口移动而导致绘制结果消失的问题了。
*** 缓冲技术实际上是非常重要的一门技术，在实际中真的应用非常广，凡是需要快速访问慢速存储介质中的资源的时候几乎只有唯一一种方法就是使用缓冲，有时甚至是多级缓冲。最快的是寄存器，其次是内存，再次是文件系统，最后是数据库。有个比较简单的原则就是尽量避免在慢速存储介质上进行频繁读写。包括lisp的表格记忆技术实际上也是使用缓存的例子。
门票系统。检验，状态机，链路，事件，API，组装。
酒店 流程定义与资源分配 产品 订单 运营
表管理者 

服务化 粒度 隔离 监控

高可靠性 高可用性

部署 功能 业务 流程进行拆分

按功能进行拆分，实现服务化。

监控以管理

拆分是为了重用

消息的本质只不过是一个代码抽象手段而已。它能够将代码分到很多函数，很多工程里面。

去哪儿网 机票系统 大量使用消息来组织系统

避免重复 避免内耗
使用副作用来解决if else问题
缓存技术不止可以缓存慢介质中的数据，还可以缓存需要计算才能得出结果的数据，这就是记忆技术。
** 2015/05/25
*** 如果开发人员不是产品的用户（这其实也是大多数产品所面临的情况），就无法设身处地为用户去考虑，做出的产品要么容易空想，做出不实用的功能，要么突破不了需求人员的限制，难以做出创造性的新功能。这就是需求的困境。
** 2015/05/26
*** 所有的自动弹窗都必然是系统有一个后台程序或服务在监控着，只要找到了这个程序或服务，关掉它，就可以很容易的删掉很多时候无法删除的文件了。寻找的方法也很简单，在任务管理器里面一个个的寻找对应的exe同名的进程或服务就好了。
*** 在windows的任务管理器中，有个很有用但很容易被忽略的功能，对指定的进程进行调试，如果有进程对应的pdb符号表，是可以用这个方式追踪到代码上去的。也就是说，通过这种方式可以在没有源代码，只有pdb的情况下看到源代码。
*** 为什么一个类最好初始化后才能使用，实际上这相当于给数据打上一个当前无效的标记，为什么必须打标记呢？因为很多操作都有失败的可能，你无法确认赋值操作必然会成功，所以当赋值以后，如果类的值依然为初始值，就说明这个数据是无效的，这是一种隐式的标记手段。当然，有时候为了其他目的，可以直接在类里面设置一个字段来表示数据是否有效，其实是一样的。
*** 何为解释器？解释器实际上就是当面对一个东西的时候我们应该做出什么样的反应的抽象。具体表现在编程中的解释器实际上就是一个字符串对应一个操作这样一种行为，用代码表示起来大致是：
if(expr == "xxx") do fn1();else do fn2();
这就是解释器的基本模型。
*** 实际上，通用的函数都是解释器模式的函数，因为通用的函数必然针对各种不同的输入做出不同的处理，而这其实就是解释器了。要给某个软件提供无与伦比的拓展性非常简单，你只需要尽可能的将这个软件的接口公开出来，然后再提供一个这个软件可以调用的解释器接口函数就可以了。
** 2015/05/27
*** 关于接口的重要性无论怎么强调都不为过，两个东西之间如何才能协调在一起工作？答案就是接口，接口实际上是基于两个东西的设计而作的一个折衷，目的是为了用最小的代价使得两个东西能够共存于一个系统，协调工作。典型的例子是lisp通过ffi调用c函数。两个东西各自的设计越多，协调起来就越困难，就越难以设计出通信的接口，所以应该保持简单，这样才好使用接口来对接。典型的例子就是dotspatial不使用gdal库而自己设计了一个读写shp的库。
*** 求知应该建立起自己的模型，而不是世界的模型。我们身处的世界太复杂，各种乱七八糟的概念，乱七八糟的模型掺杂在一起，关键是很多时候这些模型本身就是互相冲突的。你如果都强行逼自己去适应的话，必定会疲于奔命，到最后一事无成。你应该建立起自己的模型，然后学到新知识时，把他往自己的模型里面去填，如果不合适就舍弃。这样就能渐渐形成自己的理论体系，走得更远。
*** 实际上所谓的lazy evaluation与eager evaluation只不过是一个求值顺序的问题，前者叫call-by-need序求值，后者叫call-by-value求值序，就这么简单。
*** 模式匹配与递归，解释器就是这么简单。只要掌握了这两点，你就掌握了解释器。
*** 在解释之前，还有个语法分析的过程，就是把字符串解释成为AST语法树，也就是各个基本语法元素的过程。很多语言的语法分析非常的复杂，但其实语法分析其实很多时候并没有必要，其实通过list或json,xml这种格式，语法分析直接就可以跳过去，直接进入真正关键的部分语法解析，也就是解释器的编写。
*** 惰性求值的实现原理实际上就是反向求值，先算最后需要返回的东西，然后再从这些东西中查找那些东西还没有被求值，需要被求值，从而渐渐的求出结果。它不同于大多数语言中所采用的及早求值，能够规避部分及早求值的缺陷，但也会导致新的问题，必须谨慎使用。
*** 何为人工智能（AI）？实际上非常简单，就是一个模式识别的过程。你需要知道自己当前处于一种什么情况，然后针对这种情况作出正常人的反应，这就是人工智能。比如dota的AI，如果对面无人抱团，你只有一个人，那么你应该做的情况就是等待队友，而不是直接冲上去送；相反，如果你们这边人数优势，那么显然应该冲而不是等对面都到齐了；同时，如果你发现对面地图上的人都不在了，那么你就应该也相应的猥琐一点。等等这些就是正常打dota人的一些常识性的东西，如果你能做到与人一样的反应，那么你就叫具有了智能。
** 2015/05/28
*** sql语句可以说是一种非常有趣的语言，虽然不能适用于通用编程，但却能为编程带来不少的新鲜想法。
*** 学会从计算模型上来理解问题，这比直接通过做题，通过单纯看书来理解效果要好的多。
*** sql语句的基本语法还是很简单的，使用where与and来作为filter；from来作为enummrator;select作为accmulator；order by ... asc desc来对数据做最后的处理。共同组成了一个很简答的编程模型。
*** group by必须配合sql函数才能体现出它的作用，如果不这样的话相当于只进行单纯的重复筛选，没有任何意义。
** 2015/05/29
*** MFC程序其实跟普通的c++程序没有什么两样，它只不过是定义了一套代码编写的格式，也就是以消息映射的方式来组织代码，其实还是非常简单清晰的。
*** F10真乃调试神器，先从构造函数开始，寻找主要的功能代码，到达到自己想要看的位置的时候用F11去看实现细节，这样就找到了自己真正想看的代码，非常方便。
*** 实际上编程所实现的行为与他的代码是有一一对应关系的，我们通过代码这种格式来操作工具的行为。由此实际上可以推广开去，代码也许并不是唯一的可以操作工具行为的东西，通过我们的手来操作工具，使得工具实现它的行为，这又何尝不能说是一种编程呢。所以，编程的本质实际上就是表达，而表达的手段可以多种多样，之所以选择使用编程语言来表达是因为计算机比较容易理解这种格式，我们完全可以通过其他的手段比如动作来编程。
*** c++有一个非常大的缺陷就是――他根本不知道自己是什么类型。一旦程序运行起来了，一个对象要想知道自己是什么类型可不容易。因为对C++来说，运行起来的每个对象只是一串字节流而已，它只能知道这个对象字节流的长度，甚至连字节流的长度都不知道，因为对内存不受它自己的掌控。即使通过计算，它也无法知道自己的类型，因为不同类型的字节流长度可能是一样的。
** 2015/05/30
*** 实际上在编程时，我们花了很多的时间在做着解释器这一类无聊的事，有时是自己写，有时是调用别人写好的库。这种事被重复的做了一遍又一遍，非常无聊，其深层的原因在于我们的操作系统本身只能传输无格式的字符串数据。这种设计虽然非常简单，但同时也放任了各种乱七八糟的格式的横行，我们需要各种乱七八糟的库来去去操作这些数据，非常的麻烦。可以说，我们几乎一半的编程时间是花费在无意义的解析数据，获取数据的阶段的。而其实编程的重点不应该在解释数据，而应该是在处理数据，这就造成了编程上的巨大浪费。解决的方法非常简单，在操作系统中或是我们自己添加结构化数据的支持，以统一的格式来进行数据通信，这样就能避开解析工作，让我们专注于编程本身了。
*** 时间才是最大的坏人，古剑奇谭的剧情设定实际上很多时候充分展现了这一点。根本没有坏人，所有的坏人都是被时间，被残酷的现实逼出来的。仙剑四的玄霄是这样，古剑一的欧阳少恭是这样，古剑二的沈夜也是如此。这就越发凸显了背景设定的重要性，但光有好的背景设定还不行，一个精彩绝伦的游戏要能够在揭示出了所有的背景以后依然能够有比较长的高潮，这才是一个好的设定。
    在这方面，花千骨是设计的比较好的，一波又一波的高潮保证能把你虐的死去活来。相比之下，古剑做的还不够，无论是仙剑四，还是古剑一，古剑二都存在设定了一个很好的背景，高潮却太短的问题。没有最后一来一往的精彩博弈，这使得它虽能触动玩家，但把玩家虐的死去活来，无法忘记，却还是差了点。
*** 实际上古剑是超越仙剑那么一点的，无论是剧情还是玩法，仙剑只是靠着老牌子遗留下来的福泽才得以获得和古剑奇谭分庭抗礼的地位的。
解析器 解释器 结构化数据
** 2015/05/31
*** 打电话与直接聊QQ的差别，打电话会不断的强迫不断的思考，不断的去寻找新的话题。很多东西无法深思熟虑，想清楚了再去回答
