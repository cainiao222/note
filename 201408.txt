* 2014/08
** 2014/08/01
*** 为什么要推出面向对象，还是有其道理的。面向对象就是用来组织面向过程中的各种各样千奇百怪的函数，使之变得结构清晰，从而大大加强函数的可读性，可维护性的。是用来解决面向过程的种种缺陷的，其实就是对面向过程中写出的函数的一个分类。无非就是对复杂对象的一个分类方法而已，没什么神秘的。由面向过程转化为面向对象思维由此看来也没有什么难的，确实，在函数比较少时没有分类的必要，就直接用面向过程写程序就足够了。但如果函数太多了，在寻找函数时就是一个很大的困难，这是就要使用面向对象了，这就是面向过程与面向对象的分界，如此简单。很容易碰到刚好卡在要分类与不分类的分界线上，分类与不分类都差不多，此时采用哪种方法完全取决于个人喜好，爱分不分，并不是什么时候都要使用面向对象的，不要被洗脑了。
*** 从今天起，我的编程思维终于开始转向面向对象了，哈哈哈哈。
*** 什么时候使用虚函数，在函数的实现因类而异的时候就应该使用虚函数，如果父类可以尝试着给该函数一个大致的实现，就可以用虚函数，然后实现之。如果父类不给实现，就应该给这个函数为纯虚函数。
*** 如果一个类完全没有虚函数，那么这个类其实意义不大，还不如用面向过程。如果全是虚函数，那么这个类就是接口。一般比较正常的类会含有几个实函数，用来写实现已经可以定下来不会再改变的函数。几个虚函数，用来写实现随子类变化的函数，这两类函数加起来就是面向对象，面向类思想的核心。
** 2014/08/04
*** 当一个类继承某个类时，只有父类中的虚函数是需要被重写的方法，非虚函数不用管。
*** 面向对象最大的优点是可以使代码的组织比较有条理，提高可读性，可维护性。但它也有一个很大的缺陷，就是代码的可重用性不如面向过程，因为成员函数的很多参数被隐式地包含在了类的成员变量里面，想重复使用就得提取出这些东西了，这有时会比较麻烦。为了克服这一缺点，比较好的做法有两种。一是尽量少提取参数到成员变量，除非真的是需要在所有成员函数之间共享的变量。二是对确实需要经常被重复使用的函数，将其写在另外的工具函数(面向过程)中，不要写在类中。
*** 面向过程与面向对象应该混合起来使用，对于经常需要被维护但却不怎么会被重复使用的函数需要使用面向对象，而对于经常需要被重复利用的函数应该使用面向过程。这两种方法混用才能写出综合素质最好的代码。
*** 关于函数类型（公有，私有以及保护）的划分，公有函数是提供给外部，给其他类调用的函数，是外部接口，这一类函数要比较规范，可以修改实现但不能修改声明。私有函数是类自己的工具函数，是不对外提供的，这类函数比较灵活，可以随意修改声明与实现。保护函数是提供给本类以及其子类使用的函数，也是不对外提供但是对子类提供。越是靠近程序员一方就越灵活，所以应该尽可能地将函数定义为私有函数，不行就定义为保护函数，再不行才定义为公有函数。
*** 智能指针这个东西看似很神秘，其实很简单。他只是将delete的代码转移到了智能指针这一工具类里面。这样看起来比较好看，而且不容易忘记。
** 2014/08/05
*** send,recv系列与read,write系列是两套IO函数，是两种理解IO的方式。前者没有缓冲的机制，而后者有缓冲。对于简单的IO，直接使用前一套就够了，但一旦IO的情况复杂之后，缓冲就变得越来越有必要了。因为IO实际上是两种设备之间的数据交换（内存与硬盘或网卡），它们之间的速度不一致这一问题是客观存在的，必须要使用缓冲机制才能保证高效的数据交换，更为关键的是缓冲机制实际上提供了一个抽象层，将数据的发送给隐藏了起来，用户只需关注本设备上的读写，当缓冲区满时，数据会自动写入到另一设备，从而大大简化读写逻辑。
*** 一个函数如果很短且不调用其它函数最好定义为内联函数。
*** 异常必须被处理，而返回值可以不处理。这就是异常与返回值最大的区别了，也是决定你是使用异常还是返回值的主要考量点。如果你觉得某个错误可处理可不处理就使用返回值，如果必须被处理就要使用异常。
*** c++构造对象的两种方法，一种是直接调用构造函数，另一种是“new 构造函数()”前者构造的是栈对象，离开作用域自动析构，后者构造的是堆对象，需要自己手动调用delete。两者是不同的。
** 2014/08/06
*** 其实Windows实现的标准函数库的代码并不难懂，只不过是多了几套规则，比如空的标示符啊，不想外部使用的函数加_啊，这些子类的，知道了这些规则后再来看就没什么难懂的了。不要在意这些细节，忽略掉看类的接口就行了。
*** 为什么标准函数库里面的函数如此复杂，因为它面对的情况更复杂，它为了处理复杂的情况必须写的如此复杂。
** 2014/08/07
*** 数组与链表相比，数组可以随机寻址，因而查找速度比较快。之所以拥有这一特性是因为数组是定长的，所以实际上定长是随机寻址的关键，同理推导到shp上，shp的每一项记录也是定长的，因此shp也是可以随机寻址且拥有较高的效率的。
** 2014/08/08
*** 函数的返回值定义为bool型仅仅适合与处理函数调用要么成功，要么失败的简单情况。面对比较复杂的，比如读入了多少个点等函数，bool的返回值回使得函数的调用不好控制，给自己造成麻烦，简单的情况还行，复杂点的很容易给自己倒找麻烦。
*** 迭代器这一概念实际上应该换一种叫法也许好理解些————顺序访问器。每当你试图顺序遍历一个集合是都应该定义一个这样的访问器。如果你只是用vector这样元素定长的数组，那么你可以忽略它，但只要你想要使用元素变长的数组，你就不能忽略它了。
** 2014/08/11
*** 抽取变化的部分，提取不变的部分组成循环，简化代码。
** 2014/08/12
*** C++语言里面数据与代码的隔阂客观存在，无法回避。反射实际上就是一个部分打破数据与代码隔阂的方法，其他语言像C#,java可以借助于这一技术部分回避这一问题，但C++不行。但其实反射并不是打破这一隔阂的唯一方法，还有更好的方法是无需打破，不要将数据写成代码就行了，比如当读入一个表时不要试图将每一个表项读入到一个表对象中，这样一开始就将表项给定死了，应该将表项信息存放在一个数组中，当需要操作表时去操作这些表信息，而不是去操作表对象，这样代码一直在操作信息，并不需要操作代码，就可以实现动态对象读写了。
** 2014/08/15
*** 一开始就使用类来处理业务，来实现将函数分类。将定死的流程写成public函数，自己的实现逻辑表示成private函数，将要留给子类使用的属性与方法定义为protected，要留给子类实现的属性与方法定义为virtual。也就是说public是留给外部的接口，protected是留给子类的接口，private是具体实现。
*** 人会出错，但机器不会错。一般我们写程序的输入来自于人或者机器。如果来自于人，出错的可能性会很大，经常要考虑各种稀奇古怪的输入，非常痛苦。如果来自于机器，那就好说多了，机器生成的数据会非常规整，都不用考虑什么古怪输入。
** 2014/08/17
*** 东西做出来是给人用的，如果你自己都用的不顺手，那怎么还指望别人好好地去用呢。
*** 我对自己的工作定位————我是做数据的。何为做数据？其实，软件都有两套逻辑，数据使用逻辑与数据创造逻辑。数据使用逻辑可以定义并使用数据，但却不能创造出它们。需要额外的数据创造逻辑来做，然后提供给数据使用逻辑，才能实现软件的功能。这两套逻辑所有软件都有，只不过有些软件的难点在于数据创造逻辑，比如点子地图，有的软件的难点在于数据使用逻辑，比如即时聊天，有的软件两者都是难点，比如搜索引擎。这实际上是软件的一个真理，就像宿命一样无法逃避。而我的工作就是定义并实现数据创造逻辑，为数据使用逻辑打下坚实的基础。
*** 我对自己的性格定位————首先要相信每个人都是不完美的，都有自己的长处与短板。正是因为现实的不完美才需要我们去追求理想中的那个完美。但最求完美不只是一个简简单单的口号，是有合适的方法的。与其花费时间，努力去追平别人的个性优势，自己折磨自己，不如把时间花在提升自己个性中的闪光点上面。与其做一个各个方面都一般的普通人，不如做个有几项突出特点的牛人。就像我自己，我性格相对内向，不擅交际，由此而导致的附加性格弱点，不够自信，有点畏畏缩缩。但正是因为性格比较内敛，我花在思考上的时间比别人多得多，由此我也获得了一个独特的性格优势————绝佳的思考能力，看待问题比别人客观全面深刻得多。这一优势已渐渐萌芽，成为我为之自豪的一个性格强项，花费时间继续加强我的这一个性优势才是正确道路。要始终相信，补短不如修长。当有朝一日长处已经发展到别人已经高山仰止的地步的时候，性格弱点的并发症肯定也会随之消失不见的。个性的发展实际上遵循的是反木桶原理，有自己的突出优点才能赢。
*** 宏与函数相比强大之处在于宏能够跳出附加在函数上的一些规定限制，比如先对参数求值，检查上下文语义等限制，从而写出更加灵活的程序。宏是用来写函数的，而函数是用来处理数据的，宏是用来写函数的超级函数，能够跳出函数的限制写出非常灵活的函数。实际上可以把宏看成是更底层的东西，函数只不过是被宏实现出来的一个简单易用的小工具而已，通过这个小工具，常见的问题可以被很容易的解决，但碰到一些特殊的情况，函数就无能为力了，就得靠宏来定义新的工具来处理这些特殊情况了。
** 2014/08/18
*** main的本质也许就是一个回调，上层通过回调函数给下层留出调用接口并调用回调函数，下层直接实现了以后就可以无缝嵌入到上层，实现软件的功能。这一现象非常常见，比如常见的onXXX函数基本都是回调函数。
*** vs将临时文件设置到其他位置可以大大缩小程序的体积，将Intermediate Directory设置到其他位置可以避免生成项目Debug,Release,将Fallback Location设置到其他位置可以避免生成ipch,sdf。通过这两个选项，就不会有其他东西来污染代码了。
** 2014/08/19
*** 思考指引代码编写，反过来代码也能指引思考，良好的代码结构就是有这个功效。当你嗅到代码中的某些坏味道并且知道按照代码规范的标准此处应该怎样修改时，实际上这一改变会指引你重新审视代码逻辑，从而优化处理流程。最常见的坏味道就是代码重复了。
*** 要想传递参数给某个函数只有两种方法，一种是通过函数参数，另一种就是通过全局变量，注意类成员是类的全局变量。通过函数参数传递的方式能够减小函数间的耦合关系，但缺点是当调用层次关系复杂以后每一层都要通过参数传递，非常不利于代码的整洁。比如如果a调用b,b调用c，c调用d，要想通过a给d传递参数，必须将参数先传给b，在传给c，最后才能传递给d，这显然非常不好。通过普通全局变量传显然也不好，但通过类的全局变量来传是可以的，既保持了代码的整洁性，又不会破坏面向对象。
*** 一个设计良好的程序代码里面不应该出现数据，而只应该出现针对数据的处理逻辑。因为数据的值会经常改变，而数据的处理逻辑不会改变。
** 2014/08/20
*** 代码调整都是由优化完成进化。优化是小的代码实现的改变，而进化是大的代码逻辑结构的调整，往往那些小调整最后留下的难以调整的遗留部分就是需要进化的信号。在代码调整的过程中，新的问题不断涌现，新的概念被不断地被创造或引入以简化整体逻辑，就是这种不断的调整完成最终进化。再由优化完成进化的过程中，往往可执行的中间成果非常重要，它能降低这一过程的复杂度，而且能得到这一过程的很多中间信息，从而辅助进化的进行。这实际上也是一种编程的方法————交互式编程。典型的例子就是lisp编程。
*** 模板实际上就是一种类型推导机制。而推导实现的原理就是替换，通过调用时所给出的类型替换到代码中模板参数的位置，这就是所谓的类型推导。这一过程是在编译期完成的，因此大量使用模板会延长编译时间。
*** c++语言经过这么多年的发展，简简单单的生成最终的静态程序这种一维语言的发展方式已经不能够满足现实的需要。自从模板这一机制出现以后，c++就正式开始走在了根据具体调用情况推导参数类型的二维语言的道路上。很多新特性的实现实际上都是借助于模板这一机制，直接用语言自己来实现的。
** 2014/08/21
*** 谷歌的PageRank算法是基于访问数量以及页面质量来对网页重要性进行排名的算法，其基本原理就是传递权重，权重越大的网页越重要，排名越靠前。这实际上是一种基于群体选择的重要性算法排名，可以应用的领域绝不只是计算网页重要性一种，还可以用于文学作品，体育运动，神经科学，癌症研究，交通网络等多个领域。
*** 搜索引擎的基本框架————建库，查找，排序。建库主要是建立网页地址库以及关键字与页面对应的库（倒排索引）。查找是根据倒排索引的关键字查找符合要求的网页。排序是网页重要性排名（PageRank）。所有搜索引擎都无法逃开此规律。其实排名才是核心，常见的排名算法有不排名（结果少时用），基于检索词（无法抵御针对性攻击），PageRank排名。
*** 当函数中途调用失败而导致处理无法继续时，使用异常机制来强制中止程序执行比使用返回值来寄希望与让程序员自己去处理错误要好的多，虽然这样会导致效率的损失。
** 2014/08/22
*** 为什么map，set里面不能有重复的元素，因为map，set的实现是基于二叉树（红黑树）的,它是根据key来决定元素的放置位置的，key一样就意味着放置位置一样，这显然是不行的。总之，是由于值决定放置位置这一机制导致了这个问题，而对于其他的像vector，list等容器，其位置有另外的逻辑，跟存放的值无关，所以即使存放相同的元素也不会有问题。
*** 哈希实际上就是一种由键决定存放位置的机制，这种机制需要一种算法来实现只要键相同，其存放位置必定一样，实际上就是要一个在定义域内位置值不重复的哈希函数。
*** 工具写完了一定要先调试运行一遍，看看执行流程正不正确，切忌先运行看结果，如果结果无问题就跳过调试，因为直接看结果你很难发现小问题，而调试运行却可以。
*** 一般的编程语言，虽然能处理各种各样的数据，但却不能处理自己（代码），反射的出现部分解决了这一问题，使得程序能够以把对象本身当成数据去处理。但这一解决方案并不完美，调用形式比较奇怪。真是基于这一思路，lisp设计了宏，这一专门用来处理代码的工具。
*** 人的思维比较善于解决低维度的问题，一般一维比较容易，二维就有点难了，三维及以上的就不大可能一次想出来了。当碰到高维度的问题时，先将高维度的问题转化为低维度的问题就比较容易了。比如要从一组数中找出重复次数最多的数，如果先将数据排序，问题就变成一维的，很容易解决了。
*** 文件编码格式无非定长与变长两种，定长字段的优势不止在于可以随机存取，还有随时可以修改某一格的数据，不像变长还要移动后面的数据。所以定长的相当与静态数组，变长的相当与链表。定长字段随机增删改效率很高，虽然比较浪费空间。定长字段的数据格式尽量不要存放内容长度变动很大的字段，比如描述字段，因为实在太浪费空间。
** 2014/08/25
*** 关于c++的类型转换，它是基于实际代码编写需要进行类型转换的情形进行考量而设计了四种看上去好像毫无关系的类型转换static_cast,const_cast,reinterpret_cast,dynamic_cast，实际代码编写过程中，我们往往碰到需要转型的情形就是这四种。它是根据专门设计的，相比较传统的c语言强制转型不止拥有更好的代码可读性，而且可以获得更加精细的控制保证转换的正常进行。
*** c++语言的设计一直就是头疼医头，脚疼医脚的设计方式，拥有很多针对具体简单情况很实用的设计，但却缺乏一种高层设计，缺乏整体的结构。这样做下来的好处是通过这些繁杂的小特性的堆积能够实现很强大的功能，但缺点也同样明显，复杂难学，特性容易误用，写出优秀代码太需要靠优秀的程序员了。
*** com控件（包括ocx控件）实现将控件与主控程序解耦的方式就是将注册信息存放在注册表这一第三方公共资源上来实现的。
** 2014/08/26
*** mouse_event函数与keybd_event函数分别可以用来模拟产生鼠标与键盘事件给其它程序去处理，它可以用代码模拟消息的源头，在不知道其它程序的消息实现的情况下给其他程序发送消息，实现程序控制。
*** 其实所谓的可执行文件不过就是一堆函数与数据的集合包，它内部其实是没有对象概念的，对于对象，它会将对象的属性与方法全部抽出来放到一起。了解了这一点，其实可执行文件一点也不复杂。
*** 其实操作系统就是一个最大的插件式程序运行平台。
*** 钩子机制实际上是独立于窗口程序之外的，属于windows api的东西，不过使用钩子机制有个前提就是必须要有消息传递。你可以在控制台中使用钩子函数，但必须配上处理消息的语句钩子才能起作用。
*** hook有什么作用？hook的作用其实就是消息处理，与mouse_event,keybd函数产生消息不同，hook能够处理这些产生的消息。这样一个生产，一个消费，共同达到自给自足的完美平衡。
*** 想致富，先修路。这句在传统上非常正确的话当网络时代到来时受到了冲击。网络实际上就是一个““路”，它打通了富裕地区与贫困地区的隔阂，贫困地区的优质廉价资源能够通过这种方式跟富裕地区贸易，大大推动共同富裕。只要有公路以及完善的物流，共同富裕绝对不是空话。
*** 编译器其实根本不会管.h文件，.h文件只有被包含到.cpp文件中编译器才会去编译。另外，声明可以有多次但实现只能有一次，而且必须先声明再实现才行。可以直接在.cpp文件中写声明来避开包含.h头文件。
*** 动态库里面的lib文件到底是什么？实际上它只是一个所有导出符号的地址表，它存储了地址所以当调用时就不再需要GetProcAddress这种函数来查找函数的地址了，这样就简化了代码。
** 2014/08/27
*** hwnd与hmodule(hinstance)的区别：hwnd是内核对象，通常是控件标示，一个窗口程序可以有很多个控件；hmodule是程序标示，一个程序只能有一个。
*** windows并不会主动向程序发送消息，比如控制台程序是没有消息的。只有在应用程序调用了GetMessage这个函数主动向windows请求消息，windows才会将消息发送给应用程序。所以，它并不会主动推消息给应用程序，只有应用程序来拉消息。
*** wParam,lParam这两个参数实际上是一种拓展的通信机制，是一个参数的容器，可以存放各种各样的参数。函数的调用者将参数放置在这两个参数里面传递给被调用者。进一步引申，其实void *这种指针就是一种通信机制，用来接收接收任意类型的数据。
*** dll其实只是将代码转移了一个位置，将原本很大的程序分成了一个一个部分，这种分离的设计非常有利于代码的拓展与维护，可以说是编码的一个突破性进步。它的使用方法也跟源码复用差不多，只不过源码复用需要包含的是头文件与源文件，而dll需要的是头文件与lib文件。不管哪一种复用方式，都要遵循先声明后调用的原则，不管是使用头文件声明还是在源码里面直接写函数头声明。
*** 控制台程序没有自己的窗口，无法接受消息，GetMessage永远获取不到消息。想要获取消息必须用CreateWindow创建一个窗口才能获取到消息。
** 2014/08/29
*** 所有的数据都放在文件。