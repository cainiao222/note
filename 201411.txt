* 2014/11
** 2014/11/03
*** std::function实际上相当于给函数预留了一个槽。这样相比与传统使用接口函数，通过类继承来实现接口的方式就多了点灵活性，允许程序员在运行期将函数的实现委托给不同的函数，拜托继承依赖，大大提高了程序的重用性。qt5信号槽的实现多半就是采用的这种方式。
*** 通过function与bind，同一个类的不同对象可以委托给不同的实现，从而实现不同的行为。这样相当于跳出了类的限制，类不再是一堆函数的封装，而仅仅是函数声明的封装，其实现并不被规定死，可以在运行期灵活地修改实现。
*** 最近通过频繁的思考，已隐隐把握住编程的核心——面向对象。但不同与传统的以继承封装多态为核心的面向对象，我自己的面向对象必须是遵守的以下几个原则：
1） 封装是基本，将程序抽象成一个个基本的物件是永远不能丢弃的最基本的原则。
2） 降低耦合，解耦。继承与多态耦合性太强，尽量少用甚至不用。尽量将程序抽象成更多的互不相关的物件。使用一个对象时不需要引入附加的多余对象。
3） 依靠对象之间的通信来完成程序的功能，通信的方式有通过公用对象、通过共同的接口协议这两种。比如通过文件，剪切板，共享内存，将要通信的几个对象放在一个类等属于前者；通过网络协议，分层架构间通信等属于后者。
** 2014/11/04
*** 递归好像就是专门为树形结构而准备的，一个函数里面如果用到了递归，那么它处理的数据就很有可能就是树形结构的。
*** (start-process "abc" "*scratch*" "ping" "www.baidu.com")
异步创建一个名为abc的子进程并在这个进程中调用ping命令，参数为百度网址，并将结果输出在*scratch*缓冲区上。
*** 使用lisp中声明局部变量的符号let的时候要注意：尽可能地缩小局部变量的作用域，也就是能够用反括号结束变量的作用域的时候就尽早结束，这样不至于使代码的层次很多，影响可读性。
*** 其实很多时候我们在乱用局部变量。变量使用完毕以后函数并没有结束，那么这个变量将在函数的后续部分持续存在，容易造成命名冲突、代码耦合、难以拆分到多机多线程等一系列的问题。当然，在c++中我们可以利用花括号来规避这个问题，最怕的是没有意识去规避这个问题。始终要记住，能尽早结束变量的作用域就尽早结束。
*** 实际上尽早结束变量作用域还可以推广到指针所指向的资源上面去，一旦这个资源不再需要了，就应该马上释放掉，不要把所有的资源都放放到最后的析构函数里面去释放，甚至根本不释放。
*** 避免过早优化代码，前期代码可以写的烂点，但要保证效率，以最快的速度完成任务就行，然后等系统投入使用了，就是优化的时候了。
*** lisp代码层次越多，越难以被理解，一般不要超过4层，如果层次过多，就要考虑怎样减少层次了。层次越多越难以被理解。
** 2014/11/06
*** 语言所提供的功能越多，使用起这门语言起来越方便，但同时，学习起这门语言所需要花费的时间精力也会越多，而且功能间组合起来也会越复杂。
*** 关于释放资源的顺序，实际上是有讲究的，如果资源B依赖与资源A却先释放了A，那么释放B时就会因为使用了已经不存在的A资源而出错。一般比较好的系习惯是使用堆栈来管理这一堆资源，后开辟的资源先释放，这样就能保证先开辟的资源不会因为与后开辟的资源有依赖而导致后开辟的资源释放时出错了。
*** 资源之间的依赖关系，也就是类之间的依赖关系会给资源释放带来麻烦。意识到了这个问题才能有针对性地避免这一问题。
*** 程序崩溃大部分时候是访问到了无法访问的内存而导致的。可能是已经被释放了，可能是根本还没有被开辟，也可能由于数据结构的改变使得原来的内存地址失效。不管是哪种原因，一旦程序异常崩溃，要多从内存上面找原因。
*** 每次开辟一个资源是要留意你这个资源想用多久。如果只是临时性的小资源，使用栈内存会好点，开辟释放都很快，不需要指针。而如果是全局性的或是长期性的，使用堆内存，也就是使用指针与new会好点，管理起来更灵活。
*** 要对资源有细微灵活的掌控，一举一动，尽显合适。
*** bind实际上起的是一个桥梁与转化的作用，它能将类中的成员函数或者普通的函数转化为函数对象，这种转化的最大作用是委托，代行职责。将一个类的某些函数的代码实现委托给其他的函数（类函数或普通函数）去实现，从而可以专注于实现框架功能。或者是从被委托者的角度出发抽象出一个方法序列去实现某个功能。总之，它从函数的角度出发重新组装了类，实现了类之间既连接在了一起，又保持了弱依赖关系。
*** 撤销与重做实现：核心实现就是保存对象状态，用老的对象状态替代新对象的状态。具体一点实际上涉及到两种情况，运算以及构造。如果是运算的撤销的话，直接进行反算就行了，比如加变减，乘变除。如果是构造则情况就有点不同了，这种情况需要保存所有对象的状态
*** 关于撤销与重做的实现有两种方式：一种是保存每一步操作的所有对象状态，撤销时重新整体渲染上一遍就行了。这种方法不需要用户去实现每个方法的redo与undo方法，实现起来比较简单，缺点是当对象比较多时重新渲染的成本会高到无法忍受，而且实现起来典型的特点就是所有的对象都会闪烁一遍。另一种方法是实现几种基本操作的redo与undo方法，并用一个列表记录下每一步操作的类型，当撤销时去调用相应操作的redo与undo方法，这种方法在对象多时就不会有慢的缺陷了，只是实现起来稍微复杂一点。一般通用的撤销方法会采用后者。
*** 函数或变量先使用，后实现，不需要提前声明这其实是一种非常有用的特性。可以在无需知道函数是否存在的情况下调用函数，而具体的函数实现推迟到后面去实现。尽可能地延后了实现的时间，提高了编程的灵活性。
*** 即使对象析构了，在对象中手动开辟的内存空间也不会被析构，这种情况会产生内存泄露，必须被避免。
*** 公司福利：技术分享、周末水果、自主编程、集体电影、旅游、集体玩。
*** 执行与输出的同步问题。
*** 3D打印技术：
1） 复杂性免费。
2） 使用组装来制造工具的时代将一去不复返。即使是结构很复杂的情况下依然可以快速完成。部件越多，组装误差越大，不管工艺多先进。
3） 免费制作生活用品。
4） 任何材料均可用来打印，包括使用活体细胞打印。
5） 3D打印+人工智能，自动化地制作工具。自制造，自进化。
6） 设计到生产零延时。
7) 做出很多组装无法完成的东西。
8） 随时随地制造。
9） 不再有制造垃圾。
10） 可复制。
11） 云制造。
12） 规模效应不再存在。
13） 超越现实，打印新材料。
*** 第一次工业革命——蒸汽机——动力成本趋近于零。 
第二次工业革命——计算机——计算成本趋近于零。
——电力——能源成本。
第三次工业革命——信息技术——通信成本趋近于零。
第四次工业革命——3D打印——制造成本趋近与零。
*** 当人工智能遭遇互联网，从此人工智能插上了翅膀，瞬间突飞猛进。
*** 上下文环境必不可少。对于推理很有帮助。
*** 实时大数据分析。
*** 利用互联网帮助人思考。
** 2014/11/08
*** 对未来有清晰的规划几乎是无用的，最奇妙的事情通常是突然发生并且无人注意的。——尼葛洛庞帝
*** 为自己编程，顺便服务别人。
** 2014/11/09
*** 电脑将作为人脑的延伸，帮人脑去解决某些人脑由于天然缺陷所难以解决的问题。这是一个将被随身携带的大脑，即将帮助人们思考，影响人们的行为。
** 2014/11/10
*** 程序被分成的块越多，执行效率就越低。这种分块包括分成几个程序，几个层次，几个类，几个函数，甚至连分成磁盘文件与内存文件等都算在内。因为分的块越多，块与块之间的通信成本就会越高，需要越多的临时变量共享状态，越多的计算来维护通信格式的统一，这些会严重影响效率。但同时，分块能够减少重复代码，提升代码的可维护性。这一点来说，分块有时必要的。既要效率，又要可维护性。编程本来就处在这样一种纠结的环境中。
*** dbf是一种表格格式，而bmp是一种网格格式。前者每一行的各个格之间的大小一般不一致，但bmp每一格的大小是必然一样的，都为3个字节。
*** BOM是计算机为了区分一个文本文件到底是属于unicode的哪一种编码方式而自动在文件头添加的几个字节。对于unicode编码，BOM是FF FE,对于unicode big endian编码，bom是fe ff,对于utf-8编码，bom是ef bb bf。
*** unicode有两套标准：ucs-2与ucs-4，现在一般使用的是ucs-2,它采用两个字节来进行字符编码，一共可以编码65535个字符，基本可以容纳所有的欧美字符和绝大部分的亚洲字符，但很多比较偏的语言无法容纳。
*** 使用qt编程时，千万不要使用std::string，否则中文乱码问题会坑死你。
*** 人机交互其实也是一个比较复杂的问题。面对这一问题，首先要明确：人机交互就是由人和机器一起互相分工合作，共同去完成一件事的过程。所以，人机交互具体的过程是——首先搞清楚，完成这件事需要做哪些事。然后对这些事进行分类，哪些应该交由计算机来做，哪些需要由人来做。如果需要由人来做，应该怎么做。最后就是定义好交互接口，或者说协议，通过拖拽？滑动？选择？具体哪些事交给人来做，那些事交给计算机来做，要针对人做与计算机做的不同特点来分。计算机最擅长的就是重复，而人最讨厌的就是重复。计算机最擅长的就是计算，而人最讨厌计算。人最大的特点就是灵活，人非常善于将不同的东西组合起来，共同完成某个任务，这种灵活性是计算机望尘莫及的。最典型的例子就是编程，交由计算机来做就是个非常难的问题。同时，人还可以作为计算机处理所疏漏地方的一个补充，处理某些计算机处理中的疏漏部分。计算机善于处理比较规范的数据，想要计算机做更多的事，就需要更规范的数据格式来做支撑，否则就只能由人来手工做了。人与计算机就是在这种博弈中共同前进的。
*** 常见交互情形：
1） 利用各种工具反复修改某一数据，典型实例：photoshop,街景数据处理平台。这种情形的对象特点比较浓一点，就是反复修改某个对象的状态。适合于一界面显示数据，各工具修改数据。
2） 一步步地完成某件事。典型实例：软件安装，功能向导。这种情形的过程特点比较浓一点。适合于多界面跳转，一步步完成这件事。
总结起来就是要么分类，要么分步。做任何事只有这两种方法。
*** 高效学习的关键就是要构建知识网络，而构建知识网络的方法就是类比。
*** 构建计算机的基础是门电路。通过门电路的复杂组合最后构成了我们现在的信息世界。
*** 迭代器接口
** 2014/11/13
*** 不能否认注释的作用，但注释在大多数时候并不是最终的良好解决方案，而是中间解决方案。有时候几句代码暂处于测试阶段，并不适合于直接孤立成函数，这是用注释来说明这几句代码是合适的，到以后当代码稳定下来以后再将注释去掉，移动代码到单独的函数中才是正确的做法。
*** 分类了才能有特性，要发明一个理论，首先就要对事物进行分类，然后对某些类别，才会有特性出来。因为没有道理是到处适用的，只有相对的真理，没有绝对的真理。典型的例子就是易经八卦。
*** 什么样的游戏才能受欢迎，其实跟编程语言一样，这个游戏需要有足够的灵活度，应该定义一些基本的规则，然后让用户基于这些规则来组合，不断的发掘出新的玩法，这样的游戏才能获得成功。比如dota,就定义了每个英雄的伤害规则，装备的使用规则，打钱规则等等，让用户可以自由的去组合，从而成就了一个如此成功的游戏。比如coc，就是定义了各种兵种，各种法术，兵种走位规则，然后让用户基于此去发挥，从而成就了这个游戏。
** 2014/11/14
*** 程序即服务，每个程序都有或多或少的自己的特性，而这些特性就是服务，它总是帮忙解决了某些问题，从而让利用了它的人不用去解决这些问题。人每次所能解决的问题数是有限的，只有将精力集中于关键问题，忽略次要问题，才能把问题解决好。
*** 最牛逼的程序是这样组成的：由很多彼此分离度很高的程序组成，每个程序负责解决某几个问题，然后共同分工合作，共同解决这个大问题。典型的例子就是计算机网络。
*** 模板其实也是一种重新组织代码的方式。编程语言在不断的进化，从最开始的纯过程式语言汇编，到出现带函数的语言，再出现带类的语言，再出现带模板的语言，lambda，其实都是在寻求一种组织代码的方式而已。每一种新组织方式的出现都使得代码的组织方式更加灵活，编程语言的发展实际上就是在不断的向着更加灵活，更加自由的组织代码的方式在发展。要更加灵活，就要求更加精简。所以所有的编程语言都是朝着lisp在发展，所有的cpu都是朝着risc精简指令集的方式发展。要更加灵活，就要打破规则，减少规则，所以linux内核要使用c语言来写而不是c++来写，因为c++所设定的那些规则不适合于编写linux的人。
** 2014/11/17
*** c++设计迭代器的目的是为了将数据结构与算法分隔开，使得同样的算法可以用在不同的数据结构上。这是建立在数据结构与算法都很多样的情况下的，如果只有数据结构很多或者只有算法很多的话是根本不需要迭代器的，徒增复杂性。
*** 返回对象引用的情况只有一种，就是返回在函数外边初始化的对象。在函数外边却不是全局，需要返回的情况只有一种，就是在类里面。
** 2014/11/19
*** 学习知识应该是取其精华，去其糟粕，先广泛涉猎，了解各种知识的核心理念与思想，然后选取一个自己感兴趣的点进行突破。历来哪一个伟大的人不是先博览群书，再在特定的领域做出了自己卓著的共享，然后名垂青史的。
*** 基于我按照时间记的这些笔记，写一个网页前端，然后将部分精品笔记上传到网上去。
*** 使用英文来进行思考，英文绝对在某些方面领先于中文，先要了解，然后取其精意拓展自己的思维能力。
*** 从易经里面所需要吸收的精华——易经是对世界运转规律的总结，即万事万物总是处在不停的往复循环中，就是在这种循环中螺旋式前进，永远满足元亨利贞，元亨利贞不断循环的过程。我们无法改变这种规律，只能改变每个阶段的时间长短。所以，当你处于困境的时候，你就要记得，这时候是积累的阶段，是技术沉淀期，要耐心积累技术，静静等待奋发的机会。当你处于春风得意时期，你要警言慎行，不要烦大的过错，否则就会进入困境。人力始终有限而天地无限，要趁着自己的有生之年尽可能地走远一点。
*** 读知北游，我建立了自己的精神世界；学习易经，我开始在自己的世界里建立规则。
** 2014/11/20
*** 占卦占卦，其实卦又何须去占？你自己所处的状态你自己都不知道，却去乞求虚无缥缈的行为来给予你一点启示吗！你自己对自己当前所处的状态应该有一个清晰的掌控，这样才能做到“行无咎”。指望子虚乌有的东西来给予自己指引终究不如自己来给自己规划来的靠谱，这就是荀子所说的“善易者不占”的意思。因为靠占卜得来的结论犯错的几率太高，还不如通过自己的理性思考来决定自己要走的路。
*** 易经其实不仅仅是一本描述天地万物的各种状态以及每种状态应该怎么做的书。它还有由爻的排列推演出事物发展规律的精神内核，这就是所谓的“太极生两仪，两仪生四象，四象生八卦”。它其实就是定义了两种元状态，每种状态有自己的含义，然后排列（注意不是组合，因为上下卦是有顺序的）成为八种状态，继续细化定义这八种状态，然后在排列细化，产生了整本书。
*** 学习易经，核心是要学习这种“一生二，二生三，三生万物”的思想体系并使用这种体系来为我们服务。这其实跟我们发明自己的理论的原理是一样的：工具就应该尽量小，工具就应该互补，不要有重叠部分，然后通过这种小工具的互补来诞生出新的工具来为我们服务。
*** 易经对我们的做人做事的启发是巨大的。做人应该刚柔并济，循环向前。做事应该积累，表现，积累，表现循环。发明理论应该先定义基本公理，在推演出辅助公理，最后推演出万物。等等，好处说不完。
*** “三教九流”中的“三教”指的是佛教，道教，儒教，“九流”指的是儒家，道家，阴阳家，法家，名家，墨家，纵横家，杂家，农家。这九个流派在秦时明月中都有出现。秦时明月与其说是九个流派在武学上的交锋，还不如说是九个门派的思想家在思想上的交锋，他们互相在摩擦中融合（其实融合的最后估计就是易经），最后共同走向新的远方，这就是秦时明月的核心思想。
** 2013/11/21
*** 基于自己平时记下的代码片段，编写一个前端，让我可以更方便地管理查看修改这些代码片段。
*** cmd控制台是windows程序的基础，里面的很多命令是操作系统接口，是可以被放心使用的。很多时候我们想使用系统的api，但是查找起来又比较困难，可以考虑直接调用控制台命令。
*** 为什么越是复杂的东西越难以学习？因为我们学习东西的方法很多时候是错误的。通常我们是按照先学习成果，然后倒着一步步追溯到源头的方式在进行学习，而这与知识本身发展起来的过程刚好是相反的。这种学习方法造成的结果就是初期学习难度会非常大，因为有太多的新概念需要去理解，后期通过多次重复才有可能有比较好的理解。这种方法虽然能更快地将知识投入使用，但基础其实几乎是没有的，也不明白别人为什么要这样做。这种方法顶多也就能用来入入门而已，想要真正学精学通，还是要通过从头开始慢慢深入的方式来进行。
*** 美剧与国产剧最大区别之一就是美剧多数时候是靠人心来推动情节发展的，而国产剧靠的是计划。
** 2014/11/25
*** vs的Ctrl+F5直接运行程序很多时候是很有用的。首先它不是通过vs的调试器调用的目标程序，避免了调试器对程序运行行为的干扰，可以完美模拟目标程序的实际运行行为。其次它在程序运行结束后会自动暂停，这样就可以让人看清楚程序的输出了。
** 2014/11/27
*** 如何给一个类添加方法？程序员不是神，不管多么牛叉的程序员也无法完完整整地考虑到某个类需要使用的全部方法。所以说，允许在代码中灵活地给类对象添加方法这一需求客观存在，不能被回避。针对这一问题，传统的给类添加方法的方法是写一个类来继承这个类，然后在子类中添加方法，再实例化子类对象，当原来的代码中所有需要使用父类对象的地方全部更改为自己改写后的子类。这样就不可避免地需要更改原来已经写好的代码，并不是一种良好的解决方案。比较好的解决方案是允许在任何地方给已经写好的类添加方法，这样当需要给原有的类添加方法时，就不需要改动代码的其他地方，保证了代码与代码间的松散耦合。
*** c++里面function与bind的出现其实就是为了给类动态添加方法，通过这两个工具，你可以自由地选择需不需要这种动态能力来调整已经写好的类。如果追求效率，就不要使用，如果追求灵活性，可以在自己的代码中使用，这样类就获得了在任何地方都能给已经写好的类添加方法的能力。
*** 面向对象不应该只是一种代码的书写方式，而应该是一种思想。
*** c语言可以通过使用已经定义好的类作为全局方法的参数类扩充原有类的方法，这种扩充类方法的方式应该被发扬。
*** 返回bool型值循环处理多份数据的情况下，每一份数据都有可能出错，当处理到某一份数据出错时但还需处理其他份数据时，如何保证返回值的正确性？无论直接使用break,continue还是return都是不合适的，这是比较好的方法是使用一个临时变量记录下状态，然后在最后返回这个状态量的值。
** 2014/11/28
*** 如何解决更好地调度银行ATM机问题？传统的调度方式方式是排队，先来先服务，由于系统不知道每个人办事所需要的时间，无法做进一步的细分，最后造成很多人即使是做一件很快的事也可能需要等很久，系统的总等待时间延长。如果能够对排队做一下细分，理应能够提高调度效率。
*** MFC相比于QT，还是暴露了太多的代码实现，封装效果差强人意。用户需要仔细了解每个函数的意思，并判断应该将自己的代码放在哪里。其实不管放在哪里，都会导致用户的代码与机器生成的代码耦合，使得代码难以维护。同时，MFC用来处理消息的机制——消息映射限制了建立消息映射的时间与范围，用户不能根据程序的运行情况动态地选择建立消息映射的时间，更改映射函数。总之，MFC是对Windows API的一个非常丑陋的封装，它唯一的优势也许就在于效率了。
*** 对于人生发展，事情多有事情多的优势，事情少有事情少的优势。环境本没有优劣，差别只在于你能否充分利用环境。事情多可以用压力来锤炼自己，事情少可以用自学，总结，思考来锻炼自己。前者便于积累杂学，而后者便于建立知识体系，前者是技术广度，而后者是技术深度。其实都是一样的，关键是你自己能否充分利用。
*** 易经其实揭示了这样一个道理，环境并没有好坏，关键是你是否能适应并利用环境。人生其实就是一场旅行，你可以偶尔小憩，但不能停止。一旦停止，就离死亡不远了。
*** 打开文件时能够以只读方式打开尽量以只读方式打开，因为用这种方式还能够打开已经被其他程序打开的文件，这是用读写方式打开所做不到的。
*** 使用fread读文件时，实际上文件是4k（默认缓存大小）4k的读入的，实际上fread只是做了一个拷贝与移动指针操作，所以，读一个字节跟读1k字节的差距只在于拷贝操作的效率差距而已。
*** 操作系统管理文件描述符，任何一个程序都有0,1,2三个文件描述符，分别表示标准输入文件，标准输出文件，错误输出文件。如果用户自己再打开另外的文件，文件描述符将从2开始累加，这一步骤是在fopen这一步骤做的。
