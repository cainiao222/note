* 2014/05
** 2014/05/04
*** 有两种情况容易产生临时对象，一是函数参数，一是返回值。要想避免临时对象的生成，对于函数参数，可以用引用来实现，但如果传递给函数的是一个右值，依然无法避免临时对象的生成，所以只能使用右值引用。而对于返回值，只有借助于右值引用。总而言之，尽量使用右值应用来传递与返回参数，可以大大提升函数调用效率。
*** 最好的分类文件的方法是采用混合方式，在某一层面上使用某个标准分类，下一层再采用不同的方法分。一般常用的方式是这样，上层使用时间分，下层根据类别分。这样不管多少信息都能使没一层的信息在可接受的范围内。

*** 对问题进行分步处理，形成流水线，一步步地处理问题。这种规范化的数据处理流程是小企业不具备的，只有形成这种处理思维，才能使问题处理规范化，大大加速数据处理的流程。
** 2014/05/12
*** 用mpi写的程序就是在多个进程上面跑的程序，这多个进程可以是在一台电脑上也可以是在多台电脑上，mpi使得在这些进程之间通信变得非常容易，但同时这种容易也是建立极大地消耗管理资源的基础上的，管理服务进程非常消耗资源，使得这些进程之间的协作变得效率不是那么的高。这是一个用来写在多个进程上面跑的程序的库，并不是用来写简单进程通信程序的库。是用来处理复杂通信任务的，并不适合于用于很少通信的情况。
** 2014/05/13
*** 可以使用很多种不同的结构体来以各种不同的方式解析一个长整数的各个位段，可以达到简单而清晰的效果。典型的例子就是ip地址。
*** 协议实际上就是在程序实现的时候的一些规定，正是因为有了这些协议才使得我们写程序实现变得简单了，不然复杂的网络系统根本搭建不起来。
** 2014/05/14
*** 对于非常大的对象，最好专门为它设计一个类，否则偷偷进行的拷贝操作就会拖死你的程序，更近一步最好自己完全接管这个对象的内存。
** 2014/05/15
*** 一般来说，小对象具有多而杂，难以管理的特点，这种东西用对象来管理比较好；而大对象一般少而简单，若依然使用对象来管理，很容易出现意外的拷贝，导致很大的性能损失，这种对象比较适合于用buffer缓冲区即内存来管理。
** 2014/05/17
*** 实际上linux常用的系统引导程序grub非常简单。它就是通过配置文件来实现引导系统启动的，配置文件就是一个普通的shell脚本，其引导linux主要通过insmod,linux,initrd这三个命令，引导windows主要通过insmod,chainloader这两个命令，都是很简单的。当系统无法启动时，一般修改下这个文件的内容就可以很简单的重新引导系统了。
*** 要想让程序更加智能，只有通过配置文件，通过配置文件中记录的信息来推动程序的自动执行过程，不需要认为干预。所需要人做的事越少，需要通过电脑做的事就越多。
*** 每种语言都有自己的特性与擅长的领域，像c++具有除了c以外其他语言基本都不具有的管理内存的特性。这一特性使得c++非常擅长于编写非常消耗内存的程序，比如有很多个小对象或有几个大对象，这些对象的内存管理问题处理不好就会造成极大的性能开销（主要是对象的复制），不具有管理内存能力的语言在这方面写起来就比较吃力了，即使写好了也可能会碰到性能问题，所以c++比较适合于编写内存管理比较复杂的程序，底层程序。而像lisp，java这样具有垃圾回收机制的语言能自动管理内存，虽然这种自动管理很多时候并不如手工管理来的好，但确实能为程序员省去不少麻烦，使得开发效率更高。
*** 其实用不同的语言编程确实会影响人的思维模式，每种语言都有自己对客观世界的理解与解决问题的模式。像c++解决问题的模式是基于修改所存储变量的值来完成对问题的处理。而lisp是一种函数式的语言，它解决问题的方式是基于函数的闭包。也就是它解决问题是基于一个个写好的小工具，这些小工具的累积来解决问题。这两种语言前者更接近与机器，而后者更接近于人的思维。
*** 在编程时把重复的工作聚集在一起，一次处理很多时候是一种很好的解决方案。比如发送文件，将所有文件缓存起来一次发送就比一次发送一个文件稳定高效得多。又比如文件IO，把很多次IO放在一起就比分散在代码各处来的要简单清晰高效。这其实应该成为一种思想：即将相同或相似的事放在一起对问题进行分类分步处理以简化复杂度。
** 2014/05/18
*** 程序中途因错误而退出时必须将错误信息输出到控制台或日志文件，这样当程序执行到一半异常退出时才能最快的定位到是哪里出了问题，从而最快的改正问题。否则你只能一部分一部分的调试看是哪部分出错了，非常麻烦。
*** socket的本质是一个程序与通信协议之间的抽象层，提供给程序员通过不同的协议来进行通信。tcp/ip协议的每一层实际上都是很简单的，应用层使用socket抽象层与运输层与网络层进行通信，实际上自己本身并不做数据的发送与接收工作，都是有运输层与网络层来完成的。运输层的协议主要是tcp与udp，主要解决的问题是序列化，通过端口这一形式将计算机上的所有网络进程的网络数据放在一起，然后通过端口进行区分。网络层的协议主要是ip，它主要解决的是网络上计算机的编号，以及数据单元怎样在网络上进行传输（路径算法），至于链路层就是放在设备上的程序提供一些地址信息等辅助信息传输的，通过这四层就完成了传输，实际上这种方式已经是要解决复杂的网络通信问题很简单的解决方案了。
*** socekt本身并不做数据的传送与接收工作，它只负责与底层主要是tcp，udp协议进行通信，交给他们了就不管其他的了。
*** 主机很多进程要发送信息的序列化由tcp,udp来完成，但进程内部，也就是自己程序信息的序列化就得自己来完成了。
*** 写程序最忌讳碰到问题时心浮气躁，这种状态下根本什么事都坐不下去，更不谈解决问题了。碰到这种问题时，关键是要理顺解决问题的思路，按部就班，一步一步排查。
** 2014/05/19
*** 使用socket发送接收数据时数据的同步是个很容易出问题的点，如果一方发送的太快导致另一方来不及接收而发送方误以为接收方已经接受完所有数据关闭了连接，接收方就会丢失还没来的及接收的数据。
*** 不要对某些可能比较耗时的操作讳莫如深，当写下这种代码时，要大致估算一下此代码大概会消耗多少时间，比如初始化内存空间，即使是初始化100m左右的空间100m次运算而已，按照计算机几GHz的cpu算下来也才消耗零点几秒而已，相比初始化之后的好处而言这零点几秒算不了什么，但如果是在循环里面初始化这100m空间的话，即使是只有100次，也会消耗十几到几十秒的时间，在这种情况下能不要初始化就尽量不要初始化了吧。
*** 几个东西协作完成任务时同步非常重要，比如一个已经做了很多而另一个却还没开始就必然会导致协作上的出错，这个问题经常碰到比如开发socket程序，多相机拍摄照片，多人合作完成项目开发等等。
*** 在开发socket程序时，打断点很容易造成程序之间不同步，比如一个都请求连接了而另一个还没有listen，而不打断点却好好的，这时打断点调试还不如直接用输出调试。
*** socket是一个成对使用的api，每调用一个函数时都要留意另一端的状态，比如一端要connect另一端就一定要listen，一段要send另一端就一定要recv。大多数的scoket错误都是由于这种状态不匹配所导致的。
*** 无论是用socket分包还是tcp协议分包基本上都不会出问题。但有一点需要注意，自己用socket分包消耗的是处理机cpu的时间，而tcp分包消耗的是网卡的时间，而前者速度比后者快的多，后者分包是会大大降低网络使用率的。所以尽量自己用socket来完成分包，一般最好一次发送4k字节比较合适。分送太大的包会完全使用网卡来帮你分包导致很低的网络使用率。但分包也不能太小，太小会导致频繁的发送开销，依然会降低网络使用率。
*** 实际上socket并不是把数据发给了网络上的另一台主机，而是交给了tcp与udp，然后用他们来进行传输。理解这一点很重要，它意味着并不是你一次发送多长的数据在网络上就有多长的数据在传输，tcp协议依然会对他们进行分包。大小只有在最接近于网卡的数据，避免被网卡分包才能达到最大效率。
*** 其实判断socket每次发送多少最合适有个很简单的办法，即发送端将一个包拆成了几个包来接收，就将当前发送包的大小除以几。
** 2014/05/20
*** 对于比较小而且少的字符串，完全可以随便使用std::string而不用关心效率与内存占用问题，这些开销相对于其带来的有点是完全值得的。只有对于程序中的几个关键的大对象或大量对象需要自己去另外设计对象结构，自己来管理这些对象，这样整体下来既关注了整体的灵活性，也不至于因为某些关键对象而失去效率，是一种常见常用且实用的编程技巧。
*** 尽可能地将程序中出现的数据比如文件名，端口，ip，地址等信息保存到文件里面，然后从这些文件里面读取，能大大提高程序的自动化程度，使得程序变得更智能，更灵活，这也是配置文件一般设计的思想。其实有个很简单的判别方法：程序中不要显示第出现字符串，整数等，应该将这些东西全部转移到配置文件。
*** 尽量不要将程序代码写在main函数里面，main函数里面最好仅仅写一些程序的控制信息，不如system("pause")这样的，在这种情况下，如果在前面的代码里面因为出错而return，就会直接退出程序，而执行不到这些控制信息了。
** 2014/5/21
*** 命名空间这东西类似于类，但实际上又比类好用。命名空间最大的用处在于把你写的全局函数或全局变量用这东西包起来，防止里面的命令跟其他的库冲突，同时又提供简单的使用方法，不像用类要想实现此效果要么先定义一个四不像的变量，要么将所有的变量或方法前面加个static，还有就是不用像用类一样在所有方法实现前面加一个讨厌的“类名::”。c++终究还是偏向于面向过程，面向方法的。所以，实际上命名空间比类还要好用，还要重要。
*** 其实程序编写的初期各种各样的错误处理等考虑的是十分不全面的，这是为了快速投入试用，后期针对试用后的反馈这些东西才渐渐的被添加上去了，都是这样的。我们模仿别人编写的程序编程时，往往会陷入别人一开始就考虑的非常周全的误区，其实不是的，初期编程，只要考虑最基本的错误就足矣，没必要都考虑到，搞得非常复杂。
** 2014/05/22
*** 对于系统的实现，应该先写核心，再写业务。比如对于数据分发处理系统，核心就是发送文件，执行远程程序。先把这个做完才是业务流程，流程就是先发数据，再发执行指令，最后收集结果。当然，中间必要的交叉也是必要的。
*** 其实对于核心数据格式的设计虽然一般是根据需求一直在变的，但还是有一些规律可循的，在格式设计的初期虽然无法预测到所有可能的需求，当有一点要始终保持就是保证数据的完整性，尽可能地少丢失数据信息，使得数据易于读写，解析等，这些会给后期更改格式带来巨大的方便。
** 2014/05/23
*** 比较小的数据往往是需要先取出来的数据，这些数据最好放在序列化后数据的前段，这样就不需要来回移动指针了。
*** 序列化时预留几个字节能在后期情况了依然无需更改之前的序列化反序列化代码，只要增加就可以了。
** 2014/05/26
*** socket实际上就是一个在服务器与客户端之间保持内容同步的文件，这个文件存在于内存中为硬件（这里是网卡）保留的内存区域，大小大概是几k，每当这几k内存被同步交付给协议上层以后内容被清空，这就是tcp的原理。理解了这一点以后，实际上是用read,write来操作tcp比用send,recv来的更接近本质。