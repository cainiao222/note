* 2016/10
** 2016/10/08
*** 代码的层次结构非常重要，如果层次控制得好，代码的可读性就会非常的好。如何写出层次结构非常良好的代码呢？分文件是很常用的方法，不过随便一个功能都分好几个文件也是不明智的。正确的做法应该是复杂的功能分文件，简单的功能还是写在一个文件，不过分部分，高层代码写一部分，低层代码写个部分。
*** DONE 使用回调来表现层次结构，外层的代码写在外层，内层的代码写在内层，这是每个前端开发者都应该掌握的编码技巧。
*** 函数的定义与调用都应该放在适当的层次，不能跨越层次太多，这样别人看起来才能一目了然，从外层到内层，每一层都会定义与调用一堆函数，当跳出这一层的时候这些函数就会被自动释放掉，这样写出来的代码才能拥有最好的可读性。不过有一点需要注意的是如果一个函数经常被调用，频繁的定义这个函数就不是很明智，这种时候就应该把定义稍微往外层移动点，不过也不能移太多，太多了易读性就是去了。
*** 写代码不止要达到可读的程度，还要达到易读，可读是说能够读懂，易读是说容易读懂，二者高下立判，仅仅岛导可读是不够的，还要争取达到易读。
*** 什么样的函数接口才是非常优秀的函数接口呢？可以参照高德地图开放平台 API，通过函数把所有的东西都封装起来了，只需非常简单的函数调用就可以重现功能。什么是失败的 API 呢？可以参考腾讯地图开放平台 API，代码逻辑混乱，全局变量满天飞，胡乱使用对象，一堆莫名其妙的对象成员，还需要用户去猜测，非常失败。
*** 高德地图的API结构确实非常的好，使用AMap来管理整套API，然后在这套API中，有Map用来管理地图，有TileLayer用来管理图层，有service用来管理服务（主要是地名搜索、路线规划、公交查询），有Marker用来管理标注，有InfoWindow用来管理窗口，使用Plugin（包括地名补全，侧边栏，工具栏等带UI的东西）来管理插件，有Event来管理事件。
*** 再来对比下百度地图的API，百度地图的API实际上并没有划分出service、plugin这些东西，直接把功能挂在BMap这个对象上，这就直接导致这个对象过大，性能方面可能会受影响，拓展性也不会好，不过百度地图的帮助文档丰富程度是强于高德的，学起来比较容易上手。
*** 最后看看腾讯地图的API，腾讯地图的API相比于其他两家的API，质量就差更多了。高德地图有高层、中层的抽象以及底层的实现，百度地图有中层的抽象以及底层实现，而腾讯则只剩底层实现了。它的API接口暴露了很多底层实现的细节，需要用户自己去绘制，考虑很多东西，这就非常差劲了。
** 2016/10/09
*** 抽象的最大意义也许就在于提供给上层统一的接口，用户只需关注于功能使用，而无需关注功能实现。我们只要修改实现细节，所有使用这一接口的地方都会被修改，实现一改全改。
*** 实际上，js 的 new 就是一个工厂模式的实现（对象的字面量写法实际上也是 new）。工厂模式使得我们能够使用一个函数来创建对象，忽略对象的构造细节，我们只要修改了细节，所有依赖于这种方式构造出来的对象都会被修改。
*** 实际上工厂模式只不过是函数的一个非常初级的用法。函数是一门编程语言最强大的东西，没有之一。通过函数以及函数的组合，可以实现非常强大的抽象。函数可以用一句话代表一堆话，可以把这堆话作为函数参数传来传去，想什么时候调用就什么时候调用;函数还有自己的作用域，实现内部元素的控制，当退出作用域的时候将这些元素给释放掉;函数还可以捕获它外部的变量，使得我们即使出了变量的作用域，依然可以通过它透出的函数来间接使用这些变量，实现状态抽象。
*** 全景图还是有它自己独特的意义的，它对于现场还原具有很好的效果，远远强于只有一种图片的情况，对于作业也大有好处，唯一的问题就是数据量。
*** 函数与语句最大的差别也许就在于函数是有作用域的而语句没有，也就是俗称的上下文有关文法与上下文无关文法。
*** YUI 虽然走入了历史，不过 YUI 依然有些非常强悍的新功能需要被继承，比较值得一提的就是其事件框架以及组件框架，这两个现在是还找不到替代品的，其他的像测试框架有 Mocha，CSS 框架有 bootstrap，APP 框架有 backbone。
*** es6 的模板字符串的花括号中是可以表达式（变量，函数调用都是表达式），但不能是语句，因为语句没有返回值。如果真的要使用语句的话，可以使用函数（箭头函数更好）封装语句，然后加上返回值，这样你就可以随便使用语句了。这样看来，实际上 js 的模板字符串并没有做任何的限制，我们完全可以使用语言中的任何特性写进模板字符串实现字符串拼接，唯一的不足是无法统一管理输入参数，不过这也不是什么大问题。
*** DONE 实际上没有语句只有表达式的语言是无比强大的，因为它可以允许我们随心所欲的进行组合，不用考虑返回值的问题，语言的可组合性非常的强。任何语言都应该这样设计。比如 lisp 语言。
*** 为什么匿名函数（js 中的箭头函数）这个东西会作为一个非常现代化的特性走进各种语言呢？因为很多时候我们只是需要一个函数，这个函数只使用一次就不再使用，我们并不需要把这个函数单独提出来影响代码的结构，我们也不需要费心思去考虑给这个函数取一个怎样的名字，我们甚至不需要为这个函数写上多余的大括号，这种时候，匿名函数就成为了最佳选择。这实际上是函数的使用频率越来越高了的一个表现。也就是说，什么时候使用模板字符串呢？即用即仍的函数、小函数。如果函数需要多次使用，那么还是使用个具名函数更好点。当然，由于 js 中的匿名函数与普通函数还有 this 的区别，这门语言的匿名函数应该被更加广泛的使用。
** 2016/10/10
*** TODO autoload 设计启示：使用一个函数封装一堆函数，将这一堆函数延迟加载。原本需要加载一堆函数，现在只需要加载一个函数，速度自然更快。充分利用函数延迟加载的特性，大大减少了函数数量，从而实现加载速度的提升。想法非常好，但是也有需要注意的地方，关键的问题是具体到什么时候加载，加载以后什么时候释放？
*** load 与 eval，函数定义就是 load,而函数执行就是 eval，将函数调用变成函数定义能够延迟调用的时间，实现延迟加载，为程序减负。
*** spacemacs 设计原则，如何解决 vi 与 emacs 的按键冲突问题？使用外围与内围两个状态用 vi 做外围，emacs 编辑做内围。
*** vi 有三种插入命令：insert,append,open。每种插入又分大写还是小写。所以综合起来一共有六种插入命令。这六种插入实际上比较乱，根据单词的意识来记忆比较好。
** 2016/10/11
*** 事实上，把所有函数都写在一个（比如全局作用域）是个非常不好的做法，这样当函数很多的时候加载起来就会非常耗时，同时对拓展性也是很大的伤害。
*** 培养编程的感觉。
*** 使用的require.js，但是却使用的CMD的写法。
*** 不管是amd还是cmd，它们都蕴含着同样的思想————使用函数来包裹模块，把模块的所有代码写在一个函数里面，模块可以嵌模块，形成树形结构。每个模块里面暴露尽可能少的外部接口，每个模块应该是自完全的，自己渲染，自己添加事件监听，自己实现监听函数。
*** 实际上每一个前端功能都包含三个部分————界面绘制，事件监听，事件处理。这三个部分分别叫做V,C,M,各种框架所做的事情实际上也只不过是在给这三个部分分类，防止文件过于复杂。当你学习框架时，可以从这三个方面去考虑，考虑当这个框架引入时，如何处理这三个部分的代码。
*** 延迟加载也许是当下实现web编辑器性能飞升的关键。
*** 实际上按需加载css也许是很诱人的个东西，根据别人选择的不同方案动态改变样式，想想都十分诱人。
*** 只有函数才具有可维护性，css由于没有函数，所以可维护性非常差，当然借助于less的函数能够解决部分问题，但是由于css各个属性太乱还是不能根本解决。
*** webpack的出现是历史的必然，本来js足够强大，我们能够使用js来加载任意类型的文件，那么当加载其他类型的文件的时候，先用个程序转化下转化成js不就可以实现加载任意格式的文件了吗，这就是webpack的设计思想。
** 2016/10/12
*** 实际上，hook也是一种代码解耦的方式，类似于事件。它可以使我们在不修改已有代码的情况下实现功能的拓展。
*** 实际上，requirejs与webpack是差不多的东西，webpack所宣传的打包任意类型的文件使用requirejs也可以做到，requirejs也可以依赖css，less,图片这些东西，也可以将这些东西打包成一个文件，而且难度也并不会就比webpack要难。所以说，前端的很多工具实际上是重叠的。
*** nodejs的出现确实是前段领域划时代的东西，自从它出现后，js终于可以脱离浏览器运行了，终于可以操纵操作系统的各种资源了，由此出现了大量的js工具集，js终于迎来了春天。
*** gulp是一个工具集，它不同于webpack。webpack只是一个工具，而gulp是一个工具平台，它提供了很多我们写工具的时候需要用到的各种API，它是比webpack高层的东西。
*** webpack之所以会流行，很大程度上是由于它抓住了前端问题的核心————打包。它与gulp的目的是不一样的，gulp倾向于给人开发前端工具，而webpack是用来给人做前端开发的，高下立判。
*** 将所有的UI相关的代码写在一起，将添加事件监听的代码写在一起，将事件处理写在一起，通过这种简单的分类，代码逻辑就可以非常清晰了。
*** 如何提升代码的可读性？MVC只是一种比较粗略的代码分类方法，要想继续提升可读性，还得继续细分。首先需要划分的就是M端，M端由事件派发的函数作为开始，需要实现自己的业务逻辑，这些业务逻辑必然有很多共用的部分，这就是分割点。首先需要把这些共用的业务逻辑抽象出来，放在另一个位置，可以是另外的函数，也可以是另外的文件。
*** 实际上，在MVC三个部分代码中，VC端很多时候是非常简单的，而M端才是重头戏，所以，要继续细分，首先得从对M端的划分开始。
*** 实际上对于一个功能模块的MVC来说，它的终点M端实际上很有可能还连着其他功能模块的起点M端的。也就是说，实际上，MVC是嵌套的，一个M有可能跳转到其他功能模块的V。
*** TODO 也许编写一个工具用来抽模块是个不错的做法，因为一个文件很多时候会依赖其他模块，如果都是用require引入的话，我们完全可以解析下require的参数，将所有被require的文件给抽出来。
*** webpack是更好的requirejs，它使得前端开发尽可能的与node开发保持一致，比如它可以依赖文件夹。也不用考虑异步加载的问题，因为文件都被打包到了一个文件。
*** browserify的思想实际上比webpack更加的先进，它是微内核的，灵活性与拓展性都会比较好，而webpack隐藏了所有实现细节，想重新组合就比较困难了。一般新手可能会更喜欢webpack，而用的多了想获得更好的拓展性就需要使用browserify了。
*** TODO 不管是webpack还是browserify，它们都只会打包被依赖的文件，如果一个文件没有被依赖，这个文件是不会被打包进最终文件的。值得注意的是，如果只是想提取文件而不打包，这两个包好像都还做不到。
*** 最好使用一个文件夹来表示一个功能模块，而不是使用一个文件，每个文件夹有相似的结构，这样代码就能写的比较清晰。
*** 要理解iD对代码划分的方式————mode（顶栏操作菜单）,operation（右键菜单）实际上都是V，behavior是C，而action是M。
*** 在本地可以开启一个服务实现自动打包，在服务器上可就未必可以了。因为服务器对稳定性的要求比本地要高，一旦代码打包，这个打包无法即时被推送给所有用户，就会造成莫名其妙的错误。
*** js的箭头函数是个非常好的东西，尤其是在事件处理函数中。
** 2016/10/13
*** 如何处理文件路径的问题？使用绝对路径，不要使用相对路径。
*** z-index是基于BFC来进行层级定位的，所以，要使得z-index生效，必须先给元素生成一个独立的BFC,也就是说，必须先给元素个除了static定位以外的定位才能正常使用这个元素。
*** 关于z-index的生效方式，它是以父级为准的，如果父级的z-index比较低，那么子元素的z-index设置的再高，它也是不会跑到前面去的。可能是因为浏览器是从父级到子集设置z-index的，父级不给力自己再怎么牛逼也不行。
*** 确实不能require css是非常不好的。
*** 每一个组件都必然是有自己的数据的，这个数据最初由外接传入保存在组件内部，然后这组件自己管理并对外暴露接口完成功能。
*** DONE 我的第一个组件————右键菜单。
*** 面向对象的核心思想是将数据与对数据的操作放在一起，数据通过初始化函数传入，然后在整个对象声明周期内维护这份数据，提供很多工具函数来操作这份数据，当需要的时候通过这份数据向外部提供功能（在这个过程中数据是对外隐藏的），完成自己的功能。这一思想很好的实现了数据与功能的解耦，外界只需提供数据就可以完成操作，的确是一个非常强大的编程方法。
** 2016/10/14
*** TODO 编写一个测试开源代码库的平台也许会有市场，因为我们不想去一个个下载。现在的解决方案，使用npm下载webpack/requirejs+依赖库就可以了，但这种方式还是太复杂。
*** TODO 编写一个工具用来做摘抄，将剪切板中的内容发送到指定的文件。比如clipBoardSend func.js，在提前设置好的地方新建一个名为func.js的文件，然后将当前剪切板的内容写进这个文件。这样的一个工具用来做代码摘录就非常的好了。
*** 原生js实际上是没有参数类型提示功能的，但是webstrom使用标注的方式实现了类型提示，这实际上是一个很好的想法。实际上，注解（annotation）实际上是一个非常有用的功能，现在像java已经把它作为语言内置的功能集成进语言了。
*** scripting language 虽然多没有强制类型，有很多好处，但type同样是极其有用的，没有type，基本上programming by contract是不可能的事，项目越大越关键。这是为什么PHP，Python后来都把类型系统加回来的原因。javascript也是一样，因为现在的JS项目已经不是简单写个onclick = fn这么简单了。时间证明，程序员需要type system，他们不喜欢强制的type system，optional types 是能走得很远的中间道路，因为有了抽象能力，鲁棒性，又不牺牲执行效率，开发效率，是鱼和熊掌兼得的策略。————itlr《如何评价TypeScript》
*** js的arguments是一个类数组对象，它记录了一次函数调用的所有信息，包括被调用的函数是哪一个（callee），函数参数是哪些（[...]）。它可以被用来实现变参，但是实际上用它来做变参不直观而且使用起来不方便，所以es6使用了rest arguments来取代它。它还有个缺点就是性能问题，由于arguments是不断变化的，导致编译器无法对它进行优化，它的可读性也不好，所以，最好的方法是不要使用它了，如果需要使用caller，还是使用named function吧。
*** 弱类型语言由于没有类型，当参数传递进来的时候为了鲁棒性，一般都要进行参数类型判断。这实际上会造成冗余代码，强类型语言在这方面是强于弱类型语言的。
*** 一个模块不能有太多的依赖性，依赖太多移植起来就会比较麻烦，消除依赖的方法有很多，一个是除非必要，不要引入依赖库。还有一个是如果引入依赖库，需要自己再封装一层，这样替换依赖会比较容易。
*** what is dispatch？dispatch is a loop which will traverse all children of its and judge whether the target child has specified event handler.If the answer is true,call the function use the event target。
*** dispatch是先获取类型，然后遍历类型内的的对象的。
*** 如何编写自己的事件系统呢？首先需要找到事件之源，
如何处理ui与模型的同步？

这个很有可能是bind的bug，因为一旦bind，一个函数就不再是原来的那个函数了，会返回一个新函数，所以现在对原函数移除事件监听就失去效果了。

js中事件处理代码出错了无所谓，重新调用就好了，这很大程度上较少了程序崩溃的几率。

跳转到指定函数定义也许是一个非常有用的功能，依赖树的代码编辑。
** 2016/10/17
*** 从每次做需求的过程中获取经验教训，危机也许就是转机。
*** webstrom ctrl + +/-粒度最小，ctrl + alt + +/-粒度中，ctrl + shift + +/-粒度最大，分别是一个大括号，递归式大括号以及整体。
*** 使用回调函数处理函数结果而不是把结果直接返回继续处理，这是js中非常常见的用法，而且几乎是处理异步函数调用的唯一方法，因为这种方式不会阻塞主线程。
*** TODO 如果说使用回调函数是为了异步续处理，那么不断返回函数又是为了什么呢？是为了生产数据以便于续处理。
*** 编写能够处理特定数据格式的程序不难，难的是处理格式不固定，需要自己寻找规律的格式的数据。
*** requirejs的require.config()会产生一个内部对象，然后你就可以使用对象的key来使用对象的值了。
*** 从jquery的设计思想来设计api. addEffect,removeEffect,toggleEffect。
** 2016/10/18
*** 事件是前端编程过程中非常重要的一个概念，
*** TODO 一段代码加载之后如何卸载，这个做得到吗？
*** 可读性差可维护性一定差，可维护性好可读性一定好。所以，想要提高代码的可维护性，首先得从可读性入手。
*** webpack的require参数中，！是程序，？是参数。
*** appendChild是异步加载的，所以，想在标签加载完毕后再做某些操作需要使用回调函数，配合onload是非常合适的选择。
*** 我真的理解webeditor吗？好多东西好陌生。
*** 其实iD原本的设计是很好的，但是被一堆没有理解iD精髓，随意给它加功能的人（也包括我，呵呵）给改坏了。
*** 即使是js这样灵活的语言，初期可以不使用面向对象编程，但是当代码量上去了以后，面向对象也是必须的。
*** iD的正确使用方式是怎样的呢？应该给每一个常用的数据集一个数据类型，应该将数据尽可能的集中，统一管理，这样也便于优化。应该给常用的数据类型几个方法，用来操作这种类型的数据。应该有一个主的数据流，一步步将所有的数据渲染出来。
*** 实际上iD原本的设计是根据数据的逻辑类型对数据进行分类，但是做着做着就变成了根据数据的业务类型对数据进行分类了，这是非常错误的一种做法。
*** 如何对前端的数据进行封装，也许将dom元素与数据封装在一起是非常合适的。
*** 在地图编辑器中，map实际上是一个全局对象，在任意地方都可以随意使用的一个对象。
*** js语言本身并没有类型多态，所以需要我们自己去手动判断，所以类型判断在js中变得格外重要。
*** js虽然是一门弱类型的语言，但是类型的重要性依然是毋庸置疑的。使用类型系统能够让我们提前定义好属性以及属性的方法，能让我们管理起对象，这种强大的能力是不使用类型系统难以做到的。
*** 如何将数据与它对应的dom元素建立关系，iD的答案是使用id，数据有id，dom元素有id（写在它的class中），通过这一对应关系，就可以很容易的在这两者之间互选。
*** what is map?map is a collection which consist of two parts.The one is severail types of data,the other one is the related dom element.we can use map to find every kinds of data or dom element。
** 2016/10/19
*** webEditor对iD的扩充有个非常好的就是Overlayer的引入，这一修改大大方便了地图中对象的创建与显示，提高了编码效率。不过这一修改没有被放在正确的位置，它不应该被放在map.js中，而应该放在render文件夹下的新文件中，由于文件没有组织清楚导致这一扩充很少被使用。
*** 实际上，由于回调函数中this指向的是运行时的环境而不是调用时的环境，所以，只要回调函数中使用了this，我们几乎都应该使用箭头函数，由于我们无法实现预知到是否使用this，所以最好所有回调函数统一使用箭头函数吧。而且箭头函数在chrome45已经默认支持，无需转译，所以放心使用吧。
*** 也许代码管理者不应该写代码，而应该看代码，当看到哪段代码写的不好要求相关人员改正或是自己改正。
*** 关于鼠标滑过元素事件有两对，一对是mouseover与mouseout，另一对是mouseenter与mouseleave。这两对事件中前者会重复触发子元素，后者只有在进父级元素的时候触发，根据实际需求，一般使用后者，也就是mouseenter与mouseleave会比较好。
*** 使用require可以实现延迟加载，避免一开始就把所有的文件都加载进系统，这样可以加快启动速度。
*** 服务是依托于数据的，服务是函数，数据是属性，这两者共同组成了类，一起叫做面向对象编程。
*** 时间派发总有一个根对象，这就是d3.rebind干的事情了，它能将制定对象的事件的对象绑定到dispatch中进行处理。
*** 快捷键也是一个需要统一管理起来的东西，如果不统一管理起来，那么实现定制快捷键几乎不可能。
*** 弹窗也一样。
** 2016/10/20
*** 防止一个事件重复触发的神器————节流。
*** iD的behavior实际上是脱离了V的MC，它使得我们能够实现功能组装而无需关心界面。behavior还有一个作用————隔离，我们无需关心其他behavior的行为冲突。behavior的还一作用————功能组装，只需把一个behavior放到另一个behavior中，就可以拥有这个behavior所拥有的功能。通过behavior的功能隔离与组装，我们可以提高性能。
*** 耗时操作最好都放在if里面暂存起来，下次用的时候直接取。
*** 运算数据与使用数据应该分开，不要放在一起，不然数据运算有问题，想做下续处理都没辙，这也许就是前端将action单独分来来的原因。
*** 写代码也要使用面向服务架构，采用三层结构，第一层是程序名，第二层是模块名，第三层是功能名，第二层就是所谓的“服务”，每当增加一个新功能时，要考虑下这个功能应该被划分到哪一个服务下去。
*** 有一个变量需要考虑，没什么问题，简单。有两个，还行。有三个，操蛋。有四个，洗洗睡吧。
*** 小心连点()比如fna().fnb().fnc().fnd()...)，因为一旦某一截返回了空，下一个点的调用就会失败，最好每次点一次，然后做个判断，然后再接着继续点。
*** A或等价于并非（非A且非B）   ;   A且B等价于并非（非A或非B）；
	也即全部与部分都取反且边或或变且。通过这种转化能够将比较难以用if语句直接表达的或条件变成容易表达的且条件。
*** 实际上不止this是动态作用域的，函数参数也是动态作用域的，但是确实有时候我们需要绑定块级作用域，这个时候就需要使用bind函数了。
*** 实际上，我们平时一般喜欢从document出发去寻找子元素是不对的，应该尽可能使用更小的范围而不是使用全局的document。
*** 其实web编辑器整体上还是太过简单了，无法适应复杂情况下的高德软件地图编辑业务，需要从整体上进行扩充。这个扩充有如下几点：
	1、增加批处理
	2、增加模态右键菜单
** 2016/10/21
*** ai中有将几个路径放在一起有复合路径与编组两种方法，如果你想把这几个路径放在一个图形中，使用复合路径，这一般也是最常见的用法，如果你只是想把他们放在一起，可以使用编组。复合路径是一个神器，可以在我们想要的地方填充颜色，非常好用。
*** 即使可以使用断点调试，使用log调试依然是一个不可忽视的调试技能，因为断点会打断时间片，而log不会。而且对于触发非常频繁的函数，使用端点进行调试效果非常差，这是使用log会有意想不到的效果，特别是chrome控制台允许临时修改代码进行log输出，这一点就变得更为有用了。
*** svg中所有的g标签实际上都应该给一个class，为了可读性，让别人一看就知道这个g是干啥的。
*** d3注意事项，不要append两次，一旦出现这样的情况，代码可读性就会直线下降。
*** pop oop fp aop
*** xxx xxx_imp
** 2016/10/24
*** 如何编写一个业务组件？每个UI组件都必然有自己的数据，将这个数据放到组件的成员变量里或是从外部传入都可以，然后在适当的时候完成这个数据的更新就可以了。
*** 可以使用成员变量记忆状态，也可以使用函数重新运算状态，甚至可以两者结合起来，先看是否有状态，有就取，没有就算，这都是常见的处理状态的方法。
*** 我现在写代码没有充分利用到缓存，这样写出来的代码虽然说没有状态，是函数式的，但却失去了缓存所能带来的性能提升，今后要有意识的避免。
*** 不止要保证能够往下面找，还要保证能够往上面找。这也就是一般来说某个数据总是要保留一个parentId的原因，这样能够保证任何一个元素总能找到它关联的所有数据，形成一个图。web编辑器的MAAT/SAAT以及各种子关系都是基于这个原理设计的。
** 2016/10/25
*** 主流的事件派发实现中，on实际上是添加与删除的结合体，相当于生产者；而消费者是事件。
*** 为什么我们一般资源的使用API设计的时候都是打开、操作、关闭的流程，我们为什么需要打开与关闭？实际上是为了初始化与清除状态，这样我们就能够做更多的事情。
** 2016/10/26
*** 如何实现数据联动？只要保证数据是“算出来的”（这要求我们使用函数而不是数据），而不是直接使用以前的数据，那么数据联动就总是正确的。
*** 自己写UI组件需要解决如下几个问题：
	1. 拖动（draggable）
	2. 位置（position）
	3. 尺寸（size）
	只要把这几个问题做好了就可以轻松做出自己的组件了。
*** TODO 前端实现hotloader到底有多难？css可以做到只要css修改就重新加载，那么js呢。怎样才能做到js的无需刷新页面自动加载？
*** iD的mode核心实际上是状态；behavior是行为，用来操作状态；action是行为，用来操作数据。
*** redux的dispatch实际上是改。
*** 一个库实际上就是一个封闭的环境，它需要对外提供增删查改的功能，所有库都是这样设计的，尽管不同的库增删查改的差异可能会非常的大，以致于你无法一眼直接看出这个库的增删查改都在哪个地方。
*** 统一管理Dialog、Logger、z-index等，能够统一管理，带来无法想象的好处。
*** 实际上绝大多数的js流行框架没有多少行代码，完全可以凭一个人空手写出来。
** 2016/10/27
*** map/reduce是一种针对于集合进行变换收集的方法，适用于将复杂的问题简单化。它无法完成问题分解，只能完成问题求解，问题分解依然要人自己发动脑力去思考。
*** TODO 每次写一点代码都要全页面刷新才能调试看写的代码对不对，这是非常浪费时间。能够没写一个函数，都单独测试这个函数，正确了才继续往下走？
*** js的every相当于且，一碰到false立即返回；some相当于或，一碰到true立即返回；filter相当于？，为true的会被保留。
*** 键盘f1到f12功能键的设计是一个很精巧的设计。我们很多时候什么字符也不希望输入，而只是想输入一些命令，这就是这几个键的功能，它实现了功能与界面显示的解耦。
** 2016/10/28
*** TODO 可组合性是个极其重要的问题，函数式编程为什么会流行，很大原因是因为纯函数具有极强的可组合性，远非类这种东西可比。
*** TODO 函数具有无与伦比的可组合性，状态能够大大加快程序的运行，但状态又会破坏函数的封装性，这真是一个非常矛盾的问题。
*** 为什么要组件化？有个非常重要的原因不可忽略————可组合性。使用组件能够让我们直接将UI与业务逻辑组合，大大提高开发效率。
*** 实际编程的过程中，我们进场碰到非常复杂的逻辑，需要考虑非常多的情况，这种时候一般的解决方法是这样，首先把最典型的、最容易判断的情况给滤掉，剩下的就好判断多了。
*** TODO iD为什么要将一个操作功能在operation、mode、behavior、action这四个东西里面，是为了重用，提高功能的可组合性。
*** 回调函数是被修改的重灾区，要想你自己写的功能函数不被修改，就不要把功能实现写在回调函数里面。
** 2016/10/29
*** js如何最快的将var替换成let，直接全局替换，将"var "替换成"let "就可以了，注意后面的空格。
** 2016/10/30
*** TODO 如果在普通编程语言的基础上禁止使用外部变量，那么会怎么样？
** 2016/10/31
*** 实际上函数式编程还有个好处就是它对于性能优化非常有利，因为它的数据流非常清晰且没有副作用，重新组合起来就会非常的容易。
*** 借助于函数式编程的思想，实际上我们根本不需要自己写顺序、选择、循环里的任意一种语句，我们完全可以都使用链式调用来完成。所有的编程都可以直接通过map/filter/reduce/some/every等高阶函数模拟，由此带来的是更好的可读性、可组合性以及性能优化空间。
*** TODO map是长方形，filter/reduce(accumulate)/some/every是朝右的三角形，朝左的三角形又是哪个函数呢？是split,enumerate这样能够产生列表的函数，但是这两函数不是高阶函数。其实这也是现有高阶函数尚未实现的东西，缺少一个产生列表的高阶函数。
*** 使用面向对象思维编程的意义就在于————你可以提前定义好一些东西，包括属性和方法，然后一次将它们全部构建出来(new)，这样你就可以直接使用它们了。
*** 对象的字面量语法虽然能够非常方便的创建对象，但却无法实现重用，无法复用一些已经写好的属性与方法，这就大大限制了这一方法的使用范围，如果你想重用，还是老老实实的使用类吧。
*** 代码可读性好有什么作用呢？它给了你重构代码的机会。
*** 如果使用了过多的成员变量，那么拆分起来就会困难重重。
*** 当发现过于复杂的时候，及早拆分。
*** TODO 如何追溯一个事件到底在哪些地方被监听了呢？
*** 代码一旦写的精简了，相互依赖关系就会错综复杂，如果不能很好的理清楚它们之间的逻辑关系，进行良好的解耦，那么维护起来也会非常麻烦，甚至不如各写各的时候。
*** TODO 留意webstrom的自动补全，哪些情况下它是可以识别，哪些是不可以的？
** 2016/11/01
*** graph存储结构，所有的节点、道路、关系都存在graph的entities里面，并且维护了一个waysIds、relsIds的索引，当我们通过节点与道路的id查找这个索引时，能够获取所有它关联的道路与关系索引，然后我们就可以在entities里面找到对应的对象了。
** 2016/11/02
*** git的reset与revert是一个非常坑的东西，reset是reset到你想取消的commit的前一次commit，而revert是revert到你指定的commit，让这个commit恢复到commit之前的样子。
*** 实际上iD整体的设计很多地方是参照了git的设计，比如：
	1、graph的entity对象不可变，多版本共享一个对象以降低内存占用，支持回退；
	2、添加、修改、删除的设计也跟git里的一样。
*** 在每个文件夹中设置一个入口文件，然后这个入口文件引用这个文件夹里面的其他文件。
*** 如果业务逻辑非常复杂，最好实现以后附上对应的需求地址，这样以后忘记是啥意思了还可以翻开来看。
*** if...else...中的重复代码如何抽象，多数情况下，实际上我们是在条件判断的两个分支中用不同的方法算出了两个共同的东西，只要获取了这个东西以后，然后代码就相同了，你可以将除了算这个东西以外的其他东西提取出去，然后就可以将重复代码消除了。
** 2016/11/03
*** 对于一个软件而言，很多时候合理的数据流是始于数据、终于数据的。将数据塞到UI渲染，操作UI产生新的数据，把这些数据通过回调抛回，处理数据并重新与原数据合并，继续传到UI渲染，循环往复。
