* 2017/07
** 2017/07/03
*** 二维码扫描登陆接口总结：
	1. 设备访问服务端生成token二维码。gen_login_token
	2. 手机扫描此token并向服务端发送token请求。token_login
	3. 服务端确认手机token与设备token并向手机返回设备信息，请求手机确认设备。token_confirm
	4. 手机确认设备通知服务端，服务端允许token登陆。
	5. 设备使用token不停轮询，直到成功。is_token_login
	注意： 不同于http两端握手的请求，这是一个三端握手的登陆方案，设备与服务器通过手机这一三方设备的两次握手，完成请求与登陆。手机两次握手，两个请求；瑟尔比请求与登陆，又是两个请求，一共四个请求。
** 2017/07/05
*** 如何管理数据？
*** IMPORTANT 如何提高代码可读性？使用script标签对代码可读性伤害非常大，值得注意。
*** 事件是可视化程序的大脑，是它主导着程序数据的派发与处理。
*** TODO 路由到底占据了一个系统中的多大量的代码，答案是非常大，据我的估计，这个量大概在70%左右。而且越是复杂的系统，其路由也会越复杂，这个比例还会变大。基本上，学会了写路由，你就学会了写系统。
*** TODO 按照文件夹模块化组织，模块内的index.js是模块入口，引入它就引入了整个模块。
*** IMPORTANT 构造dom并绑定数据，由dom获取数据并处理，这就是前端程序的不二法门。
** 2017/07/06
*** 关于defferd对象，它是promise的前代版本，不同于promise使用函数参数作为续处理的方式（executor/resolve/reject）,它使用的是对象式，我们通过$.Deferred()方法创建一个defferd对象，在合适的时机resolve与reject它，并返回这个对象，然后我们就可以在外部通过done/fail/always取到resolve/reject的值。它是处理异步的第一代封装，这种方式能够将我们从callback hell中解放出来，但缺点是稍显麻烦，所以有了promise。
*** 正则表达式真的是一个神器，许多以前难以解决的搜索问题都可以轻松解决了，哈哈。
*** 事实上，gulp有点像Rxjs，多数情况下，我们并不需要自己去写API，只需合理利用它已有的然后我们写一下剩余的逻辑就可以完成绝大多数的任务，这样，我们并不需要知道gulp插件的详细逻辑，只需要拓展就好了.这些插件中，最典型的就是gulp-transform。这几乎是一个万能插件。其他非常通用的插件有gulp-concat,gulp-replace,gulp-if等。
*** 注意这种模式:
	#+BEGIN_SRC javascript
		fna(fnb) --> fna(fnwrapper(fnb))
	    function fnwrapper(cb){
	       let result = somethingself();
           cb(result);
	    }
	#+END_SRC
	这是一种函数劫持，在原始的函数执行流中间插入了一个新的函数，修改了函数的输入，然后再继续处理，需要注意的是，保持fnb的输入接口一致，
*** IMPORTANT 不要直接使用库，特别是你会大量使用这个库的时候，应该在这个库中间使用一个抽象层，重新封装这个库里面的函数，函数名保持一致都没有问题，你也可以自己新设计一套API，这样有许多好处：
	1. 外部库可自由升级。外部库的API总是不稳定的，如果API发生了变化，普通情况下，你需要修改所有调用的地方。但如果使用这种模式，你只需要修改下封装库做下适配你的项目就可以跑起来了。
	2. 外部库可以换。外部库总是有自己的周期，有朝一日，这个外部库过时了，你想换个更新潮的库，那么也没有问题，重新适配一下就好了，其他地方不用修改。
	3. 函数调用可统计。函数调用统计是非常常见的需求，项目发展后期很可能会做这件事，这种代码写在哪里最合适呢，写在封装库里面。
	4. 项目整体更加的有层次感。通过这种方式，整个项目可以有一套非常清晰的命名空间，比如APP.interface.fna()、APP.interface.fnb()。。。
*** 设计模式是非常有用的东西，每一种都是，但是它没有所认为的那么多种，有很多种都在讲述同一个问题，总结下实际下实际上并没有几种。我的总结如下：
	1. 封装模式。这一模式包含非常多的子模式，像各种工厂模式、装饰模式、代理模式、外观模式、桥接模式、中介者模式等都属于这一种。
	2. 迭代器模式。包含责任链模式、命令模式等。相当于是Monad，用来解决无穷流的问题。
	3. 发布订阅模式。它包含生产者消费者模式。用来将动作的产生与处理解耦。
	4. 缓存模式。包含享元模式、备忘录模式、状态模式等。
	5. 解释器模式。用来处理结构化的文本。
	基本上就是这些了。
*** IMPORTANT 对任何系统而言，输入设备都是这个最重要的东西，它是系统最外层的接口，是直接与用户打交道的东西。写代码的时候，这些接口总是系统最上层的东西，这才是一个合理的系统。
*** TIPS 关于paredit的C+right快捷键与M-r快捷键，这可以看成是元快捷键，为什么仅仅这两个快捷键就可以很好的输入lisp了呢？C+right实际上代表着添加，它添加下一个子表达式到列表，M-r代表着删除，它删除一个表达式的外层列表，有了添加与删除，自然基本所有的问题都解决了。还有个就是lisp是一个表处理与他，这两个快捷键都是基于表这种基本元素。
*** emacs的API实际上并不多，很多比较基础的，非常常用的API都没有，需要我们自己来实现，但是实现起来都不难，但是需要我们有基本的API感觉才行。
