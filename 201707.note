* 2017/07
** 2017/07/03
*** 二维码扫描登陆接口总结：
	1. 设备访问服务端生成token二维码。gen_login_token
	2. 手机扫描此token并向服务端发送token请求。token_login
	3. 服务端确认手机token与设备token并向手机返回设备信息，请求手机确认设备。token_confirm
	4. 手机确认设备通知服务端，服务端允许token登陆。
	5. 设备使用token不停轮询，直到成功。is_token_login
	注意： 不同于http两端握手的请求，这是一个三端握手的登陆方案，设备与服务器通过手机这一三方设备的两次握手，完成请求与登陆。手机两次握手，两个请求；瑟尔比请求与登陆，又是两个请求，一共四个请求。
** 2017/07/05
*** 如何管理数据？
*** IMPORTANT 如何提高代码可读性？使用script标签对代码可读性伤害非常大，值得注意。
*** 事件是可视化程序的大脑，是它主导着程序数据的派发与处理。
*** TODO 路由到底占据了一个系统中的多大量的代码，答案是非常大，据我的估计，这个量大概在70%左右。而且越是复杂的系统，其路由也会越复杂，这个比例还会变大。基本上，学会了写路由，你就学会了写系统。
*** TODO 按照文件夹模块化组织，模块内的index.js是模块入口，引入它就引入了整个模块。
*** IMPORTANT 构造dom并绑定数据，由dom获取数据并处理，这就是前端程序的不二法门。
** 2017/07/06
*** 关于defferd对象，它是promise的前代版本，不同于promise使用函数参数作为续处理的方式（executor/resolve/reject）,它使用的是对象式，我们通过$.Deferred()方法创建一个defferd对象，在合适的时机resolve与reject它，并返回这个对象，然后我们就可以在外部通过done/fail/always取到resolve/reject的值。它是处理异步的第一代封装，这种方式能够将我们从callback hell中解放出来，但缺点是稍显麻烦，所以有了promise。
*** 正则表达式真的是一个神器，许多以前难以解决的搜索问题都可以轻松解决了，哈哈。
*** 事实上，gulp有点像Rxjs，多数情况下，我们并不需要自己去写API，只需合理利用它已有的然后我们写一下剩余的逻辑就可以完成绝大多数的任务，这样，我们并不需要知道gulp插件的详细逻辑，只需要拓展就好了.这些插件中，最典型的就是gulp-transform。这几乎是一个万能插件。其他非常通用的插件有gulp-concat,gulp-replace,gulp-if等。
*** 注意这种模式:
	#+BEGIN_SRC javascript
		fna(fnb) --> fna(fnwrapper(fnb))
	    function fnwrapper(cb){
	       let result = somethingself();
           cb(result);
	    }
	#+END_SRC
	这是一种函数劫持，在原始的函数执行流中间插入了一个新的函数，修改了函数的输入，然后再继续处理，需要注意的是，保持fnb的输入接口一致，
*** IMPORTANT 不要直接使用库，特别是你会大量使用这个库的时候，应该在这个库中间使用一个抽象层，重新封装这个库里面的函数，函数名保持一致都没有问题，你也可以自己新设计一套API，这样有许多好处：
	1. 外部库可自由升级。外部库的API总是不稳定的，如果API发生了变化，普通情况下，你需要修改所有调用的地方。但如果使用这种模式，你只需要修改下封装库做下适配你的项目就可以跑起来了。
	2. 外部库可以换。外部库总是有自己的周期，有朝一日，这个外部库过时了，你想换个更新潮的库，那么也没有问题，重新适配一下就好了，其他地方不用修改。
	3. 函数调用可统计。函数调用统计是非常常见的需求，项目发展后期很可能会做这件事，这种代码写在哪里最合适呢，写在封装库里面。
	4. 项目整体更加的有层次感。通过这种方式，整个项目可以有一套非常清晰的命名空间，比如APP.interface.fna()、APP.interface.fnb()。。。
*** 设计模式是非常有用的东西，每一种都是，但是它没有所认为的那么多种，有很多种都在讲述同一个问题，总结下实际下实际上并没有几种。我的总结如下：
	1. 封装模式。这一模式包含非常多的子模式，像各种工厂模式、装饰模式、代理模式、外观模式、桥接模式、中介者模式等都属于这一种。
	2. 迭代器模式。包含责任链模式、命令模式等。相当于是Monad，用来解决无穷流的问题。
	3. 发布订阅模式。它包含生产者消费者模式。用来将动作的产生与处理解耦。
	4. 缓存模式。包含享元模式、备忘录模式、状态模式等。
	5. 解释器模式。用来处理结构化的文本。
	基本上就是这些了。
*** IMPORTANT 对任何系统而言，输入设备都是这个最重要的东西，它是系统最外层的接口，是直接与用户打交道的东西。写代码的时候，这些接口总是系统最上层的东西，这才是一个合理的系统。
*** TIPS 关于paredit的C+right快捷键与M-r快捷键，这可以看成是元快捷键，为什么仅仅这两个快捷键就可以很好的输入lisp了呢？C+right实际上代表着添加，它添加下一个子表达式到列表，M-r代表着删除，它删除一个表达式的外层列表，有了添加与删除，自然基本所有的问题都解决了。还有个就是lisp是一个表处理与他，这两个快捷键都是基于表这种基本元素。
*** emacs的API实际上并不多，很多比较基础的，非常常用的API都没有，需要我们自己来实现，但是实现起来都不难，但是需要我们有基本的API感觉才行。
** 2017/07/07
*** pandoc-mode是emacs家族的又一神器，能够轻松将当前文档转换为其他格式的文档，配合我们自己的快捷键，真是写文档无往而不利之利器。
*** IMPORTANT 关于emacs的major mode与minor mode。将major mode用来做些基础性的工作，minor-mode用来做一些辅助性的工作，例如键绑定paredit-mode、文档格式转换pandoc-mode这样。类似于插件，往主模式中添加一些锦上添花的辅助功能同时不会印象到主模式，实在是一种非常强大的抽象。
*** 实际上，自己写一个color theme非常简单，只需要写几个正则，然后对不同模式的内容标上不同的颜色就可以了，一个正则，一个变色API，就轻轻松松完成了。
*** emacs缺少一些基本的支持，比如基于元素的右键菜单，比如tab的右键菜单这些，这使得它有些时候比较费事。
*** IMPORTANT 词库替换的确是一个非常强大的本地化方案，它不仅可以解决单词问题，句子问题，还可以解决代码块的问题，甚至文件的问题本质上也就是一个文件路径名的词汇替换而已。使用它，我们可以使用在不同的区域下使用不同的value替换不同的单词，句子，段落，文件，非常强大。
*** 关于词库替换的同名冲突问题也不是什么大问题，这种情形下，取两个不同的key名称就好了，这样就可以被替换成不同的名字。
** 2017/07/10
*** tinyurl,提供网址压缩服务网站。这确实是一个需求点，因为http参数一多，网址就会很长，这影响很多地方比如说二维码的生成。通过它生成一个短网址，当用户请求这个短网址的时候由它做个代理，在服务端请求新的网址，并将结果返回给用户，这样能改善用户体验。
*** TODO tinyurl如何设计？？？
*** http状态码，200、300、400都是非常有用的。200用来报告请求成功；400用来报告请求失败；300有个非常重要的作用就是标识缓存
*** 基线台湾版与目前三星版购买流程对比：
	1. 基线是发送了一个tinyurl请求获得了一个短链，然后前端使用这个短链生成了一张二维码图片，用户请求这个图片跳转到购买页面，是前端生成的二维码；
	2. 三星版是通过tvQRCode请求直接在后端生成了一个二维码图片并返回这个图片的地址，前端将这个地址设置到img的src属性上展示。是后端生成的二维码；
	3. 这两者都是通过请求获取了一个字符串，只不过前者二维码展示的是请求地址的短链，由手机去继续请求；后者是已经封装好了的购买二维码。
*** TODO 获取函数的调用关系是一个非常迷人的东西，如果这一步能够使用代码自动生成的话，那么理解起代码来将会变得非常容易。
*** TIPS js正则的img选项中，m要慎用，因为一旦开了这个选项，组信息就丢失了。
*** qrcode.js，生成二维码的js库，还是非常有用的。
*** 直接覆盖同名变量的值是一个非常可怕的东西，这会使得所有的变量都变得不可追溯，产生无尽的麻烦。
*** IMPORTANT 将所有纯函数抽到utils对象（或tools对象）中去，这个对象没有状态，即插即用，可以轻松被新的方法替换，不用考虑状态的问题，这就是状态与非状态和谐相处的秘籍。
*** TIPS setTimeout是一个非常神奇的方法，它代表着时间。当你以为代码执行完毕了，没有其他代码要跑了，它会告诉你不是这样的，还有些在setTimeout里面的代码会执行呢。
** 2017/07/11
*** IMPORTANT 工具函数：
#+BEGIN_SRC javascript
function getPackageJSON() {
	return JSON.parse(fs.readFileSync('./package.json', 'utf8'))
}

function url2ArgObj(url){
    return url.split("?")[1].split("&").map(item => item.split('=')).reduce((preResult,item) => {preResult[item[0]]=item[1];return preResult;} ,{});
}
function url2TplStr(url){
    let argTpl = url.split("?")[1].split("&").map(item => item.split('=')).map(item => {item[1] = '{' + item[0] + '}'; return item.join('=');}).join('&');
    let domainTpl = url.split("?")[0];
    return domainTpl + "?" + argTpl;
}
function url2Code(url){
    let argStr = JSON.stringify(url2ArgObj(url));
    let tplStr = url2TplStr(url);
    let code = `${tplStr}.format(${argStr})`;
    return code;
}
function obj2Url(obj){
    return Object.keys(obj).map(key => key + '=' + options[key]).join('&');
}
#+END_SRC
	http://m.iqiyi.com/pay-tw.html?pid={pid}&platform={platform}&version={version}&uuid={uuid}&mac_address={mac_address}&enter_type={enter_type}&hw={hw}&p2={p2}&hu={hu}&from={from}
	以上工具函数能够快速将链接转化为代码，提高接接口的效率，非常有用。
** 2017/07/12
*** 工厂模式并不仅仅是用来创建不同种类的对象的模式这么简单，它是一个状态管理的容器。在js中，工厂模式通常的实现是在一个函数中有几个状态，然后返回一个管理这个状态的函数，类似于一个类，但表意与写法上有细微的差别。
*** TODO 函数调用树生成。首先需要统计代码中用户定义的函数，然后广度优先遍历AST，这样就可以生成调用树了。
*** TIPS adb调起盒子设置界面命令：adb shell am start -n com.android.settings/.Settings
*** TIPS 关于循环的层数问题，最好不要超过两级，一旦出现二级循环就要考虑到是否需要把这个内层循环搬到一个新的函数中，这样程序整体可读性会比较好。
** 2017/07/13
*** 文件树与dom树一样，也是树结构，自然也可以使用通用树遍历结构来遍历它。代码如下：
#+BEGIN_SRC javascript
function walk(path,callback) {
    let files = fs.readdirSync(path);

    files.forEach(function (file) {
        let target = path + '/' + file;
        let targetStat = fs.statSync(target);
        if(targetStat.isFile()){
            callback(path + '/' + file);
        }
        else if(targetStat.isDirectory()){
            walk(target,callback);
        }
    })
}

walk('./src',console.log);
#+END_SRC
还是再附上dom树遍历的代码吧：
#+BEGIN_SRC javascript
function walkDom(element,callback) {
    callback(element);

    Array.from(element.children).forEach(element => {
        walkDom(element,callback);
    })
}

walkDom(document,console.log);
#+END_SRC
可以看到，大体形式一样，都是循环加递归，但由于文件树需要区分文件与文件夹，所以看起来稍微复杂些。
*** TIPS 追踪代码，特别是前端代码，是有规律可寻的，最大的规律就是UI，通过查看UI上目标对象上的类或id，查找代码中用到的地方，很大的概率你就可以找到这个部分的相关逻辑在哪了。
*** TIPS 数据的规范定义的越严格，写起代码来越是规则，代码量越小，对开发越是有力，改善代码质量，从数据抓起。
** 2017/07/14
*** TODO 古装剧剧中长长出现的阵法到底是什么呢？我们可以这么理解，它就是古代人创造出来的工具，类似于我们现代人创造出的手机、电视这些。只不过我们创造手机、电视是储能于外部。古装剧与我们现代人的差别在于古装剧是储能与内部的。随着科技的进步，有朝一日我们人类真的有可能实现储能于身体内部的效果，毕竟这才是最方便的。
*** 业务抽象的两个层次，底层的按照代码抽象与高层的按照接口抽象。一个是开发的思维，一个是用户的思维；一个是白盒的抽象，一个是黑盒的抽象；按照代码抽象便于复用，按照接口抽象便于使用。两种抽象都是必须的。
*** 继承是代码层次性的体现，父类实现代码结构，子类实现函数功能，每一个层次的代码都能保持在可读可理解的范围内。
*** 对html/js/css跑locales脚本，对js跑babel脚本。
** 2017/07/17
*** 关于sourcemap文件，sourcemap文件实际上就是一个json，里面有这些字段：version（版本）,file(入口),sources（文件列表）,sourcesContent（文件内容）,names（词汇表）,mappings(词汇映射表)，就这么简单，它是可读的。比较有技术含量的就是mappings词汇表了，记录着每个词出现的位置。以分号（；）分隔行，以逗号（，）分隔词，以VLQ编码表示位置对应关系。
*** TODO lazypipe，延迟计算pipe的工具，用于gulp中piper的复用。它实际上体现了一个非常基本的函数本质性的东西————延迟计算，便于重用。延迟计算对重用是非常有利的。正式因为有了延迟计算，我们才能把计算实际尽可能的推迟到运行期去执行，这样我们就有非常多的机会来修改传递给函数的参数，计算的灵活性得以大大提高。
*** TIPS 实际上gulp.watch的问题不在于监听的效率，而是监听之后处理的效率。默认情况下，它会处理所有的监听的文件，不管它有没有改变，这显然会带来极低的效率，只要我们加上gulp-changed,只处理变化的文件，效率自然就上去了。即使是babel转化也丝毫没有问题。
*** 过于繁重的开发任务毫无疑问会阻碍创新，如果时间不够，开发者怎么会有时间学习研究新技术，用更加先进的方法来解决问题。
** 2017/07/18
*** 现有的程序大部分都是同步的，同步IO的一个很大的缺陷就是IO操作占用CPU，如果能将所有的程序全部异步化，那么编程将会变得非常美好。
*** IMPORTANT gulp是一个流处理工具，它实际上就是一个流的monad。只要我们遵守它的规则————流入一个流，返回一个新的流，我们可以在任意一个中间步骤插入我们自己的处理，实现构建流程的定制化。
*** IMPORTANT 什么是monad，monad就是同一种数据类型的一个流。像redux/gulp/promise/rxjs实际上都是monad。我们可以将数据保存在monad中暴露出来，用户可以自己编写函数来处理它，只要返回新的同类型的monad就可以，这样数据流非常清晰，拓展与定制起来都会非常容易。在monad的世界里，程序是不存在选择结构（if），不存在null的，一切都是monad的一个阶段。
*** TODO monad如何处理循环？答案也许是monad不能处理循环，但是monad本身可以是一个数组，这样元素就能一个一个流过monad，这样就处理了循环。
*** TIPS 柯里化非常有用，之所以在实际的代码中很难见到是因为直接写fn()()()这种形式不便于理解，所以，一般它会被拆分成多个return，实际上还是一个柯里化。
*** TIPS 绝大多数的gulp插件代码都非常短，这些插件是用来学习流处理的非常好的教材，比如lazypipe(50行)、gulp-if（20行）、vinyl-path（20行）等等。
** 2017/07/19
*** TIPS 想要请求变得简洁清晰？很简单，勾上XHR请求就好了，因为一般我们发送的数据请求全部是XHR请求，使用它我们可以很清楚的看到系统数据请求的实际与顺序。
*** TODO 实现一个自定义类对象的管理类，实现管理自定义类对象，而不是原生的系统类型。
*** 真正掌握OOP的前端真的不那么多，初学者往往需要花上几年时间才能掌握它，一旦掌握了，就能自己写框架代码了，真正跳出了原生数据类型的限制，能够构建自己的系统了。
*** 代码也是数据，程序运行初期应该先初始化数据，包括管理对象的代码数据。便于后期管理。这也就是绝大多数系统在开始的时候会创建一大堆类对象而没有实际运行代码的原因。
*** 什么是page? page继承自basepage，basepage有几个基本的生命周期函数以及键盘事件处理钩子，用户只需要实现这几个函数就能做出一个页面无缝集成到系统中。具体来说有五个：
	1. onCreate
	2. onStart
	3. onStop
	4. onDestory
	5. onkeydown
*** TIPS 根据 HTML 规范——HTML Standard，拥有 id 属性的任何元素，其属性值将作为 window 对象的属性（自然也就是全局变量）。这也算是一个非常边缘的知识点了。

