* 2015/07
** 2015/07/01
*** c++是可以显示的调用析构函数的，而c#是不可以的。但其实c++当显示调用析构函数是，只是执行了其中的语句，并没有执行内存释放的工作，跟调用普通的成员函数是一样的。但如果析构函数设置为私有的，那么就有作用了，它能防止在堆栈上产生对象，只能new出对象在堆上。这个设计实际上很奇怪，不容易被理解，为什么会这样，很难是人一下子就明白过来。
** 2015/07/02
*** 在类里面可以直接访问整个类的资源，在子类只能访问被声明为public与protected的资源，而在类外面只能访问被声明为public的资源。这种资源的访问控制限制了变量的使用范围，实现了作用域这一非常关键的概念。
*** 作用域的作用很容易被低估，数学之所以发展成现在这样奇丑无比，很大部分原因就是因为数学里面没有作用域的概念。有了作用域，我们才能真正的关注于问题本身，而不用关心烦人的变量命名问题。
*** 实际上控制一个变量只能在栈上创建，只能在堆上创建都是利用的作用域，使用public,protected,private来进行控制的作用域。并不是只有花括号“{}”才能实现作用域。访问修饰符也是非常重要的控制作用域的方法。
*** 作用域是一个非常重要的概念，如何合理设定资源的作用域是一个非常难的问题。如果作用域设定的好，我们能够直接关注问题本身，不需要从其他的地方借调资源，可以取用自己想要的东西，屏蔽掉没用的东西。更好的关注与问题本身，这对更好的解决问题是非常有帮助的。
*** c++中的namespace是用来限定类、对象、函数的作用范围的，通过指定一个高层的名字来限定变量的名字，避免名字冲突。这也决定了我们并不能在类，在函数里面定义namespace，只能使用它们。通过namespace，我们对全局的类，函数，变量进行了分组，降低了同名冲突发生的几率。但其实即使使用了namespace，它里面的东西的作用域该是多少还是多少（其实依然是全局的），依然有全局对象的缺陷（共享、耦合、难以调试等）。
*** namespace实际上并不能设定作用域，用不用它变量的作用域还是那么多。它相当于给里面的所有变量改了一个名字，而不需要一个个的去改，从而简化了工作量。真正限定作用域的只有两个东西，一个是花括号，一个是访问修饰符。
*** const指针非常有用，如果你指针的空间已经开辟好，就等着别人往这块区域填数据了，你不想别人把这个指针改成另外一个值指向另外的地方，那么你就需要把这个指针设置成const。设置成const以后，能减少很多误操作。
** 2015/07/06
*** c#的lock关键字实际上只有在两次进入同一个lock，lock同一个对象（不管是否改变这个对象的值）的时候才会起作用，如果一个函数始终只有一个线程会访问，那么lock实际上是没有作用的。
*** lock还有一个非常关键的好处在于lock可以锁不同的代码，如果在一个函数中有lock一个对象，另一个函数中也有lock这一个对象，那么这种锁的好处就在于你必须等待前面那个函数的lock代码执行结束了才能执行后面函数的lock代码，这样就能在不同的线程中进行代码同步了。
*** 可以自己随便定义一个对象来进行引用计数，自己实现lock，这种lock的优势在于可以更精确的控制锁，比如可以设置允许几个线程调用代码这种高级的操作。
*** c#的struct与class，前者是存放在栈的，后者是存放在堆的。这跟c++都是存放在栈是有很大区别的。这一区别使得我们如果将一个struct赋值给另一个struct，是深拷贝；但是如果将一个class赋值给另一个class，是浅拷贝。
** 2015/07/08
*** 函数的本质是什么？实际上就是等价替换，将一段很长的代码提取到其他地方，或是将重复出现几次的代码提取到一个位置。如果是完全一样的重复，提取出来就是没有参数的函数，如果某些地方不一样，那么这些地方就会变成函数的参数。由于提取出的函数有有意义的名字，而且用较短的代码代替了较长的代码，所以代码的可读性一般来说会更好。
*** 关于c#对象的深拷贝与浅拷贝问题。c#的赋值运算符（=）实际上只会深拷贝栈对象以及堆对象的引用，而并不会拷贝堆对象本身。因此如果想完整深拷贝一个对象，除了要先赋值拷贝栈对象部分以外，还要通过new再赋值的方式拷贝出堆对象部分，这样才是完整的深拷贝。值得一提的是，指针实际上也可以看成是堆对象部分，也是需要单独new再给值的。
*** TODO c#如果一个托管对象被回收，它指向的非托管的内存是否也会被释放呢？
** 2015/07/09
*** 递归是有顺序的，只能从大往小处递归，不能从小往大递归。比如求1到100的和，只能用1作为递归终止的条件，不能用100。
** 2015/07/10
*** static实际上是一种限制，表明这个属性或是这个方法并不为类对象所有，而是类所有。所以在static中不能访问类的对象的资源。但同时也是这种区别于对象的设置，使得static属性或方法可用来
1、做一些统计性的工作，比如对象计数、垃圾回收、单例对象等。
2、用来冒充一下全局函数。比如c#的main、Thread.Sleep()。
*** c#里面子线程不止可以访问主线程的堆对象，还可以访问主线程的栈对象，而且即使主线程的这个对象已经被销毁，如果子线程还在使用这个对象，这个对象就不会被销毁。可以说，子线程其实是完全可以访问主线程的所有资源的，甚至有可能会拓展部分主线程变量的作用域。甚至可以这么说，要不是因为子线程必须写在花括号这种显示的代码层次限制结构中的话，主线程也应该是可以随意访问子线程的所有资源的。
*** 如何使得不论是多么长的数据，都能计算出一样长度的数字呢？很简单，求余，将这份数据分成除数组，然后再每组取一位，这样就实现了将从任意长的数据里面算出固定位数的数字。接下里的问题是这一位如何选取的问题，也容易，每次都取中间就可以。MD5就是用这种分组的思想弄出来的。
*** 其实MD5算法的真正精髓之处在于将数据看成是一个个整数的集合，对这一个个整数进行运算，而不是将数据看成一个个二进制位，对所有的二进制位进行一些位操作。如果你总是用位运算的视角来理解MD5的话，那么你必须将每一个二进制位都参加运算，这样其实是不可能做到MD5的改动任何一位都会产生不同的数值的目的的，因为你必然会遗漏掉某些位数，而这些位数的改变就不会影响MD5的最终结果。正确的算法是一次看64位，把这64位当做一个整数来参与运算，得到相对较短位数的数值，然后使用这个较短的数值继续参与运算。只有将整个文件看做一个超级大的数来进行计算，才能做到变动任何一位都会极大的影响最终的结果。不断的递归，每递归一次，文件长度就缩小一个数量级，这样渐渐的，就得到了一个固定长度的最终整数了。
** 2015/07/13
*** 数学的难度就在于每一个复杂数学问题的解决都要先引出一大堆的陌生概念，然后基于这些陌生概念退出陌生结论，往往入门的陌生概念就要难倒一大堆人，更不要谈先理解了这些陌生概念然后使用它们来进行问题推导进而解决问题了。
*** DES算法实际上是一种非常简单的算法，其基本原理实际上就是首尾两次置换，中间16轮运算，16轮运算中，实际上也是一个按位对应，然后与秘钥进行异或运算的过程。并没有什么特别的。值得注意的是，与base64不同，这种算法并不会改变数据的长度，只会打乱并修改数据的位置。
*** RSA算法的关键是先由乙方产生公钥与私钥（三个数），并把公钥（两个数）告诉甲方，然后甲方再利用公钥（这两个数）来进行信息加密，并把加密后的信息告诉乙方，然后乙方就可以用自己没有告诉甲方的私钥（两个数）来进行信息解密，看到甲方的信息了。它的创新点在于并不需要将密钥整个放在网上传输，而只需要传输一部分，然后就可以完成正常的加密解密了。
*** 破解RSA的关键是知道公钥里面的那个大数到底是那两个素数的乘积，只要知道了这个，由公钥计算出私钥并不难，这样RSA就被破解了。
*** 关于一个代码文件的长度问题，其实也是那个原则――尽量小。其实你会发现，我们总是会花费大量的时间在寻找代码上面，特别是在一个代码文件特别长的时候，那早起来真的就是噩梦，虽然代码导航能够在一定程度上解决这个问题。但是导航其实容易打断思维，还是靠短代码文件，鼠标滚轮寻找自己想要的代码来的实在。在这种情况下，我们应该尽量将不怎么修改的代码移动到其他文件中去，这样就可以缩小自己所需要翻查的代码总量，迅速找到自己想找的代码。
*** 代码文件也应该尽量拆，拆的越小，越不容易产生交集，各自维护自己的代码才是效率最高的方式。如果要修改公共的代码，比较合适的方式是将所有代码放到一个函数里面去，然后只在那个公共文件里面加上一行，这样一旦这部分代码修改了，依然可以只改动自己的代码，而不用去公共的部分上面去改。
*** 尽可能的减小代码之间的依赖，这样进行代码拆分起来会容易很多。滥用作用域很大的变量会导致拆分异常复杂。
*** 如何从已经写好的代码中抽出新的功能模块？
1、如果想不清楚输入有哪些，输出有哪些，那么抽象起来就会异常复杂。
2、如果某些参数不再当前新模块的上下文，第一个应该想到的就是作为函数参数是否合理。
*** 其实static函数还有个限制将代码写在这个类的作用，不如c#的main函数，由于这个函数是static的，所以这个类的main函数里面不能访问这个类的static对象，所以你必须将这个代码搬到其他类里面去。
** 2015/07/14
*** 逻辑理不清或理的不正确，代码也会非常难写。
*** 业务层与逻辑层的分野是非常正常的。业务层需要统管一系列的逻辑，比如如果你做打开相机这件事，你实际上需要做三件事。一、初始化PGR记录。二、初始化同步日志。三、初始化全景显示。这三件事实际上都是打开相机背后所做的事情。逻辑层就是负责统一管理这些所有的事情，决定做哪些，不做哪些事情的。而逻辑层与业务层的区别就在于它只关注于自己的那一小块，并不干其他的事情。在编写代码的初期，往往只写逻辑层，在这里面什么都干。渐渐的你会发现代码太长了，需要抽取出部分代码来只干一件事，逻辑层就出现了。这种分层是渐渐的，过早的提前分层会让代码变得非常难写。
*** TODO 消息机制是否本来就是一个多线程程序呢？
*** 软件有各种乱七八糟，莫名其妙的BUG，很可能是因为逻辑不清楚导致的。这时，重新理清逻辑，大幅度调整代码，是很可能一下解决所有问题的。
** 2015/07/15
*** bool状态量是导致系统复杂性的重要元凶。当需要新的状态的时，要先想下是否需要引入新的状态量，能够不引入尽量不要引入。
** 2015/07/16
*** 如何设计界面持久化，什么时候将数据读进来，什么时候将数据存出去？这部分最后规范起来。使用统一的标准。
** 2015/07/17
*** 其实c++与c#的枚举类型基本差不多，没有什么很明显的区别。但由于c#中一切类型都有一个对应的类，这个类提供了很多比较方便的操作，比如parse、tostring这些之类的。所以使用c#，用户可以用更短的代码来完成更多的事情。
** 2015/07/20
*** 要有自己的判断，即使这个判断是错的，也比没有判断，只会随大流的人要好得多。
*** 何为委托？委托实际上就是一个工具，用它能够将一系列函数头相同的函数给连成一个整体，一旦调用这个委托，就使用委托的参数一个个的调用这些函数，这样就可以实现一个数据，n多操作。更为惊人的是，你可以在任何地方修改这一系列调用，而不需要去修改调用者或是被调用者的代码。
** 2015/07/21
*** 也许一直以来我们学习英文的方法出了问题。阅读时查生词成本太高。所以很多人渐渐就觉得学单词跟用单词本来就应该分开，背单词是背单词，做阅读是做阅读，做阅读不应该去查单词。但其实不是的，如果查单词成本变低（网络查词），我们完全可以变查单词边阅读，这样将查词与用词结合起来了，学习的效果也许会更好。
*** 从上面查单词的例子不难想到，很多时候一些基本的固有属性、本来参数（也就是一些常识性的东西），很可能会无形中误导我们的习惯，让我们认为很多东西是理所当然的，但其实不是。理解了这一点之后，学习起来就不会囿于成见，读死书了，按照自己的感觉，而不是公认的方法。感觉哪种学习方法效果好就用哪种方法，不用在乎那些抱老想法的人的看法。
*** 学习时从概念的源头开始学习那个概念效果是最好的。后人的理解经过一遍有一遍的传递很可能渐渐的出现偏差。使得这个概念越来越难以理解。先从本源学习起，然后你就可以用比较正确的心态看待别人的个人理解了。直接从别人的理解开始学习很可能会陷入迷惑不解。
*** c#自带的xml操作类XmlSerializer有一个很好用的技巧。如果你想从一个很大的对象中去寻找某个值，直接使用调试器去找可能会非常麻烦。这是可以使用这个类将这个对象保存起来，然后再使用其他的工具查找起来就会非常方便。
*** 什么叫做渲染引擎？实际上就是一个很大的对象，我们称之为环境。这个环境有非常多的属性，然后我们只需要给我们关心的属性设置值，当再次渲染的时刻到来的时候，引擎就会自动遍历对象的所有属性并进行显示。由于你修改了部分属性，所以重新显示的时候最后的画面就变了。可以说，只要有显示的地方就有引擎的存在。
*** CPS变换，啊啊啊啊啊，太恐怖了。它让你能够随心所欲的控制计算，而实现起来却简单的离谱，卧槽，太太太太吓人了。
*** 其实continuation-passing style非常简单，不过是返回过程而不是返回结果而已。一般的direct style实际上是eager evaluation的，会马上对表达式求值再进行接下来的计算，而CPS不是这样，它会暂时将过程保存起来，直到最后一个表达式求值的时候才进行整个表达式的求值。相当于完整的保存了调用堆栈，直到真正需要的时候才一步步去处理。
** 2015/07/22
*** c#里面的is与as。as做的事情比is更多，它会先判断是不是指定的类型或其父类型，如果是将将对象转化为该类型，如果不是则返回null。而is则只做了最半部分，并不将对象转化为给定类型。
*** c#的typeof运算符能够获取一个类型的管理对象，这个对象能够获取这个类型的一些管理信息，完成获取方法与属性甚至调用的目的。
*** 对于一个比较大型，相对复杂的软件，要想做的简单，需要软件本身提供几种比较基础的服务。比如数据访问服务、持久化服务、配置管理服务等。dotspatial是这方面做的比较好的一个，可以通过它触碰到编写大型软件、管理复杂代码的技巧。
*** 其实我还是蛮喜欢程序员，蛮喜欢代码这个工作的。看懂别人的代码、使用自己的代码去操纵世界的感觉还是非常好的，与金钱无关。
*** 为什么现在移动端这么火？其实非常简单，是因为计算机的小型化、普及化趋势。在很早以前，计算机非常庞大，只有非常少数几个人能够享受自由计算。后来出现了个人电脑，实现了第一次变小，走进了千家万户。然后出现了笔记本，实现了第二次变小，开始走向了个人用户。然后出现了智能手机，实现了第三次变小，完全走向了个人。然后可以很容易的推测，接下来智能家居、智能机器人会火，因为计算机要走向物品。再接下来植入芯片会火，因为要继续小型化到所有的东西上。最终的目的是使得每一件东西都能享受计算带来的好处，提高所有东西的智能。
*** 计算机是一项很有用的工具，它可以帮助人去做很多无意义的，重复性的劳动。从而让我们能更加专注于自己感兴趣的部分，或者站在计算结果的更高角度上思考问题。有了计算机，人变得更加强大，更加的无可匹敌。
*** 同样的道理，问什么网络会普及？因为它可以使信息的传输不再需要借助于实物媒介，就好像可以凭空通信似的。信息的传递变得无比便捷，能耗小，质量高。
*** c#的this关键字除了表示当前类对象外，还可以表示拓展方法。用于对已有类对象的方法进行扩充。特别要注意的是，这种方法也是写在类方法中的，所以为了防止跟类的this指针相混淆，类与方法都要声明为static的才可以。
*** c#的特殊用法太过，越学越觉得虽然很多人都能用它来编程，但其实真正能够用好它的所有元素的也许并不多。
*** c#中由于所有类都有个公共的父类object，所以可以new出任何自己的类型然后赋值给object，再在需要的时候转化过来，
*** c#的params参数就是c++的变参函数，这种参数类型只能是作为最后一个参数，可以用Length来取这种参数的个数，然后用下标来取各个参数。
*** c#使用typeof来获取对象的类型，用GetType方法来获取类的类型。所以想要判断一个对象是否是某个类型可以这样这样写if(obj.GetType() == typeof (Xxx)) ...。
** 2015/07/23
*** 写代码时，初期可以不讲功能代码抽象到子函数里面去，因为这时候对这部分代码的功能只有个模糊的印象，抽象起来难度比较大，质量也不高，不如先写出来以后再去提取到其他方法里面，这样速度快，质量高。
阿里健康 药品监督？

云计算关键 生态 合作

解决方案？

云计算 未来，我们只需要一台计算机。

云计算就是一项基本的服务，未来有可能像电一样走进千家万户。

以数据为指引，以计算驱动世界。

阿里云团队 安全团队 技术保障团队 

Aws 微软other 

服务本土化 备案

智慧城市（数据中国）

平台与输出能力为主，专门化能力欠缺，拉合作伙伴。

技术实力，中间件
战略，方向明确
综合服务能力。

云计算――硬件虚拟化

编程习惯的改变

是否就是说我买了个虚拟机器就可以在网上发布产品了？

数据生态？

数据如何设计才能最好的服务于各项服务？

思想怎样最简单的改造世界？

云虚拟机器如何安装普通的软件？

公有化的地址其实是个资源，用一个少一个。也许用着用着就没有了。云计算是否能提供一个统一的地址这会是一个问题。

虚实结合的方案

四十种解决方案。

把机器放在云上也许会比放在机房更安全。

以平台为方向，但不会忽略个人。

云计算时代 浏览器时代为什么会失败？

云计算平台如何在个人领域推广？

坚决不触碰用户的数据，这其实是阿里云的底线。

云计算的最大缺陷也许是在IO，这是不管技术怎么进步也不可能达到原汁原味的效果的。

云计算其实我已经在使用了，只是我使用的方式也许跟大众所理解的方式不大一样。
** 2015/07/24
*** 学会生活，学会从你所做的事情中寻找乐趣。如果你觉得做某件事很痛苦，找不到任何乐趣，即使你可以告诉自己做这个有好处，也是必然不能持久的。比如游泳、跑步，再比如编程。要打开自己的所有感觉，用心去发现各种事情中的美。
*** 对于c++而言，结构体与类基本是一样的，其实c++的类就是默认访问属性为public的结构体。它们都是值类型的数据，如果要实现引用，除了使用&外别无它法。但对于c#，它的结构体与类前者是值类型的数据，后者是引用型的数据，是有着很大区别的。它由语言规定了那些数据为值类型，那些数据为引用类型。这种区分实际上并没有c++的灵活当然c#也可以通过使用ref来将值类型编程引用类型，也算小小的弥补了这个不足吧。

** 2015/07/27
*** 关于业务层与逻辑层有个非常重要的区别就是一般逻辑层可以重用，业务层是不能重用的。因为不同的业务要做的事情肯定不一样。但对于某一件事情，它的逻辑其实是一样的。
*** c#中枚举类型前面要带枚举类型名而且是必须的，c++中为非必须。这看似只有一点点差别。但其实由于c#的这种强制限制，使得c#在使用枚举类型的时候比c++更加自然易懂；更为可贵的事，由于这种强制的限制，c#能够做出更加明显的自动提示，是非常正确的决定。
*** 在不断的提取重复代码的过程中，你对业务逻辑、对代码的理解会越来越深。渐渐的，碰到类似的事情你就能够信手拈来了。
*** 由于c++使用函数库比较麻烦，如果你一直使用c++，不使用其他语言，你的思维方式可能会被它同化。本能的认为使用函数库很复杂，不喜欢使用其他的库，宁愿自己写，考虑问题比较喜欢从底层去解决它。这样在处理一些业务逻辑比较复杂的情形时，你很有可能会不习惯于利用现有的工具，容易扎在茫茫多的细节问题上无法脱身。
*** 多学几门编程语言，吸收各门语言的精华部分，才能不断进步。
** 2015/07/28
*** 随着业务的发展，你很快就会发现――原来你对业务的抽象可能是不合适的，一旦你觉得某个函数所做的事情很怪异，跟函数名表示的意思不再一致或是不合适的时候，就要考虑重新抽象，根据新的业务需求重新抽象了。
*** 如果读与写总是在一起的，那么将他们封装在一起是很自然的；可是如果不是，比如只是读入显示并不写或是读入之后会写几份，那么就要将读与写分离开了。
*** 对于面向对象，面向类编程而言，所需要考虑的并不是函数的复用，而是类的复用。所以函数参数的意义会被摆放到次要位置上，类成员也大可不必过于在意是否等同于一个全局变量，所需要注意的只是这个类是否好用。如果它拥有了过多的函数，各个函数之间的调用关系（比如先后顺序、嵌套调用等）错综复杂，那么就要考虑是否需要把这个类再进行拆分，使得它更小更易于使用了。
*** 面向过程与面向对象真的是两种不同的编程模式，前者关注的是函数级别复用，而后者关注的是类级别的复用。前者的使用模式是直接通过函数调用，把需要处理的数据作为函数参数传递给函数，然后再通过函数返回值或是函数参数（指针与引用）来将处理后的结果交付出来。后者的使用模式是先定义一个类对象，然后通过一个或几个类函数给这个类传入要处理的数据，再通过一个或几个类函数进行数据处理，最后再通过一个或几个类函数来交付处理结果。显然，面向对象可以将输入、处理、输出的每个步骤都分为几个函数来完成，用户可以选择是否调用这个函数，并且能够暂存调用后的成果，这无疑大大加大了函数调用的灵活性。
*** 目前主流的编程语言都只支持返回一个值，如果要返回多个值只能通过各种乱七八糟的奇淫巧计比如：
1、将多个值的指针或引用作为函数参数传递进函数，调用后取这些参数的值作为返回值。
2、将所需要返回的几个值封装成为一个类或是结构体，然后函数体中填充这个类或结构体的各个字段的值，然后再返回这个结构体。这种形式往往还和void指针一起发挥作用。
3、使用object数组，然后再需要的时候进行强制类型转换。
这些方法其实都只是在语言不提供这种功能的时候所作出的一种妥协，虽然能在部分场合勉强满足需要实现一些东西，其实都有各自的弊端。用这些方式写出的代码要么形式极丑，要么效率低下，要么使用不够灵活。也许我们完全可以设计一种语言，它能够返回多个值，并且是强类型的。这样就可以以更加接近于现实世界的编程，说不定还可以创造出一种新的编程模式。
*** 面向对象编程虽然可以大大加强函数调用的灵活性，完成更加复杂的事情。但其实也有局限性，就是它强行将所有的东西看成是对象，这样，当我们其实只需要一个过程的时候，使用这种语言想要完成这件事必须使用某些奇淫巧计来对这个东西进行下改装，但其实改装出来效果总有这样或那样的局限，无法达到原汁原味的效果。
*** 大多数面向对象的语言里都缺乏正确的实现一等函数的机制；大多数函数式语言都缺乏正确的实现一等对象的机制。这两种语言其实是两个极端，各自有自己的优势与缺陷，需要被不断的融合才能更好的为我们服务。
*** 目前面向对象编程所碰到的最大问题就是并发，面向过程编程所碰到的最大问题就是副作用。
*** 原来我没有考虑到读一次后需要写几次，以为总是一读一写，所以讲读与写写在一起。现在一读之后要两写的话，直接在以前的代码上增加一次写的话会使代码逻辑看起来非常混乱。最好的解决方法是读写分离，一次读，多次写，这样要写几份都不会有问题。
*** 对一份代码的持续改进是非常锻炼人的事情。
*** 关于面向对象编程里面类函数的参数的问题是一个非常值得玩味的事，其实有个很简单的原则：
    如果某个属性只需要设置一次，设置好以后在这个对象的生命周期以内这个属性值不再变化，并且此属性会被多次使用到的话，这种属性适合在初始化的时候赋值，作为这个对象的固有属性，而如果只是在某个类函数调用的过程中临时的使用一下而已的话，这种情况适合作为类函数的参数。
    所以，并不是说面向对象时对象的属性可以通过初始化函数来设置其他函数就不再需要参数了。能够通过初始化函数来设置的参数往往是一些比较持久、不易变的属性。对象还有很多临时性的属性仍然需要在函数初始化后的其他函数中设置。
*** 会使用类成员变量并没有什么了不起的，会使用函数参数也并没有什么了不起的。难的是会配合使用这两者。知道应该讲那些数据作为类成员，那些数据作为函数参数，将两者配合起来以最少的代码来完成事情。
*** 类的静态成员函数与非静态成员函数的差别――静态成员函数往往是一些工具函数，一般有自己的输入与输出，它功能的实现是不依赖于其他类成员的，与具体对象无关。它不能访问或是改变对象的成员，相当于类里面特立独行的一部分代码，很多时候可以提取到类外面去，之所以放在类里面也许是因为它属于类名，而不是类成员。
** 2015/07/29
*** SVN使用技巧――要熟练的使用SVN，对每个VS的每个文件（包括工程文件、解决方案文件）都要有个比较清晰的认识。因为有时候即使更新了，有些文件也会因为某些稀奇古怪的原因而更新不到，这是就需要你手动去根据工程所报的问题去可能出现问题的文件里面去查找问题所在了。
** 2015/07/30
*** 任何人拿到一份任务文档的时候最后的落脚点一定是――我到底要做点什么。比如生产给研发提需求，研发人员拿到需求文档以后，也许会先花点时间整理理解需求，但最后重点考虑的一定是――我需要做什么。所以，写文档的人一定要多站在看文档的人的角度考虑。
