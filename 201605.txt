* 2016/05
** 2016/05/01
*** 一个函数如果能使用循环给写出来，那么使用递归也一定是可以写出来的，而且这两种方式写出来的代码存在在一些联系，我们可以轻而易举的将一个使用循环写出来的函数轻松转换成递归方式，转换起来也很简单，先将for变成if，然后将循环中所使用到的变量全部变成函数的参数就好了。实际上，我们甚至可以说，循环是递归的另一种写法。
** 2016/05/02
*** 一个函数写的越长，发生命名冲突的可能性就越大。
*** 写一个解释器时，第一步就是对表达式中的字符串进行结构化，只有结构化的数据才能表现出意义，也只有结构化的数据我们才能比较方便的存取出数据里面的各个部分。
** 2016/05/05
*** 递归实际上体现着一种自治的想法，无需外接函数干预，自己就可以实现自己的功能。
*** 不要使用基本数据类型，应该使用封装的，这样才能为以后的拓展留下空间。封装能够提供一层抽象屏障，将开发人员与使用者分开，这样开发人员就能只有的改变内部实现而不用通知使用者。
*** 到底什么是解释器呢？解释器也叫求值器，其本质不过是一堆可计算的符号以及一些一些分隔符。然后求值时我们需要对每一个符号进行求值，每个符号有自己的求值规则，可能会用到旁边的符号的值，最终达到化简的目的。这种求值规则叫语法。
	如果求值规则太多，那么必然会给学习者带来巨大的记忆负担，所以每种语言都只提供少数的几种求值规则，主要包括变量、函数、函数调用、变量绑定、条件、循环、类等。通常来说，使用最多的求值规则是函数与函数调用，这种规则是说一个函数后面会跟上一堆符号叫做参数，然后共同被保存在某个地方，当函数调用发生时，解释器会去找到这个函数，并将具体的调用参数添加到这个函数的环境中，然后进行递归求值。
*** 最简单的解释器实际上只要有变量、函数、函数调用这三种结构就可以了（lambda演算）。然后我们可以使用这三种结构拓展处所有的东西。其他常见的语法规则像条件判断、循环等都可以用这种语法规则给推导出来。就拿条件判断if来说，if实际上可以看成是一个函数，像(if predicate trueExp falseExp)这种实际上可以是一个函数调用，我们定义了if的求值规则，提前说明了如果predicate为真就计算trueExp,如果为假就计算falseExp，然后当我们调用这个函数时，具体的参数值被赋上，然后我们就能计算这个函数的值了。
*** 在所有编程语言的函数中，能够定义语法的语言屈指可数，绝大多数的语言都只能对函数体内部的表达式一个个求值，一个不多，一个不少，它们无法控制哪个表达式需要被求值，哪个不用，更不要说对其结构进行变换了。lisp能够通过反引号对是否对表达式进行求值进行控制，从而获得了可编程的编程语言的美誉。但除了lisp以外，能够做到自定义语法的语言几乎没有。
*** 如果编程语言没有自定义语法的能力，那么像if条件判断这种求值语法就不能被等价成为函数，在这些语言中，只使用三种基本的结构就无法实现很多结构，求值能力就非常弱。
*** 树只能有一个根节点，不能有多个，有多个就不叫树了。
*** lisp的语法树到底应不应该包含括号呢？其实从原理上来说，如果一个元素是一颗树而不是一个字符串，那么这棵树必然是要被括号所包裹的，此时再在树的两端添加一个括号完全是画蛇添足，但是如果我们考虑这种情况，
** 2016/05/06
*** 浮点数的数据范围远远大于实际的二进制位所代表的信息量，那么多出的那一堆数被表示到哪里去了呢？答案是浮点数是不精确的，一个二进制位信息位实际会代表一大堆的浮点数，浮点数实际的个数基本上是无穷的，计算机无法表示这么多数，只能先照顾最常用的浮点数，因此对于小数位比较短的数，基本上是一对一的，但当小数位比较长了之后，那些数用的比较少，就只能使用一对多了。
** 2016/05/08
*** 为什么所有有对象的语言都不约而同的设计了一个this关键字，用来代表当前对象呢？因为对于对象的设计者来讲，具体的对象尚未构造出来，此时要想表示出这个对象，当然只能先用一个this变量代替。
** 2016/05/15
*** 其实在0.0.2版本的jsScheme版本的解释器中，我已经实现了基于词token的计算，但却没有完成基于语法树ast的计算，导致虽然不需要分词了，但还是需要分语法元素，这也许是jsScheme效率依然很低的原因。
*** 一个程序效率到底怎么样，算法是一个方面，但数据结构也许更加的重要。因为算法是基于数据结构的，如果数据结构简单，我们能够规避很多不必要的运算或是重复运算，这将极大的提高我们的程序效率。
*** 程序的结构化层次越高，跑起来就会越快，因为无需重复的解析。就比如jsScheme解释器，起先基于字符串进行计算，这种方式基本就是无结构的，我们需要多次的去做词法分析，语法分析，效率自然惨不忍睹；然后改成了基于词（token）的计算，这个时候不需要重复做词法分析，只需要做语法分析就可以了，效率自然大大提高；但如果改成基于语法的，这样语法分析也能够一步到位，效率必然还能大大提高，这也是我接下来要做的。
*** 对程序的改进有时候是灵感突发，但多数时候是循序渐进的，也许改着改着慢慢就会有思路。
*** 不要总是只考虑性能，直接从可读性上面开始优化代码，也许能够有另一番优化天地。
** 2016/05/16
*** 变量能够使得某一部分具有静态的可修改能力，而函数能够使函数这一部分具有动态的可修改能力。在编程中，如果需要某一部分可变，最好的方法就是将这一部分抽象成变量或是函数。抽象成变量，则这一部分可在运行前配置；抽象成函数，则这一部分可在运行时动态调整，要根据具体的需求选择抽象成哪一种方式。
*** 慎用js的eval函数，因为它需要重新解析字符串，这会导致性能大幅下降，可以的话，直接使用直接解析出的语法元素进行求值效率会好的多。
** 2016/05/17
*** 程序优化心得，尽量使用低成本的数据结构比如整数、浮点，减少大消耗新的操作，比如数组拷贝、移动等。
*** TODO jsScheme也许继续升级不是升级成为基于语法树的计算，而是升级为基于下标的计算。只需要tokens,current,length这三个参数就可以完成计算了。基于下标的运算也许是这一计算方式的性能极限了。
*** 不要频繁使用unshift，更高效的方式是在最后使用一次reverse。
*** 接口可以屏蔽数据结构，使得我们可以使用更优的数据结构来表达程序，获得性能提升的同时又不影响现有用户。
*** 函数调用是如此的频繁以至于我们必须保证其性能。想做到这一点，首先需要规范数据结构，当函数调用发生的时候尽可能的少做其他事，虽然有些操作是必须的，但我们可以尽可能的较少操作发生的次数。
*** 没有优秀的数据结构支持，想要把程序的性能做上去非常困难。
** 2016/05/18
*** 在上层将递归封装起来，上层少使用递归，但底层要多使用递归。
*** 不要使用标签来进行表示窗口的每一部分，因为使用者需要进入到代码实现里面中去寻找这个控件有哪些部分。应该提供简单易用的函数接口去给别人只有的选择的权利。
*** 在原有控件上封装一层是非常常见的编程套路，必须掌握。
*** 什么是框架或者说函数库？框架或函数库是在你写代码的过程中能够帮助你完成某些常见操作的工具函数，多使用它们能够使你写代码的效率大大提高。
** 2016/05/19
*** 实际上不管是什么样的应用架构，其核心都是一样的。不管是MVC、MVP、MVVM、FLUX还是其他的什么，其核心都只是一个用来解决双模型同步的一种方法而已。用来展示给用户的一个模型，用来存储的一个模型，这两个模型由于关注点不一样通常是存在差异的，不能统一处理，但分开之后也有分开的麻烦，就是两个模型的同步，这是就需要第三个部分介入了，不管是哪个架构，其核心不外如是。
** 2016/05/23
*** 什么叫可定制?可定制实际上是一种使得界面可变的方法。
*** 数据库建模的意义在于将数据结构相同的对象放在一起，以便于统一管理，所以，对于数据库建模，能否识别出是重复的数据结构是关键，建模的质量也就在此了。
*** TODO 代码写的越久，就越不敢动别人的代码，呵呵，因为动别人的代码容易动出莫名其妙的BUG。逃避问题而不是解决问题，我怎么也渐渐变得这样了呢？
*** context实际上就是前段的数据模型接口，所有的数据操作都要使用"context.perform"来进行。
*** TODO 生活在现实世界，我们都喜欢把真实的自己给隐藏起来，藏的越深越好，努力让自己变得像一个正常人，越是长大就越是这样。比如不敢在人群中大喊大叫，即使有时候真的想这么干，因为这样容易被周围的其他人当成疯子。我们的喜怒，我们的欢笑与哭泣，我们的情仇，越来越容易被周围的事物所操控，变得我们自己都不认识了，仅仅是因为这样，我们能够更好的融于一般人的世界。渐渐的，我们放弃了自己的理想、爱好、志向，渐渐变得得过且过，凡事讲求个差不多就好了。这其实是大多数人所无法逃脱的宿命，但是――――这不是我想要的，我不像像这些人一样，逐渐变得整天只知道为生活而忙碌，却不知道这样的忙碌是为了什么。大多数人会选择把自己的梦想寄托给下一代，期待他们能够替我们完成梦想，但却最终悲哀的发现，他们的下一代，也会渐渐的变得希望下一代。为什么自己的梦想不能自己来完成？人的一生，就应该活的潇洒一点，不要太在意别人的眼光，也不要与其他人去攀比，想干什么就去干，即使失败了也比没有尝试过来的好。
** 2016/05/24
*** 什么是回调？回调实际上就是放权，将某些数据交给其他地方去处理，而调用回调的这一方只需要回调的结果，这是典型的框架写法。通过回调可以完成数据流出。
*** 什么是状态？
*** 数据查看，不管是显示的道路还是隐式的关系，都应该被显示出来，这样才能给人以反馈，如果是错误的，能够及时纠正。
*** React 组件非常简单。你可以认为它们就是简单的函数，接受 props 和 state (后面会讨论) 作为参数，然后渲染出 HTML。正是由于它们如此简单，使得它们非常容易理解。  ――――React《数据呈现》
*** 我们始终坚信，组件使用了正确方法去做关注分离，而不是通过“模板引擎”和“展示逻辑”。我们认为标签和生成它的代码是紧密相连的。此外，展示逻辑通常是很复杂的，通过模板语言实现这些逻辑会产生大量代码。
	我们得出解决这个问题最好的方案是通过 JavaScript 直接生成模板，这样你就可以用一个真正语言的所有表达能力去构建用户界面。为了使这变得更简单，我们做了一个非常简单、可选类似 HTML 语法 ，通过函数调用即可生成模板的编译器，称为 JSX。
	――――React《JSX语法》
*** make data visible，then alternative can become possible.
*** 编码―――定义变量（包括函数变量）就是一个编码的过程，正是因为编码，我们才能操纵。实际上，编程就是一个编码的过程，我们给所有的东西取一个名字，然后对这些东西进行分类，按照我们的要求进行进行取用并进行计算，这就是编程。
*** 我走过山的时候山不说话，我路过海的时候海不说话。 ――――金庸《神雕侠侣》
** 2016/05/25
*** 数据的输入输出实际上都可以抽象为数据流动，任何一个函数、组件或类，其核心都只不过是要处理下数据流动，数据如何流入，如何进行处理，如何流出，这就是它们说需要关注的所有事情了。
*** 如何处理数据的流入流出是一个非常关键的问题。对于一个普通的函数来说，数据流入的途径只有两个，一个是通过参数，一个是通过外部变量，不过比较推荐的是通过参数；而对于数据流出，途径就比较多了，首先容易被想到的就是通过返回值，还可以通过参数或是外部变量，通过修改传入变量的值实现传出，还有一个非常容易被人忽略的流出途径――――回调函数。我们可以将回调函数传递到子元素，这样子元素可以在合适的时机调用这个函数，把参数绑定到这个函数并完成代码调用，行使函数的功能。
*** TODO 通过函数来传递参数是一种非常重要的参数传递模式，必须牢牢掌握。
*** React中，仅仅使用它的props就可以实现数据流入与传出了。当我们需要把数据流入到组件的时候，直接将数据通过数据对象传递到组件就可以了；当我们需要把数据流出组件的时候，不要直接传递数据对象，传递回调函数到组件，这样当组件发生某个事件的时候，它可以通过调用传入的回调将数据传出，这样我们就能够获取传出的数据进行处理了。
*** 函数非常重要的一个特性就是延迟计算，这句话得分成两部分来理解，一部分是延迟，一部分是计算，延迟是说它能够把要执行的语句放到后面去执行，计算是说它会延迟绑定，在需要的时候才绑定值，这种特性非常适合于函数库的编写。
** 2016/05/26
*** 实际上，使用let先绑定然后求值的写法比使用函数调用隐式绑定求值的写法更加的容易看懂，我们应该有意识的使用这种写法而不是直接使用函数调用。
*** TODO 跨平台为何如此强大？无论是各种各样的开发，发展到最后都是趋向于大一统，使用一套方式终结所有其他的东西。
** 2016/05/27
*** 适度的代码冗余可以降低代码的耦合度。
*** json的数组（"[]"）实际上就是一个有序列表，而对象（"{}"）就是一个无序列表，灵活运用这两种数据结构，不管你需要什么样的列表都可以轻松的弄出来。
*** 使用数据流动的思想来重新理解d3的本质，d3使用select与data函数进行数据绑定，使用select与选择dom元素，使用data把它与数据进行绑定，这样就完成了传递数据到dom中，然后我们就可以使用这个进行数据渲染了。这一整套流程是一体的，并且每次只可以处理一个维度的数据（也就是一个普通数组），如果碰到数组里面嵌套数组的情况就需要多次进行select与data了，要注意。
*** 实际上，通过d3的select与data之后，我们只是对数据进行了重新分组使之更加容易使用，并没有漏掉任何一部分信息，因此我们依然可以对这些dom与data进行任意操作，我们并没有损失某些能力，只是使得某些功能实现起来更加的容易了。
*** 封装的目的是什么？就是为了拓展，只有封装了才能拓展，没有封装，拓展根本无法谈起。
** 2016/05/28
*** d3的核心在于data函数，通过data函数将数据绑定到选择到的dom元素上，完成数据绑定，这种绑定是正向绑定；还有一种形式是反向绑定，即将dom绑定到数据，这种绑定如何实现呢？首先使用select选择一个空元素，然后使用data与enter就可以拿到新的数据集，然后使用append就可以完成反向绑定了，实际上这种写法非常奇怪，非常不利于网页的编写。
*** js的this是否就是环境里面的一员呢？答案是――――是的，this外部环境中的一个变量，当函数调用发生，进行参数绑定的时候，会把外部调用这个函数的对象绑定到this里面，这样我们就可以使用这个变量了。
** 2016/05/30
*** js的this是在函数调用时绑定的，实际上this就是一个函数的隐藏参数，所有函数调用都需要把这个给绑定到函数体内部。这一点从使用apply与call进行函数调用表现的更加明显。
*** d3的select实际上是一个取dom元素的过程，这个取不止是可以从html里面使用querySelector去取，还可以从d3的selection里面去取元素。
** 2016/05/31
*** webEditor特效实现原理――――通过layer的setOptions给layer注册了两个方法（style方法与nodestyle方法）并在渲染的过程中判断存在这两个方法的时候就调用，这样当用户通过点击按钮注册了方法下次调用的时候就可以直接表现出来了。

