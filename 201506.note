* 2015/06
** 2015/06/01
*** 使用类来组织代码虽然能够使得在外部看起来代码的机构很清晰，但却会使得类内部的代码结构混乱，难以让人看清楚类内部的逻辑，还有类成员变量的滥用会使得类内部的“全局”变量漫天飞，非常不容易看懂，写起来也不好写。
*** 程序的三要素――IPO，输入、处理、输出一个都不能少。有时候我们会忽略掉输出，但其实输出很重要，一个没有输出的程序没有任何意义。值得注意的是，程序的输出并不一定是返回值，也可以通过其他方式比如声音，对话框，颜色等等来表示。只要给人一个反馈，输出可以是任何东西。
*** 作为一个大软件某部分的编写者，如果总是只看着自己的这一部分的话，很容易陷入误区。应该站在全局的角度来思考问题。
*** c#的问题在于关键字太多了。对于一种语言来说，每多一个关键字，关键字组合的情况就会呈指数级别上升。很难想象有如此多关键字的语言还能好好的活着。
*** 设计一个可遍历的数据结构还是非常重要的，lisp之所以如此强很大的原因就是因为表这种可遍历的数据结构，帮人们节约了parse这个巨大的开销。emacs的org-mode就是典型的可遍历结构。
** 2015/06/02
*** 在抽象这一个问题上，将所有的函数都拆分成短函数有的时候也许并不是一个聪明的做法。殊不知，你在拆分函数保证一个函数里面的代码容易理解的同时，也在无意中加大了函数与函数间理解的复杂度，过多的函数容易造成理解的困难。正确的做法是――如果经常需要改动的代码，这部分逻辑清晰非常重要，那么短函数是必须的。如果一个部分代码几乎永远不会改变，那么将它拆分，就不是一个明智的决定了。
*** 减少侵入性是一个很重要的编码要领，尽量少改动别人的代码，减少与别人的交集，可以避免很多不必要的麻烦。
** 2015/06/03
*** TODO 实际上组织代码是个非常复杂的学问，不管是通过文件，通过函数，还是通过类，通过消息，通过委托，通过槽，其本质都是在寻找一种更加理想的方式来组织我们的代码，使得它在规模足够大的时候仍然能够保持清晰的结构，以便于修改。这个问题也许需要我花费一生的时间来思考。
*** 对于计算机来说，图形界面跟文件系统一样，是一件慢速的外设。既然是慢速的外设，就要注意尽可能地减少在这件外设上读写的次数，而应该尽可能的将数据保存在内存这种高速的内部存储上面，只有在真正需要的时候才将数据写出到外设。这样才能充分的利用内存。
*** 其实使用消息机制来进行组织代码的最大作用是进行代码层次提升，防止因为树形结构层次太深造成的代码复杂，难以理解。
*** TODO 设计一个轻量级的非常容易序列化与反序列化的文件格式而不是像xml或是json这种复杂的格式。
*** 程序一旦中途崩溃，保存在内存中的所有数据就会丢失，这时候如果这部分数据还没有写出到外设中，那就丢失了，所以虽然要尽量减少外设IO，但对于日志这种特殊情况，却必须多进行IO操作，防止在意外崩溃的时候导致的日志缺失。
*** 封装其实可能有这样的情况，你无论怎么封装都只能满足绝大多数情况下的需求，但有些时候会出现非常奇怪的特例需求，这是各种封装都会失效，这是你就不得不接触底层去重新针对这个特例去写一个方法出来。
** 2015/06/04
*** 其实做软件（特别是工具与服务）的最高境界跟机器非常像，就是完全自动化，不需要人工干预。但要想在短期内实现全自动化不是那么容易。但要有这个概念，在做的过程中尽量较少人工干预，能用软件自动做的尽量使用软件来做。
*** SVN里面只有自己动的文件可以随便上传下载，如果几个人同时要修改的文件，上传下载前最好跟相关人员商量下，这样冲突就会少不少。
*** 什么叫做垃圾回收机制？垃圾自动回收就是一个自动进行资源管理的程序。这个程序一般运行与后台线程，完成对所有对象资源的管理。具体的管理工作包括开辟，释放空间、移动对象等。它一般会在一开始就开辟一大块内存，有点类似于c++的堆栈，但它空间更大，一般要足够到所有程序运行才行。然后每当有对象需要new的时候，他就会查找剩余的空间，分配一块足够的空间并把空间的引用给对象。一旦空间不被任何对象引用的时候，这块地址就会被回收。垃圾回收机制：集中的管理了所有对象的资源，不用程序员再去操心内存分配与释放的问题了；由于集中管理了所有的内存，必然带来内存管理算法的优化，所以是很有可能超过没有垃圾回收程序的性能的。但同时也会带来新的问题，比如：对象地址不再固定了，随时可能会变化；要定期执行全内存整理，这种随机的整理可能会导致程序意外的卡死；提前分配了过大的内存，导致内存的浪费（这其实是lisp虽然如此牛逼但以前却流行不起来的重要原因）。所以垃圾回收是个有利有弊的东西。
*** lisp为什么需要垃圾回收？lisp的垃圾回收实际上管理的是非常长的字符串，所有的运算都是基于这些字符串进行的处理。如果没有垃圾回收，杂乱无章的对象很可能会导致lisp运行效率的低下，因此必须使用垃圾回收。
*** TODO unsafe关键字表示接下来的代码块是一块不安全的代码，为什么要进行这种标识？标识了以后CLR会有什么不同的操作吗？
*** 事件机制实际上还有一个非常重要的作用，用于在两个类之间对象进行通信的同时彻底解耦。
** 2015/06/05
*** 关于代码的可控性问题。我其实是很在意的，我习惯于完全自己来编写代码，而不使用别人写好的现成的库，就是因为我希望所有的代码总是在自己可控的范围内，不会出现出了问题还要去查别人的API解决问题的情况。
*** 一个函数的输入只能从外部环境（包括全局变量与类变量）或是函数参数处取得。这两种获取输入的方式实际上是有着微妙的差别的，特别是从函数参数取得输入。这种方式的优势在于你可以很方便的修改参数环境，而不会对外部环境有任何的影响，这在递归时将非常有用。其实一个函数执行的过程中，经常会碰到临时需要改变环境的情况，这种时候如果改变外部环境，显然会对其他函数的功能产生影响。如果把环境作为参数传入，则可以避免这一问题，既保证了函数功能的实现也不会影响到其他函数，真的是非常划算的事情。
*** 把外部环境作为函数参数传递进函数能够使你获得一个可以随时改变的环境，这在很多时候对函数功能的实现是有非常重要的作用的。你可以通过递归随时改变环境，实现函数的功能。
** 2015/06/08
*** 为什么要抽象？实际上很重要的一点，是为了保证代码的单点可修改性。不要小看这句话，代码的单点可修改性是一个非常重要的东西。我们之所以不断的抽象，不断的找出共通性，消灭重复代码，就是为了获得单点可修改性。单点可修改性使得我们能够以最短的代码解决最复杂的问题，同时在出现问题的时候能够快速定位，解决这个问题。这最后必然带来效率的提升，这不就是做软件的终极目的吗。
*** 一个类如果写的过大，必然导致成员变量的滥用。在类里面，成员变量就是全局变量。也就是说，必然会导致类全局变量的滥用，所造成的后果你懂的。
*** 在编程中，效率，特别是编程效率永远是第一位的。如果你能不使用库却能达到甚至超越使用库所带来的效率提升，那么使用库就没有什么必要了。
*** 不要重复造轮子这句话根本就是错误的。最初的原话是不要重复发明轮子。原来说这句话的人是希望我们多看书，多学习，不要从头去解决已经被别人解决了的问题。却被很多人误解成为了不要写重复代码，这真是莫大的讽刺。其实重复造轮子确实是必要的，只有通过重复造轮子，你才能理解那些非常复杂的轮子是怎样被造出来的，有哪些优缺点和使用范围，从而更好的利用这个轮子。
*** TODO 递归统计文件夹中文件数目的工具。
*** 也许我应该尝试站在更高的层次上去审视代码结构，解决问题。我总是习惯于从底层去审视，这样容易看不到整体，不能很快的理解问题。
*** 面向对象编程的一个很大的缺陷在于――它虽然能使代码组织的更加清晰
** 2015/06/09
*** 面向对象的的编程是一种基于接口的设计方式，也就是说，它虽然会打乱类内部的实现逻辑，但却能对外提供比较清晰的接口，这一点确实是面向对象编程的一个巨大优势。
*** 将一个函数转换成为类非常简单，只需要将所有的函数成员转化成为类成员就行了，（注意函数的调用顺序哦）简单粗暴，呵呵，慎用。
** 2015/06/10
*** 多数情况下，使用全局变量（包括类成员变量）并不是一个好主意，而且多数时候可以用函数参数来取代这些全局变量，一般直接用普通的成员变量就可以了，但如果函数由于递归需要保留所有调用的结果的话，使用引用是不错的选择。
** 2015/06/12
*** 内存虽然速度快，能够与CPU很快的进行通信。但它跟CPU终究不是一个东西，读写一次就是一次IO，所以你会看到像频繁设置SetPixel这种操作还是非常耗费时间的，相比之下，使用memcpy这种一次的IO就会快很多很多。
** 2015/06/13
*** lisp对list有着发自天然的处理能力，但对于不是使用list作为参数的函数，即使是使用变参，处理起来也比较的乏力，所以最好还是先将参数表示成list再进行处理。
*** 人总是擅长于根据现象总结出规律，这些规律又能反过来帮助人们来理解现象。比如数学里面有很多化简公式的规律，我们利用这些公式来化简复杂的表达式。最后化简出来的结果也许非常简单，很可能让你茅塞顿开，为啥没有一开始就采用这种思维，直接写出结果呢。这就是规律的力量，我们可以使用规律来加深对问题的理解，虽然有些规律乍看之下好像没什么用。
*** lisp里面可以使用or来简化最后两个表达式，直接减少一种情况，简化代码，有时这种简化还非常有助于我们理解我们所解决的问题。
*** 实际上，时间管理能力是一个非常重要的能力。一个人如果能够把时间掌握在自己手里，做事的效率将大大提高。现实生活中经常发生这样的事，你本来想做这件事，然后突然弹出一个你很感兴趣的东西，然后你就分心去看那个东西了，看着看着旁边还有很多跟那个东西相关的新闻推荐，然后你不听的点点点，然后时间就这样浪费了。最后你回过神来，我要做的是啥来着，效率非常低。站在产品经理的角度，他们的任务实际上只有一个，偷走你的时间。他们总是会想出各种各样的套路来偷走属于你的时间，让你去专注于他们的产品。你越是喜欢跟着他们走，你就越难以得到自己的时间，越难以进步。甚至从某种意义上来说，他们实际上是你的敌人，他们想偷你的时间，而你想留住自己的时间。
*** 就我自己而言，我的时间管理的能力应该还算是可以的。我会留出很多时间来给自己思考，而不是被周遭的各种乱七八糟的有趣玩意牵着鼻子走。我会主宰自己的时间，而不是让时间被消费。这样带来的好处是很多时候我能一语中的，一眼看穿一个东西的本质。能够意识到这些的人还是很少的，因此我也必须习惯孤独。
*** 现在这个世界是个非常浮躁的世界，各种乱七八糟有趣的东西漫天飞，我们很容易被这些东西吸引，偏离自己原本要做的事。这样造成的后果是――你可能见闻非常广，各种东西都知道。但都只是停留在表面，缺乏深度。现实世界倾向于把人培养成这样一种模样，这种人格适合于跟别人交流，毕竟你啥都能聊，能够把问题描述清楚，但由于没有深度，不能解决这些问题，没有创造力，无法把我们的世界建设得更好。实际上这是享受型的人格，直接坐享其成就行，不用再为怎样创造出这些东西操心。这似乎是社会发展的必然，毕竟社会越发达，人民生活起来越容易，谁还没事找事的去搞研究。这种人格非常不利于进步，只能保持甚至退步。
** 2015/06/14
*** 其实循环虽然简单好用，但也存在很大的缺陷，这个缺陷就是不容易递归。循环只能在每次循环的时候做同一件事，而递归却可以在每次的时候做不同的事。
** 2015/06/15
*** 多线程的本质是利用多个CPU来并行完成任务，能够并行的条件是资源确实是有多份。比如多个CPU就是典型的资源有多份的情形。CPU是有多份，但有些东西却并不是多份的。实际上，绝大多数的共享资源都不是多份的，比如磁盘，比如全局对象，比如共享内存。这些东西被多个线程共享，保证了灵活性与性能。但其本质只有是一份，无法分解，这反过来限制了灵活性与性能的持续提高，真是讽刺。一旦多个线程要对这些资源进行访问的时候，所能做的就只是
** 2015/06/16
*** 当程序发生异常的时候，直接退出并不是好的解决方法，这就是异常机制出现的意义。虽然从程序完整性上面来说，程序员应该考虑并处理所有的情况，避免未知情况的发生。但这实际上不现实，很多时候我们并不用考虑所有的错误情况，而是在错误出现的时候把事情重做一遍而已。比如请求一个资源的时候，我们完全不用管到底是因为内存不足还是因为CPU忙不过来还是什么乱七八糟的原因导致没请求到，而只需要重新请求直至成功就可以了，这时异常机制就能够比较简单的解决问题，而不是去考虑各种异常情况。这种机制虽然能比较简单的解决问题，但却也有一个比较大的弊端，效率问题，因为异常机制的本质就是就是层层上抛，o(n)的复杂度，这对于基本的功能来说效率还是太低了。
** 2015/06/17
*** 相机控制这东西的难点在哪里呢？主要在于高速采集，超大数据量，一张照片13M，一秒一不留神就是五六张，也就是一秒七八十兆的数据量，而且有时候不仅仅是存储，还需要进行一定的处理，这对机器，对IO的要求是很高的。
*** 异常机制有一个非常重要的好处就是一旦当一个功能模块出问题的时候，不会导致整个程序的崩溃。一般的大型程序都是由一个个功能模块组成的，要是仅仅因为你自己负责的模块的问题就导致整个程序的崩溃，是人都会非常的无语。
*** 其实异常机制对开发人员来说其实是好事，早点发现导致崩溃的情况，以解决问题。而对用户来说却会导致非常差的用户体验。所以，开发的前期忽略下异常处理不是什么大事，毕竟能帮助更快的解决问题。但后期快要交付时，就要把各种异常通通处理了，防止程序崩溃。
** 2015/06/18
*** 遇到问题时多与其他团队成员交流，有一个非常重要的好处――别让自己一个人承担太多压力。即使其他人不能够帮你解决问题，也能知道你碰到的问题到底是什么，有多棘手，这样当真正出问题的时候还能有人站出来帮你说说话，不然你就只能自己一个人默默地被黑锅了，或者即使做出了成绩别人也不知道。
*** 宋总其实是一个对很多事看的非常清楚，还挺会耍手段的一个领导。他总是能引领团队朝着积极的方向发展。
*** 其实多线程狂崩溃的原因只有一个――共享资源，一旦你在线程里面使用了在其他线程里面也需要访问的资源，就有可能因为其他线程改动了这个资源而导致崩溃。解决这个问题的方法有两种，一种是加锁，将这些资源保护起来，一个线程在使用的时候禁止另一个线程访问它，但这样可能会引发性能问题。其实对实时性要求不高的资源，还有一个非常好的方法是复制，将这个共享资源复制出来，这样就能各改各的，互不影响了。
*** 使用复制来解决多线程的资源冲突问题有一个要注意的点就是复制的过程必须是原子的，不能复制到一半就被其他的线程把要复制对象的值给改变了。
*** 多线程里面还有一个很无语的情况就是你可能刚将一个对象改动了值，然后立马这个值又被另一个线程里面的值给改动了，然后你本以为这个值还是对的，结果却是不对的了，然后你对这个对象的所有操作都通通失效了。
*** 全景显示这个问题的关键是将资源给复制出来，而不是加锁。通过将资源给复制出来，可以让对象即使被修改了，也可以正常的显示，不会影响新对象的更新。
** 2015/06/19
*** c#里面ref与out在编程人员看来的主要区别是out可以延后初始化，而ref不能。延后初始化可以使得代码编写的更漂亮，在客户端省掉new这样的拖油瓶。所有能够用out尽量用out，不要随便用ref，除非确实既要读入又要写出的时候才用ref。
*** 实际上，使用API来控制外部设备是如此深刻地影响着我们。无论是窗口绘制，相机控制等等，实际上就是一个函数的事，只要在大脑里面建立起来了这个东西的模型，那什么都好说。
*** 有一个非常有用的技巧，在MFC或C#窗口程序中，如果你想看界面上某个按钮对应的操作的话，直接点那个按钮，然后在它的属性面板上，切换到事件窗口，直接双击有事件函数的那一列，就可以跳转到对应的函数上面去了，这一技巧非常有用，特别是用在你摸清了代码整体的结构以后查看某个小功能函数的时候。
** 2015/06/25
*** TODO 大众的性格。
*** 万物的本质。碰到万事万物，多问问这个东西的本质是什么总是非常的有好处的。比如编程语言，软件架构，设计模式，编程原则等等。这样能让我们更加理性的使用这些东西，而不是闭着眼睛瞎用。
*** 做减法，实际上我们的大脑会自动的做减法，自动的清理掉我们很久不用的记忆。这种基于时间自动清除的方式对于无关紧要的杂乱记忆是非常好的，它能够保证大脑的长期可用，不会空间不足。但对于有些重要的记忆，这种方式就不大好了，这时候，我们需要从大脑中接管部分记忆清理工作，通过自己的总结来主动清理一些记忆，主动的给自己的大脑做减法，这样才能长期保证大脑记忆的稳定高效运行。
*** 重复读一本书比读两本书要好，因为重复读能更好地关注技巧、结构、设计等更加关键的东西。
*** 吵架往往是由于积怨引起的，并不关最后一根稻草多大的事。
** 2015/06/29
*** 定义是不是流氓，只需要看它做了什么，而不是拿其他人作参照――看他们耍了那么多次流氓，我耍流氓不能算流氓。
*** 编程工具永远不是程序本身，对编程工具的熟练掌握，永远也无法代替真正的对程序和计算的理解。过分强调这些工具的使用，是本末倒置的，让工程走上失败道路的作法。――王垠《所谓软件工程》
*** 关于c语言中的volatile关键字的作用实际上很好理解。我们现在普通使用的电脑使用的是三层存储体系，低速的外存硬盘，内存，还有处理器缓存。volatile关键字就是用来对某个变量关闭处理器缓存、只使用内存值的标识符，用来避免多线程情况下有时更新了变量内存值却没有刷新缓存值引起的值错误情况的发生。与写日志时关闭缓冲直接写入到磁盘是一样的。
