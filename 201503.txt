* 2015/03
** 2015/03/02
*** 如果企业的核心竞争力都要靠买的话，公司就不用做了，都洗洗睡吧。――雷军
** 2015/03/03
*** 血淋淋的教训――试验c++0x的新特性的时候绝对不要用vs，即使是最新版的vs2015也无法做到c++0x的完全支持，用错误的工具来试验未知的东西，这两种东西的不确定性会产生正交的错误，大大干扰试验结果的准确性。正确的做法是使用g++。
*** 返回值优化是一项非常有用的技术，有了返回值优化，想A a = fn()这种返回大对象的函数再也不会有临时对象的构造析构开销，终于可以避开使用在参数中用类型引用来返回大对象的方式了，以后这也不需要写“A a;void fn(int arg,A &a);”这种很丑的代码了。
** 2015/03/04
*** 严格来讲，右值引用只能窃取堆内存的资源，而栈内存的资源依然只能再创建一份。由于一般栈很小（默认1M），所以这种开销还是可以接受的。右值引用窃取堆资源的方式就是用新对象的栈指针指向右值的资源地址，这样就不再需要开辟与拷贝了，而就对象的析构也只需要移动下栈指针就可以了。
*** 严格意义上的栈只能通过栈顶指针访问数据，但c/c++语言的栈不是这种栈，而是一种既可以从栈顶访问，也可以从栈底访问的栈，有点像队列，不过队列只可以访问两端，而这种栈可以通过栈底指针访问任何地方的数据。
** 2015/03/05
*** 函数对象的出现，使得在函数内部定义函数变得可能。从此c++的函数内部不止能够定义类，还能够定义函数，从而大大扩充了语言的表达能力。
*** 语言核心的一个非常微小的改变对语言整体的表达能力具有质的改变。比如函数对象这种东西，不应该仅仅把它看做是一个将以前写在外面的短函数写在函数里面的玩具特性，它提供了一种隐藏外部没有必要接口的方法从而细化了函数类型，只暴露接口函数，不暴露只调用一次的工具函数，从而使得代码更加的清晰美观，容易阅读。还有右值应用这东西，跟函数对象也有点像，它细化了表达式的值类型，从而大大减少了临时对象的构造与析构；c++程序员从此可以随便返回大对象，递归函数效率也大大提高。
*** c++使用lambda将函数定义写在函数里面可以使得外部函数接口变得更清晰，但同时也会使得函数的代码变得很长，这样虽然接口变得清晰了，但函数定义却变得模糊了。这个问题应该这样看，其实函数的代码长度是无所谓的，关键是函数要写得清晰，不能瞎写，局部变量（函数内部的全局变量）要少用，该分块的地方要分块，应该把函数当做一个文件来看待，虽然代码也许很长，但通过合理的分类，一样可以使得定义非常清晰。
*** 对于函数代码的长度，很多人意识到了长度不能太长，否则会非常难以理解，却并没有意识到为什么会这样。其实在函数的定义区域写代码跟在全局范围内写代码是一个道理，在全局范围内写代码所要遵守的一些编码规则在函数里面其实也要遵守，像：
1、尽量少用全局变量，在函数里面就是尽量少定义变量。
2、尽量使用函数来实现变量功能，也就是纯函数式编程。
*** 实际上最优秀的代码估计就是用函数式编程写出的代码了，命令式的编程只有在极少数特定的情况下才需要使用。比如为了比较简单的实现某些特定的功能（这不多）。如果我们这个世界是可以被规则化的，比较纯粹的，那么完全可以用纯函数式的编程方法来进行编程，但真实的世界不是那么纯粹的，易于规律化的。所以最好的编程方式是大部分情况下使用函数式编程，偶尔用用命令式编程。
*** 上一条揭示了一条编程的本质――主要使用函数式编程。这一条再揭示一条编程的本质――实际上循环是不必要的，所有的循环都可以用递归来实现，而且用递归实现代码会更短更易理解。这其中有个关键问题是语言的解释器如何来实现递归，传统的使用堆栈来实现递归的时候，每次调用函数都需要保存与恢复大量的状态，造成函数调用非常的低效。这种实现方式写出来的递归代码显然不会很高效。但如果能够以一种更加高效的方式来实现函数调用，那么递归方式写代码有可能成为编写代码的主流。
** 2015/03/06
*** 编写代码时不要太注重性能。这样平白无故地多出了一个限制条件，使得整体的代码编写难度更加困难，因为人同一时间所能忍受的变数总是那么有限的几个，多了就会混乱。
*** 编程领域五大常用算法――分治法、动态规划法、贪心算法、回溯法、分支限界法。实际上这五种算法都是递归的，因为编程的本质就是在问题的基础上建立起来抽象，然后用抽象出来的工具继续抽象，这样层层利用已有工具解决新的问题的方法。这样就使得算法总是递归的，这是无法逃开的，复杂的算法无非就是递归变得更难了一点。
*** 代码的本质就是树形结构，优秀的代码总是一颗均匀的平衡二叉树结构，下一层级总是比上一个层级大但又不会大太多。这棵树的根是编译器，main函数与很多其他的全局函数位于。这种树形结构的代码可以保证不论代码多么的复杂，多么的多，依然能够保持代码具有非常优秀的可读性，可维护性，高效性。在编写代码的过程中，一旦你意识到自己的代码偏离了这种结构，就要注意调整自己的代码，使得代码重新恢复到这种结构。
** 2015/03/09
*** 工作就是应付客户的各种需求，以他们为中心。这样的情况下，工作是绝对不可能按照自己的兴趣来走的，所以要想工作与自己的兴趣刚好契合几乎不可能。要想发展自己的兴趣，只能通过自己研究，不要指望靠换工作来达到这一点。
*** 原本以为简简单单的编写普通代码不需要模板掌握的多好，现在看来这个想法有点可笑了，要想提高代码的抽象能力，模板是一个不能回避的问题。
*** 用c语言写程序需要比其他语言照顾到更多的东西（比如内存和资源管理，类型匹配等东西）,因而更加的难写，同时由于能够掌控更多的资源，如果能够驾驭的话将能够比用其他语言写出的程序更加的优秀和高效。
*** 关于函数的嵌套有内嵌跟外嵌两种，内嵌往往能够获得更高的效率，因为没必要把一些不需要的信息也给存起来返回，但内嵌缺乏灵活性，因为一旦需要额外的参数的时候还需要更改外部的接口，外嵌就不存在这样的问题，但外嵌需要消耗更多的空间与时间。所以两种方式要权衡使用。
*** 关于负数的最开始引入实际上是为了表示方向，正数表示正方向，对应的负数表示负方向。正负数的引入使得数字第一次有了一维的方向。而矢量的引入实际上就是这种方向的扩充，使得大小与方向绑定到一起来表示一些有各种方向的量，使得多维方向的表示成为了可能。
*** 数字的出现是为了计量，而各种算符的引入是为了对数字进行运算。每种算符都有其对应的实际意义。比如加减法表示累积。乘除法表示把每种乘法的引入实际上是为了表示重复。正是这些运算符与运算对象共同构成了今天的世界。
*** 减少重复代码的秘诀就是抽象，将重复的代码抽象出来，形成一个功能构件。具体实现时，只需再实现特异的功能构件，然后将各个构件组装，新的功能就做出来了。
*** 在编写代码的过程中不断的抽象出构件，通过构件的组装重新产生新的代码。这对于代码的编写来说是一个加速是的过程，抽象的越多，质量越高，对于代码的编写就越是有利，以后写出同样的代码效率就会越高。这种过程从本质上来说是加速式的。
*** 乖 摸摸头
** 2015/03/11
*** 在功能复杂的检查工具中，维持检查状态的正确性是一个很复杂的事情，在检查过程中的任一时刻出现的错误，在汇总时应该归结到哪里，总结果还是分结果，分结果如何汇总，这都是问题。如何正确地解决这一问题呢？
*** 慎防检查错误的蝴蝶效应，关键的部分一旦出现错误，接下来的一系列依赖于此项检查的检查通通都会出现问题，这就是vs有些时候报几十个错误，但只要改正了一个部分，所有的错误都会消失的原因。
*** c++默认的赋值运算符只会复制对象的栈内存部分，并不会复制堆内存部分，所以，如果你自己的类有一部分在堆上（new出来的），那么一定要自己写构造函数，特别是引用构造函数与赋值操作符。
** 2015/03/12
*** scheme里面，delay可以延迟计算，这是一个非常重要的特性，这意味着你可以打破求值规则，延后求值，这将有可能引发一场求值的革命，就是俗称的lazy evaluation。
** 2015/03/13
*** 在lisp语言中，有map函数实现集合到集合之间的变换，但在c++语言中，map函数已经被map容器的名字所占据了，所以，虽然c++中也有实现一样操作的函数，但名字已经不是map了，在c++中，这个函数的名字叫做transform。
*** TODO 一种常用的代码抽象方法就是将几个类似函数中不同的部分抽象成函数参数，这样两个函数就可以共用共用代码，而只需实现自己特异的代码部分就可以编写出这两个函数了。当然这并不是唯一的代码抽象方法，另一种方法就是通过全局变量（类变量也是局部的全局变量，也属于这一种）。还有一种方法是通过返回值，将函数的公共代码部分抽象成为返回值（lambda),这也是一种非常强大的代码抽象方法。
*** 如何提高自己代码的通用性？这是一个中级程序员所必须考虑的问题，实际上这个问题可以表述为――如何抽象自己的代码，使之具有更高的通用性？
** 2015/03/16
*** 对自己好一点，如果你连自己都对自己不好的话，你好指望会有别人来替你爱惜自己吗？
*** 循环的本质是什么？就是一遍遍地重复做某件事。而迭代的本质其实也是一遍遍重复的做某件事。这也就是可以用迭代来代替循环的原因。
** 2015/03/17
*** 关于精神修为的境界问题――最开始是从无到有，开天辟地，形成一个精神的世界。但这个世界的轮廓还是模糊的，很多东西都不是那么真切；继续修炼，这个世界的轮廓将越来越清晰，渐渐地，这个世界就由无形变为有形了；这个轮廓虽然会帮助你处理很多问题，但渐渐的这个轮廓也可能会成为限制，阻碍了你向更高的境界发展，此时，要破除这个轮廓，重新回归到空无的状态，也就是零极限的状态，然后寻求新的突破，一切重新开始。这种状态是最高境界，修炼到了这种境界，修为就已经达到了顶点，想要继续提升已经变得不再可能。此时就需要重新修行其他方面的东西，继续达到顶点了。如今，我的精神修为处在第二个阶段，从最开始的混沌状态已经渐渐的有了轮廓，我要对自己好一点，要破除外在的限制听从内心的呼唤。这种感觉非常美妙，我将持续践行下去。
*** 受到舆论、潮流、习俗、习惯等东西影响，我们每个人的精神世界都有不少的污垢需要被清理，精神修为的过程就是不断的清理这些东西，然后用爱来重新填补这些空缺，逐渐强大，不断进步的过程。
*** lambda实际上是一个代码封装，它可以用来延迟计算。它表示这样一个意思，现在先不计算这几行代码，等到需要的时候再来计算。
** 2015/03/18
*** 错误检查的错误状态实际上是一个树形结构，要处理错误的细分与汇总问题。
*** 人的思维可以做的事，电脑多半也可以做；人的思维都做不了的事，电脑也做不到。电脑的智能智能无限接近于人，但不能达到。
*** 写代码时，代码的层次结构一定要清晰，代码本质上就是树形结构。实现这一点具体的方法就是构造抽象屏障，编写函数时每次只在一个层面上编写代码，这样写出来的代码就会逻辑清晰，便于阅读与维护。
*** 大众所普遍认可的东西不一定是正确的，它虽然大体上来说错误不多，但这些错误却往往是无法修正的，或者说是极难修正的。同样的，你自己的看法也不一定是正确的，而且错误一般会比大众认可的东西错误更多，但相信你自己却有一个相信大众永远望尘莫及的地方，就是可塑性。一旦你发现大众是认可的东西是错误的，改正这个错误是非常困难的。但一旦你发现自己的某个观点是错误的，改正这个错误却可能是极其简单的，也就是说相比于大众的意识，自己的意识是一个可塑性，可改进性非常强的意识。既然如此，我们为什么不让相信自己呢？
** 2015/03/19
*** 能够用语言提供的基本api实现的，就用语言的api，不行再考虑操作系统的api，操作系统的api由于做了额外的事，比如生成了句柄表，扫描了额外的信息，一般都比语言api提供的药慢，不如获取文件大小，用fseek就比windows的filelength快一倍。
*** 不管使用什么语言写代码，关键部分（也就是可能需要被执行很多次的部分）必须深思熟虑，不然一个非常小的差异就可能给最终的程序代码巨大的效率差异。
*** 继承的本质就是抽象构造，但继承并不是抽象构造的唯一方法，还有一种很常见的抽象构造的方法是组合。组合具有更低的耦合性，更好的挑选余地，不想继承那样必须全盘接受。但继承的优势就在于它可以瞬间全盘接受，如果基类很优秀的话确实是一种很灵活高效的构造方式。还有一个继承的优势就是作为一种将接口函数与实现还是分割开的方式，使得代码的组织方式更加的简单清晰的一种手段，这个好处的特点是没有副作用，可以随意使用，所以现在很多语言虽然不再保留继承了，但接口这一特殊的继承作为这一好处的特殊变体却一直被留存了起来。但现在这一方式也受到了挑战，就是所谓的鸭子类型。
*** 无类型语言没有类型的限制，有些时候确实是比较的方便。但同样的，由于没有类型，它也没法享受强制类型所带来的好处。像lisp这种语言，由于没有类型，很多时候你根本不知道一个函数需要给它传递哪种类型的数据，虽然这种缺陷可以通过合理的定义参数的名称来规避，但没有强制的命名约束，完全遵守就会变得非常的困难，特别是需要多人合作的时候，基本不可能。这也就造成了动态语言合作的困难，同时，这也可以解释为什么java表达能力如此低劣的语言能够得以流行了。因为java强制限定了必须以类这种简单粗暴的方式来作为抽象的媒介，而且可能是唯一的媒介。使得虽然很多时候为了实现一个非常简单的功能也变得非常复杂，但却强制统一了标准使得合作变得更加的容易。这其中，静态类型作为强有力的限制手段，还是起了相当大的作用的。
*** lisp语言有个比较大的不足之处就是无类型，无法使用和享受类型系统所带来的好处。
*** 类的一个很大的作用就是可以拆分函数，将一个函数的不同部分拆分在类的不同函数之中，根据需要选择不同的代码来执行。
*** 其实类可以作为分解函数的一种方法，是函数之下更小的构件，将函数的各个部分拆分到不同的类函数，然后根据自己的需要选择需要的代码，从而对函数继续进行细分，这才是类的精髓。真正优秀的类总是非常小的，一个类如果代码非常多那这个类就是失败的。
*** 使用类来分解函数的方法就是函数中的成员变量作为类成员，特别是需要多次使用的变量，函数中常用的代码作为类成员函数（分为多个），需要提供给别人的接口就声明为公有函数，自己使用的工具函数就作为私有函数。这样分解之后给了使用者一次灵活选择代码部分来完成自己功能的灵活性。
*** 类型系统确实是一种强有力的抽象工具，它使得对函数代码进行diy成为了可能，从这一点上来说，它并不是对函数的一种组合，而是一种函数拆分的工具。
*** 设计的出发点应该是使用者，而不是已有的设计。如果总是从已有的设计出发，就会沦为抄袭。现在国内的很多行业普通是这一情况，要相信使用者的感觉而不是所谓的标准。
*** 流的实现有很多种方式，对象加next求值器只是实现流的一种方式，而且并不是唯一的方式。还有一种方式是使用类来保存当前状态，然后再需要的时候对对象调用同一个函数来求得下一对象，这种方式不需要一开始就算出并存储所有的对象，只需要算出所需要的对象，确实是一种非常有效的实现流的方法。
** 2015/03/21
*** 如何阅读技术书籍？技术书籍不同于文学书籍，好的技术书籍必定是条理清晰的。所以，技术书籍总是可以只通过查看标题与每段标题紧跟着的前几段就可以大致了解整个章节说要说明的是什么。这也就为技术书籍的快速阅读提供了很好的条件支持。只需要阅读每个章节的标题与前几段，接下来的部分都可以跳着读了。这样看技术书籍的速度就大幅提高了。而且在刚开始阅读的阶段，这是必要的。因为如果没有一个对所阅读的东西的一个整体清晰的脉络，仔细阅读每一段也会遇到非常大的麻烦，难以理解不说，最关键的是阅读完之后往往什么也记不住，跟没读差不了多少。而且往往技术书籍前面几个章节是基础，最重要的部分，越往后越精深，同时用到的地方也越少，所以，后面的部分不去精读也无所谓，等到彻底把前面的部分搞懂了或者是碰到跟后面相关的具体问题了再去精读也是没问题的。所以，总结一下，技术书籍的阅读方法是这样的，先粗读，只看每章节的标题和前几段，其它段落先跳着看，也不是不看，看看总结性的话语，懂了就过，不懂再稍微看细化点的解释，力争在最短时间（一般是几小时或一天）的时间内把整本书先过一遍。然后回过头了再细读，这样大概重复个几遍，整本书就完全在脑子里了。
** 2015/03/23
*** 过程抽象与对象抽象是两种不同的抽象复杂性的方法。前者是将复杂的事情抽象成一个个步骤，然后一步步的去完成，很多时候，采用这种抽象方法要使用流技术来防止多余运算。而后者是通过改变对象的状态来完成运算，它的优势在于使得过程可以定制，这一点上现在对我来说是一想比使用过程抽象更牛逼的技术。
*** 关于矩阵实际上只需要理解一些比较简单的概念。
1、我们平时所做的绝大多数数据处理实际上就是矩阵运算。
2、矩阵运算不止可以用在数字的处理上，还可以用来做各种各样的处理。
3、不要以为矩阵所定义的那几个运算就是矩阵运算，其实绝大多数时候我们是使用自己定义的运算规则在处理矩阵。
** 2015/03/24
*** windows的api接口本来很丑，还有windows的api是为了通用性而放弃了简洁性，变得更丑。另外windows的api虽然丑，但确实通用性很强，可以用这些api经过很简单的封装就产生各种实用的函数。基于这些原因，需要对windows的api做一层自己的封装，使之更加的间接清晰好用。
*** scheme相较于lisp语言是一个巨大的改进，具体表现在以下几点：
1、第一个使用静态作用域（lexical scoping)，以去除传统lisp语言使用动态作用域（dynamic scoping)导致的逻辑错误的缺陷。
2、第一个可以编译成为机器码，在不同的操作系统上直接运行的语言。
3、第一次使用了尾递归优化，使得循环可以达到无限层。
*** 代码的设计应该尽可能地精简，言多必失，做的太多只会导致副作用，引起很多语言后期很难修补的错误，多余的东西一点都不能要。
** 2015/03/25
*** 惰性求值（lazy evaluation)是编程中的一种求值策略，一个对象，只有在真正被使用的时候才被求出来值，而之前可能只需要保存求出这个对象值的方法，这样就可以减少很多不必要的计算，减少程序的空间和时间占用。惰性求值的缺陷就是需要建立和管理中介数据结构，这会使得程序变得难以理解。与惰性求值相反的是及早求值（eager evaluation)。
*** 一种语言的解释器或者编译器确实是可以直接用这种语言写成的，这在编程语言里面叫做自举。最常见的例子就是c/c++语言的解释器gcc，还有python的pypy版本，还有现今版本的scheme估计绝大多数都是直接用scheme写成的。
*** 不同操作系统有着不同的文件系统格式，这些格式有可能千差万别，但终归只是一种文件索引树结构，这些结构是可以互相映射的，也就是在一个文件系统操作另一个文件系统的数据。实现这一种服务的基础就是服务，通过服务的接口来完成相互访问。windows与linux的文件共享服务名字叫samba。
** 2015/03/27
*** 要是没有并发的巨大优势，函数式编程确实很难和面向对象编程相匹敌。确实在很多情况下，面向对象比面向函数解决其问题来要方便许多。
** 2015/03/30
*** 人为什么要活在这个世界上，其实是为了物质和精神的无限满足。物质欲望很容易满足，但精神欲望是永远得不到满足的。一旦你达到了这个目标，你就会追求更高的目标，所以说是无限满足。同时，物质欲望的满足又会激发起精神欲望的觉醒。物质是即使你不去主动消耗，它也会随着时间自己耗费，你不满足就会死，所以它会推着你去干活。精神欲望其实也差不多，你只要生活一成不变，就必然会消耗掉我们称之为激情的东西，你不找寻新的东西也会死（无聊死），所以它推着你去探索。物质欲望与精神欲望是一个负反馈的关系，物质欲望的满足会导致精神欲望的空虚，精神欲望的满足又会重新导致物质匮乏，所以人需要不断的劳动，不断的在这个循环中生存下去。正是这种负反馈维持着人持续不断的去追求，永远不会有终点。多么精妙的设计。
*** 反馈在设计工作中起着巨大的作用，正是反馈推动着我们持续不断的改进产品设计，精益求精。比如lisp的eval与apply循环。在设计的过程中如果能够熟练的运用这种循环，将能够设计出永远不会有终点的系统，使得可拓展性无限提高。反馈其实就是一个环，不管正反馈还是负反馈，熟练使用这个环是设计与控制的必修课。
** 2015/03/31
*** 只需要定义基本的数据结构以及其他的功能接口函数，就可以直接推导出这些接口函数的实现。一个非常有意思的现象是――这个基本的数据结构可以被以各种方式来定义，每种定义不同会造成其他接口函数实现的千差万别，而保持这些接口依然对外提供相同的服务，区别只在于效率。
*** 只要定义了基本的实现，其他部分都可以由这个基本的实现给推导出来。设计一门语言的关键就是要精心设计这些基本的实现，然后再由这些基本的东西排列组合出各种高端的特性。
*** lambda演算基本三要素――变量，函数以及函数调用，通过这三个东西的循环使用可以模拟任何复杂的计算，包括硬件的计算。它和实际的机器有着简单的一一对应关系，变量就是导线，函数就是电路板，函数调用就是将导线插入电路板，电路板的输出又同样是导线，可以继续用来进行函数调用。
*** 一个东西的输出本身就是输入，这才是任何递归得以进行的基础。递归一定要记住考虑到所有可能的输入，不然就很有可能会出问题。
*** 带着问题去读书，查资料，这样才能快起来，也符合我的快读书法的精要。怎样寻找问题呢？很简单，跑到问题先自己思考下大致的实现，然后有哪些需要注意的就了然于心了，然后在查跟自己想的进行比对，这样读书查资料会快很多。
