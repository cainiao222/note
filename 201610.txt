* 2016/10
** 2016/10/08
*** 代码的层次结构非常重要，如果层次控制得好，代码的可读性就会非常的好。如何写出层次结构非常良好的代码呢？分文件是很常用的方法，不过随便一个功能都分好几个文件也是不明智的。正确的做法应该是复杂的功能分文件，简单的功能还是写在一个文件，不过分部分，高层代码写一部分，低层代码写个部分。
*** DONE 使用回调来表现层次结构，外层的代码写在外层，内层的代码写在内层，这是每个前端开发者都应该掌握的编码技巧。
*** 函数的定义与调用都应该放在适当的层次，不能跨越层次太多，这样别人看起来才能一目了然，从外层到内层，每一层都会定义与调用一堆函数，当跳出这一层的时候这些函数就会被自动释放掉，这样写出来的代码才能拥有最好的可读性。不过有一点需要注意的是如果一个函数经常被调用，频繁的定义这个函数就不是很明智，这种时候就应该把定义稍微往外层移动点，不过也不能移太多，太多了易读性就是去了。
*** 写代码不止要达到可读的程度，还要达到易读，可读是说能够读懂，易读是说容易读懂，二者高下立判，仅仅岛导可读是不够的，还要争取达到易读。
*** 什么样的函数接口才是非常优秀的函数接口呢？可以参照高德地图开放平台 API，通过函数把所有的东西都封装起来了，只需非常简单的函数调用就可以重现功能。什么是失败的 API 呢？可以参考腾讯地图开放平台 API，代码逻辑混乱，全局变量满天飞，胡乱使用对象，一堆莫名其妙的对象成员，还需要用户去猜测，非常失败。
*** 高德地图的API结构确实非常的好，使用AMap来管理整套API，然后在这套API中，有Map用来管理地图，有TileLayer用来管理图层，有service用来管理服务（主要是地名搜索、路线规划、公交查询），有Marker用来管理标注，有InfoWindow用来管理窗口，使用Plugin（包括地名补全，侧边栏，工具栏等带UI的东西）来管理插件，有Event来管理事件。
*** 再来对比下百度地图的API，百度地图的API实际上并没有划分出service、plugin这些东西，直接把功能挂在BMap这个对象上，这就直接导致这个对象过大，性能方面可能会受影响，拓展性也不会好，不过百度地图的帮助文档丰富程度是强于高德的，学起来比较容易上手。
*** 最后看看腾讯地图的API，腾讯地图的API相比于其他两家的API，质量就差更多了。高德地图有高层、中层的抽象以及底层的实现，百度地图有中层的抽象以及底层实现，而腾讯则只剩底层实现了。它的API接口暴露了很多底层实现的细节，需要用户自己去绘制，考虑很多东西，这就非常差劲了。
** 2016/10/09
*** 抽象的最大意义也许就在于提供给上层统一的接口，用户只需关注于功能使用，而无需关注功能实现。我们只要修改实现细节，所有使用这一接口的地方都会被修改，实现一改全改。
*** 实际上，js 的 new 就是一个工厂模式的实现（对象的字面量写法实际上也是 new）。工厂模式使得我们能够使用一个函数来创建对象，忽略对象的构造细节，我们只要修改了细节，所有依赖于这种方式构造出来的对象都会被修改。
*** 实际上工厂模式只不过是函数的一个非常初级的用法。函数是一门编程语言最强大的东西，没有之一。通过函数以及函数的组合，可以实现非常强大的抽象。函数可以用一句话代表一堆话，可以把这堆话作为函数参数传来传去，想什么时候调用就什么时候调用;函数还有自己的作用域，实现内部元素的控制，当退出作用域的时候将这些元素给释放掉;函数还可以捕获它外部的变量，使得我们即使出了变量的作用域，依然可以通过它透出的函数来间接使用这些变量，实现状态抽象。
*** 全景图还是有它自己独特的意义的，它对于现场还原具有很好的效果，远远强于只有一种图片的情况，对于作业也大有好处，唯一的问题就是数据量。
*** 函数与语句最大的差别也许就在于函数是有作用域的而语句没有，也就是俗称的上下文有关文法与上下文无关文法。
*** YUI 虽然走入了历史，不过 YUI 依然有些非常强悍的新功能需要被继承，比较值得一提的就是其事件框架以及组件框架，这两个现在是还找不到替代品的，其他的像测试框架有 Mocha，CSS 框架有 bootstrap，APP 框架有 backbone。
*** es6 的模板字符串的花括号中是可以表达式（变量，函数调用都是表达式），但不能是语句，因为语句没有返回值。如果真的要使用语句的话，可以使用函数（箭头函数更好）封装语句，然后加上返回值，这样你就可以随便使用语句了。这样看来，实际上 js 的模板字符串并没有做任何的限制，我们完全可以使用语言中的任何特性写进模板字符串实现字符串拼接，唯一的不足是无法统一管理输入参数，不过这也不是什么大问题。
*** DONE 实际上没有语句只有表达式的语言是无比强大的，因为它可以允许我们随心所欲的进行组合，不用考虑返回值的问题，语言的可组合性非常的强。任何语言都应该这样设计。比如 lisp 语言。
*** 为什么匿名函数（js 中的箭头函数）这个东西会作为一个非常现代化的特性走进各种语言呢？因为很多时候我们只是需要一个函数，这个函数只使用一次就不再使用，我们并不需要把这个函数单独提出来影响代码的结构，我们也不需要费心思去考虑给这个函数取一个怎样的名字，我们甚至不需要为这个函数写上多余的大括号，这种时候，匿名函数就成为了最佳选择。这实际上是函数的使用频率越来越高了的一个表现。也就是说，什么时候使用模板字符串呢？即用即仍的函数、小函数。如果函数需要多次使用，那么还是使用个具名函数更好点。当然，由于 js 中的匿名函数与普通函数还有 this 的区别，这门语言的匿名函数应该被更加广泛的使用。
** 2016/10/10
*** TODO autoload 设计启示：使用一个函数封装一堆函数，将这一堆函数延迟加载。原本需要加载一堆函数，现在只需要加载一个函数，速度自然更快。充分利用函数延迟加载的特性，大大减少了函数数量，从而实现加载速度的提升。想法非常好，但是也有需要注意的地方，关键的问题是具体到什么时候加载，加载以后什么时候释放？
*** load 与 eval，函数定义就是 load,而函数执行就是 eval，将函数调用变成函数定义能够延迟调用的时间，实现延迟加载，为程序减负。
*** spacemacs 设计原则，如何解决 vi 与 emacs 的按键冲突问题？使用外围与内围两个状态用 vi 做外围，emacs 编辑做内围。
*** vi 有三种插入命令：insert,append,open。每种插入又分大写还是小写。所以综合起来一共有六种插入命令。这六种插入实际上比较乱，根据单词的意识来记忆比较好。
** 2016/10/11
*** 事实上，把所有函数都写在一个（比如全局作用域）是个非常不好的做法，这样当函数很多的时候加载起来就会非常耗时，同时对拓展性也是很大的伤害。
*** 培养编程的感觉。
*** 使用的require.js，但是却使用的CMD的写法。
*** 不管是amd还是cmd，它们都蕴含着同样的思想————使用函数来包裹模块，把模块的所有代码写在一个函数里面，模块可以嵌模块，形成树形结构。每个模块里面暴露尽可能少的外部接口，每个模块应该是自完全的，自己渲染，自己添加事件监听，自己实现监听函数。
*** 实际上每一个前端功能都包含三个部分————界面绘制，事件监听，事件处理。这三个部分分别叫做V,C,M,各种框架所做的事情实际上也只不过是在给这三个部分分类，防止文件过于复杂。当你学习框架时，可以从这三个方面去考虑，考虑当这个框架引入时，如何处理这三个部分的代码。
*** 延迟加载也许是当下实现web编辑器性能飞升的关键。
*** 实际上按需加载css也许是很诱人的个东西，根据别人选择的不同方案动态改变样式，想想都十分诱人。
*** 只有函数才具有可维护性，css由于没有函数，所以可维护性非常差，当然借助于less的函数能够解决部分问题，但是由于css各个属性太乱还是不能根本解决。
*** webpack的出现是历史的必然，本来js足够强大，我们能够使用js来加载任意类型的文件，那么当加载其他类型的文件的时候，先用个程序转化下转化成js不就可以实现加载任意格式的文件了吗，这就是webpack的设计思想。
** 2016/10/12
*** 实际上，hook也是一种代码解耦的方式，类似于事件。它可以使我们在不修改已有代码的情况下实现功能的拓展。
*** 实际上，requirejs与webpack是差不多的东西，webpack所宣传的打包任意类型的文件使用requirejs也可以做到，requirejs也可以依赖css，less,图片这些东西，也可以将这些东西打包成一个文件，而且难度也并不会就比webpack要难。所以说，前端的很多工具实际上是重叠的。
*** nodejs的出现确实是前段领域划时代的东西，自从它出现后，js终于可以脱离浏览器运行了，终于可以操纵操作系统的各种资源了，由此出现了大量的js工具集，js终于迎来了春天。
*** gulp是一个工具集，它不同于webpack。webpack只是一个工具，而gulp是一个工具平台，它提供了很多我们写工具的时候需要用到的各种API，它是比webpack高层的东西。
*** webpack之所以会流行，很大程度上是由于它抓住了前端问题的核心————打包。它与gulp的目的是不一样的，gulp倾向于给人开发前端工具，而webpack是用来给人做前端开发的，高下立判。
*** 将所有的UI相关的代码写在一起，将添加事件监听的代码写在一起，将事件处理写在一起，通过这种简单的分类，代码逻辑就可以非常清晰了。
*** 如何提升代码的可读性？MVC只是一种比较粗略的代码分类方法，要想继续提升可读性，还得继续细分。首先需要划分的就是M端，M端由事件派发的函数作为开始，需要实现自己的业务逻辑，这些业务逻辑必然有很多共用的部分，这就是分割点。首先需要把这些共用的业务逻辑抽象出来，放在另一个位置，可以是另外的函数，也可以是另外的文件。
*** 实际上，在MVC三个部分代码中，VC端很多时候是非常简单的，而M端才是重头戏，所以，要继续细分，首先得从对M端的划分开始。
*** 实际上对于一个功能模块的MVC来说，它的终点M端实际上很有可能还连着其他功能模块的起点M端的。也就是说，实际上，MVC是嵌套的，一个M有可能跳转到其他功能模块的V。
*** TODO 也许编写一个工具用来抽模块是个不错的做法，因为一个文件很多时候会依赖其他模块，如果都是用require引入的话，我们完全可以解析下require的参数，将所有被require的文件给抽出来。
*** webpack是更好的requirejs，它使得前端开发尽可能的与node开发保持一致，比如它可以依赖文件夹。也不用考虑异步加载的问题，因为文件都被打包到了一个文件。
*** browserify的思想实际上比webpack更加的先进，它是微内核的，灵活性与拓展性都会比较好，而webpack隐藏了所有实现细节，想重新组合就比较困难了。一般新手可能会更喜欢webpack，而用的多了想获得更好的拓展性就需要使用browserify了。
*** TODO 不管是webpack还是browserify，它们都只会打包被依赖的文件，如果一个文件没有被依赖，这个文件是不会被打包进最终文件的。值得注意的是，如果只是想提取文件而不打包，这两个包好像都还做不到。
*** 最好使用一个文件夹来表示一个功能模块，而不是使用一个文件，每个文件夹有相似的结构，这样代码就能写的比较清晰。
*** 要理解iD对代码划分的方式————mode（顶栏操作菜单）,operation（右键菜单）实际上都是V，behavior是C，而action是M。
*** 在本地可以开启一个服务实现自动打包，在服务器上可就未必可以了。因为服务器对稳定性的要求比本地要高，一旦代码打包，这个打包无法即时被推送给所有用户，就会造成莫名其妙的错误。
*** js的箭头函数是个非常好的东西，尤其是在事件处理函数中。
