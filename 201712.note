* 2017/12
** 2017/12/07
*** TIPS git推送分支到远程git push origin branch.
*** 在npm5版本以后，使用npm install自动安装工程依赖是有优先顺序的，首先使用package-shirink.json，如果不存在则使用package-lock.json，如果还不存在才是使用package.json。当然，如果你修改了node_modules文件夹的内容再使用npm install，这时是使用的package.json。
*** TODO 对象的相加（Object.assign）、相减。
** 2017/12/09
*** 组合优于继承，继承优于mixin。
** 2017/12/11
*** 在vue中，v-if与v-show最大的差别在于触发的钩子不同，v-if销毁创建元素，由此会触发一堆的钩子，比如created/mounted等，而v-show则没有这个问题。要根据实际情况灵活使用。
** 2017/12/14
*** TIPS 有个小技巧，如果想要一个长方形div边缘呈圆形，将border-radius设置为很大就可以了，css自然会让边缘呈圆形，无论内部元素的宽高是多少。
*** transform是一个渲染效果，发生于布局之后，也就是说它会在布局好之后移动下元素到其他位置。而布局决定换行，有可能元素换行了然后移动元素，所以元素依然是换行了的，知道了这一点后碰到这种情况，将换行给关掉然后在transform就好了（white-space:nowrap）。
*** TODO pingback总结：
	必填字段：
	type:日志类型
	hwver:硬件型号
	ua：浏览器信息
	iswechat：是否微信（浏览器标识，微信1，支付宝2，其他0）
	re：分辨率
	u:设备id
	rn：随机数
	pu：passport ID
	hu：会员状态标识
	tvver:TV端版本号
	tvmacid:TV端设备id
	tvuuid:TV端uuid
	tvp2:TV端二级产品
	tvhwver:TV端硬件型号
	s1:页面来源（调用方发起，通过url传递）	
** 2017/12/21
*** vue的slot实际上就是给了用户一个机会自己来实现组件内部的东西，开发者只是先外部的框架，至于内部的实现丢给用户，用户想怎么来怎么来，实现自己的东西。
*** TIPS 关于inline-block的文字与图片不对齐的问题是这样的，默认情况下，inline-block的元素是已基线为基准对齐的，文字的基线在文字中间偏下的地方，图片的基线在图片底部，所以，如果想将它们居中对齐的话，只需要在文字与图片上分别加上“vertical-align：center”，这样它们就居中对齐了。需要注意的是，在移动端，即使设置了这个属性也有可能出现有几个像素偏移的情况，这时需要将文字与图片的高度设置为5的倍数，注意。
** 2017/12/22
*** 编程中的接口数据实际上可以分为接口数据与UI数据，将这两种数据放在一起是不合适的，比较好的方法是将这两种数据分开，而且不是通过字段分开，应该将UI数据与接口数据分在不同的文件中，将接口数据放在上层，UI数据从接口数据中取出部分传入到UI组件中。这样整体的数据流会比较清晰，维护起来也比较方便。
*** TIPS 擅用less的父级引用，它会让你的css结构非常清晰易懂。有父级引用与没有父级引用的区别就在于有父级引用是作用于同一个元素，没有是作用于子元素，搞清了这一点什么时候加父级引用，什么时候不加就有个谱了。
*** IMPORTANT 无论是js还是css、html，它们都是代码，优秀的代码总是树形结构、一层一层的，每个层级最多不超过8个元素，一层层细分，这样无论是编写还是维护起来都会非常轻松。数据结构亦然。
*** TIPS 关于vue的模板上什么时候用冒号是这样的，如果值是data中的数据或不是data中的数据但不是字符串，这时应该用冒号，否则不用。
** 2017/12/25
*** 在css中，默认情况下，内层元素是可以超出外层元素的，只需要将内层元素的宽高设置的大于外层元素即可。如果你不想要这一点，可以将外层元素的overflow设为hidden，这样内层元素超出外层的时候就会隐藏起来了。
*** 前端页面开发流程：
	+ UI还原
	+ 接口数据对接
	+ 交互实现
*** TODO 路由与控制中心？
** 2017/12/26
*** TIPS 关于mixin的选项覆盖要分两种情况来讨论。一是钩子函数（比如created/mounted等这些），钩子函数不会都会被调用，不会被覆盖，调用顺序是先内部的，再外部的；还有一种是method，同名的method外部会覆盖内部的，这样就会出现外部的被调用了，内部的没有被调用的情况，要格外注意。
*** TODO 两个async/await函数想要并行非常简单，有两种方法，一种是直接Promise.all，但这仅适合于可以统一处理错误的情形。如果想分开处理错误，直接分别调用两个函数，不要await就行了。
*** TODO 使用watch监听props变化？
** 2017/12/27
*** TIPS float:right的好伴侣――――transform: translateY(-100%),加上了这个之后，本来在元素右下的元素就到元素右边去了，还有一种方法，使用margin-top: -xxpx，也可以使元素上移。
*** TIPS margin: auto与text-align： center，前者用于外部居中，也就是元素居中，后者用于内部居中，也就是内容居中，要注意区分。
** 2017/12/28
*** TODO 使用promise完全替代掉callback？
*** TODO async函数返回true/false代替掉成功/失败是完全可行的。
*** IMPORTANT 关于vue组件中css的样式覆盖，有三种方法。
	1. 外层的class会被带入到里层并被加入到class最后，而后面的class会覆盖前面的。我们可以利用这一点直接修改里层容器组件的样式。
	2. 利用css的样式继承，比如color/font-size这些，我们设置了容器组件的样式如果组件内子元素没有设置这些样式的话就等于直接修改了容器元素内部元素的样式。
	3. 利用我们自己加的类然后再引子元素设置样式，我们设置可以随意修改组件内元素的样式。
	   这样，虽然vue通过scope限制了内部css的影响范围，但是我们依然可以在外部随意修改内部元素的样式。总结下， *vue的scope只是限制了样式流出，但并没有阻止样式流入* ，我们可以使用各种技巧（不是hack）用新样式替代掉组件中的样式，实现样式派生。
*** IMPORTANT 使用外部代码（包括函数库、框架、接口等等），在这些接口的基础上进行二次封装多数时候是非常有用的，因为通过这一手段你减少了外部代码的入口，从而获得了对它们的更强的控制力。通过这个中间层，多数时候我们能大大减低对接的难度，同时改变代码风格到适合自己的状态。
*** TODO 前端页面，不管是什么页面，它的展示必然是一个树形结构，最前面需要经过一些统一的阻塞阶段，然后会分为很多分支，某些时候某些分支会合流，然后继续往后，这棵树最后的叶子是各种交互，交互然后重新回流到某个节点，重新操作某些节点，循环往复。
** 2017/12/29
*** 重复的代码需要拆分，重复的数据同样需要拆分。
*** 里层组件只负责带出信息，至于信息处理，统统交给外层组件，也就是获取数据的地方来处理。
*** 把一整个页面也当成一个函数来处理，保持清晰的接口与返回。
