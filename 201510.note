* 2015/10
** 2015/10/02
*** 冯诺依曼结构是一种非常简单的计算结构，这种结构定义了要完成计算所需要的最少设备。但也正是因为太过简单，这种结构的最大缺陷在于并发，它的各种设备只有一套，CPU只有一个，总线只有一个，内存只有一个，所有的计算都是在这个设备上，只能通过切换时间片的方法实现伪并发，无法真正同时执行，各不影响，计算能力也有限。
*** 其实现实世界是真并发的，很多事情都在基本基本不受其他事情影响的情况下独立进行，到处都是CPU，他们各干各的，互补影响，只有在必要时才通过电磁波进行通信，通信的手段是一问一答。
*** 地铁口、火车站口经常看见漏斗结构，这种结构实际上并不能增加通行能力，只是在无形中建立起了一种公平的通行机制，使得通行的秩序得以维持而已。推广到计算机，实际上现在普通的冯诺依曼计算机是不需要这种结构的，因为它并不存在太过拥挤就会出秩序问题的事，只有容器空间足够就行了。
*** 人的系统是一个非常复杂的系统，里面有好多个子系统，这些子系统互相分工合作，完成各项功能，理解这个系统非常有利于理解计算机系统。
** 2015/10/05
*** 所有属性都已经隐藏于AttrbuteList里面了，我只是提取出了一部分属性放在外面便于操作而已，所以每次InsertAttr的时候都应该判断下是否为这几个字段的属性以便及时更新这些属性的值。这其实是一种后台自动更新属性值的技巧，不应该让用户去手动设置这些属性的值。
*** 谈恋爱的有趣之处并不在于对方事事都顺着你，而在于对方有时候会做一些在你意料之外却又在清理之中的事情让你觉得暖心。
** 2015/10/07
*** map不过是在插入数据的时候对数据进行了一下组织，使得我们可以快速的查找到数据。实际上就是把部分查找的工作移动到了插入的时候。
*** 通过对业务流程的重组，调整部分工作的进行时间，可以大幅度的优化性能。
*** c++的map使用的是二叉树，遍历使用的是先序遍历。
*** TODO 以后抽时间重新抄写自己的笔记，边抄写边整理，不断的重复，只有这样才能持续提升自己的笔记质量，不至于泛滥成灾。
*** 只将笔记作为辅助思考的手段而不回过头去看自己以前所做的笔记的方法只发挥了笔记的一丁点作用，其实笔记应该是要不断回头，不断修改以提升笔记质量的，只有这样才能将笔记的作用发挥到最大。但直接通过简单的修改无法调动修改的积极性，比较好的方式是重抄。
*** 不止函数可以递归，类也是可以递归的，可以在类里面使用这个类。
*** TODO 类型系统？
*** what is 计算？这才是我们在编程中需要搞清楚的本质问题。如何搞清楚这个问题？你需要破除一切别人已经写好的做好的东西，API、框架、架构等等，这些通通不能要。你需要从底层开始，重塑计算的本质，方能得到最精华的东西。最要不得的就是会用函数库了就自以为了不起了。MFC就是典型，会MFC并不能带给你对编程本质的认识。
*** 可以在函数定义的前面调用函数而把函数实现放在最后，这其实并不是什么了不起的技巧，实现起来也相当的简单，只要放宽parser的扫描次数就行了，通过多次扫描得到最终的AST而不是一次，这样就可以很容易的实现这一点了。其实，一个好的parser本来就应该是通过多次扫描源代码得到最终的AST的，这样才是在时间上和空间上最优的parser。
*** 还有在parser里面也不应该做额外的语义检查，应该默认所扫描的代码本来就已经是正确的，这样才能继续简化写parser的复杂性，比较快的得到正确的parser。
*** GDAL删除featrue时比较特殊，需要REPACK一下才行。
*** 提高程序正确性最有效的方法是什么呢？在我看来，最有效的方法莫过于对代码反复琢磨推敲，让它变得简单，直观，直到你一眼就可以看得出它不可能有问题。――――王垠《谈程序的正确性》
** 2015/10/09
*** 在代码调试的时候修改代码，这也许是一个很容易被很多人忽略的技巧，但也许这一技巧非常的重要。我们可以通过在运行时改变代码的执行路径，跳过某些出问题的代码，添加代码已修正出问题的代码，我们甚至可以把出问题的代码删掉重写一下然后把执行头重新定位到代码刚开始的位置，唯一的不足就是我们无法改变已经产生的数据。
*** 使用代码调试代码。代码调试绝对不仅仅是直接用几个快捷键，看看数据就行了的，如果我们学会了在代码中写点调试代码，这样调试将变得更加的容易。
*** 其实在编写代码的过程中，绝大多数情况下，代码的可读性是第一位的。即使在某些对性能要求很高的代码中，如果为了代码的效率使用了某些很难以理解的奇淫巧计，也是不明智的，因为也许这部分的代码变得效率高了，但却使得代码整体的结构变得难以理解了，就使得整体优化变得难上加难，也是得不偿失的。
*** 检查内存泄露其实非常简单，重复执行你怀疑有内存泄露的部分很多次，看内存占用有没有升高，就这么简单，如果有就是有泄露。
*** 其实写代码很多时候就是对事情的重新组织，一个问题一旦被提出来，它所要做的事情就是那么些东西，你所需要做的就是合理的组织这些东西，尽可能的减少重复操作、冗余操作等，代码的优劣程度就在这里了。
*** 在编写代码的过程中所做的简单的、在一个函数里面的代码的等价转换不叫过早优化，在这个时候为了代码的简单易懂所做的一些变型是被接受的。
*** 要想做出一个好的产品，面面俱到是不可能的，你只能专注于当前最需要解决的几个方面，忽略其他次要因素，才能将事情做好，一开始就想全盘抓往往导致一个方面都做不好。
** 2015/10/10
*** 类型系统原本的想法是给参数规定一个类别，这原本是非常正确的。可是它错误的将类别定义为几种其他类型与方法的集合，这种定义就过于严苛了。这种定义无法处理子类型与方法并不完全一样确是同一种类型或者需要被当做同一种类型来处理的情况。由于这种情况确实存在而且广泛存在，所以需要方案来对这种类型系统进行修补，修补的方法就是继承、接口、虚函数、多态，可是这种修补又带来了新的问题，最大的问题就是耦合，代码的可复用性也受到严重影响。其实正确的类型定义应该是一段描述，类似于下面这样：
	(cond cond-clause ...)
	
	cond-clause	 	=	 	[test-expr then-body ...+]
 	|	 	[else then-body ...+]
 	|	 	[test-expr => proc-expr]
 	|	 	[test-expr]
它很难用编程语言直接表述（解决这个问题也许是一个很好的方向），但却是正确的。使用这种规则定义出来的类型才是真类型，才能真正发挥类型的作用。
*** 既然当前类型系统已经被设计成这个样子了，我们只能被动接受去使用它。规避缺陷，正确使用，针对具体的问题够用就好了。使用这种类型系统时要注意：
	1、需要类型时（比如函数参数、变量定义）应该尽量使用比较基础的类，最好是接口。也即如果一个类型需要变化（这是经常的），应该使用比较基础的类，最好是接口。
	2、如果一个方法需要变化应该将这个函数设置为虚函数，再使用继承来重写这个函数。
	3、如果属性需要变化，应该将需要变化的方法也就是虚函数抽象成为方法，然后也是使用继承来写不同的属性。但这种方法有个缺陷就是你可能需要很多个类，无论是编写还是使用都会非常困难，还有个变通的法子是使用Property工具，用PropertyList来表示变化的属性。
	4、如果是在某一个类里面的属性或方法需要变化不想被外界知道，应该使用pulbic、private这样的访问属性。
	所有所有的这些都是为了规避过于严格的类型定义而想出来的变通方法。
*** 类型系统（动态语言）不过是在其他无类型的语言（动态语言）的基础上加上了一个类型而已，继承、多态（虚函数）、访问属性（public、private）都是这个系统的一部分，抛开这些东西以后，其实两种系统并没有多大的差别。
*** 类型系统，至少是现在大多数静态语言使用的类型系统大大提升了语言的复杂度。这种复杂度带来了性能的提升和调试的便利，但同时也使得语言的灵活性大大降低了，得失之间是在是非常微妙，无法轻易说出那种设计更加的好。
*** 当初设计类型系统的人还是非常牛逼的，变与不变之间，他做了大量的工作，访问属性、继承、虚函数、静态变量、常变量、接口等等，这些东西共同作用使得我们的语言成为了现在这个样子，虽然依然有很多问题，但确实至少基本是可用的，还是非常牛逼的。
*** 其实自己动手实现一门动态语言还是很容易的，因为不用考虑访问属性、继承、多态（虚函数）、const等等非常多的东西，完全可以一个人动手来完成。
*** 我变了吗？我已经养成了干活看上面在不在，如果在的话就偷偷偷懒的坏习惯了吗？不行，要改。
*** SHP的FID是会变的，无法唯一标识一个Feature，ID是必须的。
*** 编码的过程中，不应该把任何类成员暴露给外部，因为一旦暴露，就可能会被人去修改这一个属性，而只修改一个属性值很有可能会使得整个类处于不一致的状态。比如我们一般设置某个属性值的时候很多时候我们还需要设置一个状态标识表示这个属性已被修改，这时就很容易发生只修改属性值而忘记修改状态值的情况。c#属性的提出很有可能就是为了规避这一问题，使得我们在修改状态值的时候还能附加的做出一些动作。
*** 经常有人自豪的声称自己的项目有多少万行代码，仿佛代码的行数是衡量一个软件质量的标准，行数越多质量越好，然而事实却恰恰相反。真正优秀的代码恰恰总是那些行数非常少的代码。――――王垠《设计的重要性》
*** 冯磊的接口设计的还不错，但代码写的一塌糊涂。。。
*** 使用函数参数逐级递增的梯队式的代码编写方法，参数最少的就是提供给外部的接口，最多的就是核心关键的底层函数，这是一种非常有用的代码编写技巧。
*** 使用Type来进行抽象，来编程。
*** TODO 在MapManager这个工程中，我第一次体会到了动态类型的威力。原来真的可以把属性大不相同的数据当做同一种类型来处理，大大减少重复代码。
*** 类型的本质是什么？不过是一个判断而已，使用c++、Java这种狭隘的类型定义语言只不过是减少了部分判断而已，很多情况下甚至会反而增多这种判断。从静态类型语言编程者向动态语言编程者转变时只要掌握了这一点就掌握了一大半。
*** 编程语言的本质是什么？不过是分类处理而已。像c++、java这种垃圾的静态语言定义了垃圾的类型系统企图规范这种类型的判断，结果越描越黑，把本来简简单单的类型搞得乌烟瘴气，越来越难，反而掩盖了本质。
*** 一党与多党各有各的好处优劣，简单来说，一党如果领导优秀的话是可以超过多党的，可以充分利用资源，实现迅速崛起，但如果领导腐败也可以坏到不行。多党由于竞争总不会太坏，但会有大量的重复劳动，导致资源浪费。总结起来就是说一党适合创业，多党适合守业。
** 2015/10/11
*** 关于类方法位置的调整，一个方法可能跟几个类有关，既可以被放在这个类里面，也可以被放在另一个类里面。这是就要作出权衡，有个简单的权衡方法，就是看函数参数。放在哪边函数所需要的参数比较容易获得就放在哪边。
*** 使用继承来进行函数分层的时候有一个简单的判断方法，就是看成员，每个继承层次都有自己的关键成员，如果某个函数需要使用到这些成员，理所当然这个函数应该被划分到相应的层次上面去。
*** TODO 模板在类型系统里面到底扮演了一个什么样的角色呢？如果两个函数代码一模一样，只有类型不一样（最常见的情况就是集合类型），那么无疑是可以使用模板的。
*** 其实模板只不过是一个函数生成器，它可以根据实际调用时所使用的不同类型自动生成函数，但这种生成的能力很有限，只能生成代码相同而类型不同的函数，代码哪个地方稍微有点不一样就有点麻烦了。需要将代码转变成为相同的代码，非常麻烦。
*** 为了增强模板生成代码的能力，最常见的手法就是使用函数重载，而且是参数个数形同，只有类型不同的函数重载，通过这种方式将原本不同的代码变成一样的，这样就可以生成对应函数了。
*** 模板其实也是一种对突破类型系统的手法，有些时候我们确实需要使用相同的代码来处理不同的类型（类型系统里面狭隘的类型），这时候模板就派上用场了。
*** 如果没有继承、没有多态模板也许屁都不是，这种抽象方法过于严苛。强行要求函数代码一模一样，只有类型不同本就是强人所难。但正是有了继承与多态，我们编写相同函数代码的几率提升不少，所以模板就变得有那么点作用了。不过实际编码中，还是少用模板为妙，不然很容易卷进稀奇古怪的报错中无法自拔。
*** typedef其实只是给类型起了个别名而已，并没有产生新的类型，你如果typedef了一个类型之后使用typeid().name来查看这个新的类型时会发现其实这个类型还是原来的类型，只是换了个记法而已。
*** 区分一个引用是作为输入还是作为输出有个简单的方法就是看它是否带有const前缀，如果带有的话表示这个参数是输入，并不希望自己被修改。但对于指针，不管是否有const标识我们都是无法看出它到底是作为输入还是作为输出的。
*** 类、访问属性、继承、多态、虚函数、模板这些乱七八糟的特性好像能解决某些问题，但实际上引入了更多的问题，包含有很多奇奇怪怪的陷阱，难学难用。其实，不用他们完全也可以解决各种问题的，实际的编程中，应该尽可能的少用这些特性，避开这些奇奇怪怪的陷阱。
** 2015/10/12
*** TODO 现在我已经基本做到了在12点以前睡觉，下一个目标――――坚持每天锻炼，注意是每天，不管遇到任何情况，不管多忙，都一定要抽点时间出来锻炼，强度暂且不定，但一定要坚持。
*** O2O指的是线上到线下，不是机构到机构，它是一种新的购物方式，在互联网时代它将取代面对面的交易方式成为主流，当前最大的O2O巨头是美团。还有京东也不可忽视。
*** 二维码到底代表着什么，为什么当今到处都是二维码？二维码其实是O2O的入口，O2O这一如此重要的东西就指望它来开始，所以当然如此重要。
*** 不能攒钱，你得把钱花出去，成为钱能生钱的东西，钱如果不花，那就是一堆废纸，没有任何作用。要时常花钱把这些废纸转变为固定资产，特别是转变为能生钱的资产，才能越来越多。
*** 有些东西买了以后是会贬值的，有些是会升值的，比如车、电脑、手机等这些是会贬值的，而房子、国债等这些是会升值的。要擦亮自己的眼睛，找准会升值的东西，及时的将钱换成这些东西。
*** 移动互联网真的还是未来的趋势吗？如果我现在转的话是否会变成刚转变成功，然后这个东西又不是趋势了呢。这需要自己的判断。
*** 保持皮肤湿润的秘诀其实很简单，就是身体内的水，主要是汗。皮肤表面的水必然会不停的蒸发，如果身体里的水不能及时补充就会造成皮肤干燥。使用护肤品虽然能减缓蒸发的速度却也堵塞了身体内废物的排出，不是好的方法，最好的方法就是多喝水，同时补充以运动，让身体的水分成为汗液排出，而不是成为尿液。一旦觉得皮肤干燥时就运动下出点汗。
*** TODO 其实完全可以用思考来治疗我的尿频。只要找准了原因再加上我对自己身体的认识辅助以思考，完全可以不药而愈。
*** 关于我的尿频的治疗方法：
	1、多喝水辅以运动，让我的身体习惯性的使用排汗系统来进行代谢而不是排尿。
	2、是戒除手淫看片的恶习。
	3、注意休息，保持充足的睡眠。
	4、辅以中药治疗。
*** 关于安卓开发，安卓使用的是一个xml文件来组织所有的空间，安卓框架会去解析这个xml文件，根据上面的内容生成程序界面，实际上相当于使用这个xml文件来写了部分代码。
** 2015/10/13
*** 为什么java要把tostring这个方法放到object类里面去，因为这是对象数据可视化的一个接口，不管什么类都需要它。
*** 我使用对象的记忆功能大大提升了生成ID的效率，这不能不给与我很大的启发――――何谓副作用，持久化对象是一把双刃剑，它会使我们的代码面临并发困境，但有时也能大大提升程序的运行效率，避免额外重复计算。
*** 实际上，使用对象来记忆住程序的运行结果，下次计算时直接取结果而不是再次计算，这是一个非常重要的程序优化技巧，特别是那种不依赖于其他外部变量的纯函数，这时如果能够使用一个外部变量来记住函数的执行结果，下次需要时直接取用结果而不是再次计算，将大大提升程序的运行效率。比如生成新ID时额外用一个变量去记录当前最大ID，避免遍历，再比如读文件时使用一个额外的对象记住文件的数据，下次读时直接去取。
*** 缓存系统的本质是什么？其实本质就是将低速介质上的数据存放到高速介质上或是将需要通过复杂计算才能得出的数据放在介质上，需要的时候直接取，以提高数据访问效率的方式而已。其实它非常类似于使用副作用来提高函数式编程的效率这一技巧，两者的本质是一样的。
*** TODO 其实常见的代码块模型就那么几个，掌握了就可以飞速的看代码以及对代码进行变型了。我们甚至可以把这几个模型通通继续抽象成为函数，使得所有的模型都变成一句话，这对函数式编程是非常有好处的。
*** 最常见的代码块模型就是循环结构，只要是循环结构，就必然是对数据集合进行操作，这些操作有：
	1、求最小、最大、最接近等求最型结构。
	2、求第一个或最后一个满足条件的数据。
	3、求所有的满足条件的数据，这种情况通常除了一个数据集以外还会有一个结果集，用来保存得到的结果。
	所有循环结构，都跳不出这三种操作。
*** 关于循环结构，不要忽略了用来排序的双层循环结构，这种结构实际上就是两次求最操作，和一层循环并没有什么本质不同。
*** 次常见的代码块模型就是选择结构了，这个结构比较简单，主要要注意以下几个结构：
	1、if(...){... return;}...
	2、if(!...)...
	3、switch(...)
	{
	...
	}
	差不多就这些了。
*** 其实吸附的实现并不难，无非就是几次遍历求最小罢了，也就是求几个数据集中的最值问题而已。
	
** 2015/10/14
*** 乱世靠专制，太平盛世靠民主。专制如果领导人得宜的话可以飞速发展，民主无可避免会陷入吵架扯皮最后还啥结论都没有的境地。
*** 接口实际上是类型的抽象，是它使得我们可以在类型大体不变（也就是几个公用的方法不变）的情况下修改具体类的行为，改变函数的功能。
*** 设计模式只是指出了几种特殊的情况，作为例子我们看看就行了，在实际的编码过程中，真正有用的其实并没有几种。而且java所提供的抽象方法并没有几种，不记忆这几种方法而去记忆更加复杂的几十种模式是非常不明智的行为。
*** java如此简单，就提供了那么几种抽象的方法，虽然用这几种方法也可以做到各种各样的事情，但却很麻烦。相比于lisp的简单实在是不值一提。
** 2015/10/15
*** 实际上增删查改这四个操作是有冗余的，真正必须的只有增加以及查找，更准确的来说只要有构造以及遍历就足够了，就可以完成此数据结构上的一切操作。删除可以交给垃圾回收，修改可以使用重新构造。
*** 实际上，标准的纯函数式编程是只有增加与查询，并没有删除与修改的，删除交给垃圾回收，修改是纯函数式编程所抵制的，也就是像set!这种东西是不允许存在的，但有时候确实没有修改不方便，特别是在对象很大的时候，所以lisp做出了妥协，还是加入了这个东西，虽然变得不那么纯了，但却更实用了。
*** 变量其实是最基本的抽象方式，使用变量可以抽象一切。类是变量（通过继承）；类函数是变量（通过虚函数）；类属性是变量（通过把基本数据类型抽象成类）；接口是变量（接口是更纯净的类，也是通过继承）；函数也是变量（这里指普通函数）。编程的本质就是通过合理的使用变量来抽象变化，找到业务中不变的部分，解决这些问题，让人将注意力放在真正需要人工处理的真正变化的部分上。
*** 除了变量以外，还有个不可忽视的东西――――作用域。作用域是用来控制变量作用区域的附属设施，是它使得变量变得可重用了，使得我们可以使用同名的变量表示不同的东西，实际上也就是使得变量可变了。作用域的近义词――――命名空间，就是因为这一特性才受到了各个语言专家的一致好评的。
*** 文件的本质是一个字符串流，就是一个普通的字符串，如果直接在此字符串上进行操作，增删查改的效率都必然大受影响，比较合理的方法是将起读到内存中成为结构化的数据，这样增删查改起来都会非常的容易，效率也高。
*** 编码的过程中，尽量不要出现两层循环，两层循环读起来就已经比较费劲了。
** 2015/10/16
*** eshell是emacs的又一大杀器。为什么这么说呢？
	1、它比minibuffer方便，它可以调用emacs的任意函数，包括不是interactive的函数。它可以带任意参数，不像minibuffer还要记忆复杂的传参规则与快捷键，你甚至不用带括号。
	2、它可以任意拓展，你随便在其他什么地方写一个函数读入emacs的环境，马上就可以使用了，你甚至不用重开eshell，如果那个函数你不满意，只要是emacs函数，你就可以对它进行重写。
	3、它就是一个emacs的buffer，你可以随便使用emacs的快捷键，比如光标移动、查找替换、你甚至可以将所有的输出直接保存起来以便今后查看。
	4、与操作系统无缝接合，它可以直接调用你写在系统环境变量路径里面的任意程序，所有cmd里面可以调用的程序它都可以调用，而且输出完全一致，你甚至无法对这些命令进行重写。更好的是，你可以使用一些linux系统下的命令，比如ls、cd、mkdir、cp、grep等等，完全不用装cygwin。
	不过目前eshell也有些小问题，就是首先它还无法显示中文，还有就是放在环境变量中的快捷方式似乎还无法识别调用。
*** emacs的设计中有很多地方是值得我们借鉴和学习的。
	1、程序环境。emacs后端是由elisp驱动的，图形化界面只是一个前端。这个后端环境是可以被任意修改和重写的，你觉得哪个函数不对，随时可以重写它。你也可以随时自己写函数添加到这个环境，然后就可以在前端调用了。
	2、灵活的快捷键。你可以将这些任意函数绑定到任意快捷键上，然后就可以使用这个快捷键来调用它。当然快捷键太多你也记不住，所以有时候你也需要在mini-buffer上面直接打函数名称来实现函数调用。
	3、模式的设计。分为主要模式与次要模式，分别有不同的快捷键与函数，用于各种不同的交互方式，这一设计统一了很多程序，防止冲突。你可以使用主模式来切程序，次要模式来进行一些附加的操作，比如补全、提示这一类通用的操作。
	说了这么多，其实最关键的部分是一个完全可配置的环境这一设计，我们可以使用elisp这一套统一的API而不是配置文件来修改这个环境里面的任意部分。
*** 关于绘图这一模型的设计。绘图实际上由三个部分组成――――纸（Bitmap）、笔（Paint）、绘画者(Canva),这三者是绘图过程中不可或缺的要素，不管你要绘制什么图形，都要先将这三者给设计好。一般是先将纸与笔设置好，然后使用绘画者来进行绘图。skia是这一模型的实现。
*** 要做一件事，语言是什么不重要，关键是要设计好模型，一般这个模型从现实中搬过来会比较容易理解，比如绘图，不管用什么语言，使用什么框架，必不可少的就是纸笔以及绘画者，跳不出这个模子。
*** TODO 实际上绘图的模型是一个非常广泛使用的模型，非常有用。先定义两类对象，一个主动者，一个被动者，然后再定义个控制着用来对主动者实施动作附加给被动者，实现功能。这一模型是可以被大量使用的，比如。。。
*** lisp本质：
;;数据
cons	;;构造
car		;;遍历一
cdr		;;遍历二

;;判断
atom?	;;区分类型
eq		;;区分值

;;处理
cond	;;依据判断做处理
quote	;;代码转数据
eval	;;数据转代码

实际上最初的lisp并没有定义真假，因此只能用空列表表示真假，这是设计错误，所以应该将bool添加到lisp的设计中。
** 2015/10/18
*** 失去学习的习惯是件非常可怕的事情，相比于失去知识，失去获取知识的习惯更加可怕。
*** 如果你没有获取知识的欲望，随便找个东西去学就好了，一旦你被这个东西里面的一些东西勾起兴趣，你会自然而然的去研究它。
*** 这个道理其实可以推广到很多方面，当你不知道学习一个东西意义何在的时候，“just do it.”也许做着做着你就会发现这个东西还是挺有意思的。而有意识很多时候就足够了，人，太过功利，什么时候都想着有利可图才去做并不好。因为只有兴趣才能让你不管这个东西现在是热门还是不热门的时候始终坚持下去。
*** 在scheme里面，当碰到未知atom时，scheme会去寻找这个atom是不是一个函数，如果是就返回这个函数的求值结果，而common lisp不会，它直接寻找这个atom是不是一个变量，不是就直接返回nil。这也许是这两者最大的差别了。
** 2015/10/19
*** c#语言还是有很多力有未逮的地方，比如无法修改已有类的方法，即使这个方法是虚的，只能以这个类作为模板，来重新构造一个新的类，改写其中的部分内容，这方面lisp就显得强很多了，它可以通过修改已有的函数来改变其他使用这个函数的函数的功能，极大的提高程序的可拓展性。
*** 关于继承与组合。当我们发现某个函数经常需要被使用时，我们需要将这个方法提出来进行重用。常见的重用方法有继承与组合两种。继承是将这个方法依然放在这个类里面，只不过是提到父类里面去罢了的重用方式；组合是将这个方法提到其他的类中，然后用这个类使用其他类中的方法的方式。显然，前者能够取得更大的权限，比如能够使用父类的成员，可以重写父类的虚函数等，但同时也耦合性更强，使得子类更难被重用。后者虽然只能使用共有的函数，但两个类其实都还相对独立，更加容易与其他的类自由组合，更加的灵活好用。
** 2015/10/20
*** 尽可能的使用结构化的数据，这样能够避开解析这个非常麻烦的过程。
*** 编程的过程中，效率为王，不用纠结于什么语言，能够最快的解决当前所遇到的问题才是最重要的。
*** 为什么会有人喜欢无论什么事都用emacs来干呢？因为这样你能够在任何时候使用到emacs提供的接口API，快捷键，这样你就相当于有了一个拓展性非常强而且非常容易拓展的操作系统，而不像普通的操作系统一样虽拓展性强，但拓展起来非常麻烦了。
*** 有些时候，我们需要自己存些数据，尽管有些可能需求人员都暂不需要，但保持信息的完备性是个很重要的东西，这样就可以以不变应万变，即使哪天别人提了个很奇葩的需求你也很容易把那些数据给取出来。
*** 程序员真的是一个设计师，各个功能模块的接口都需要被小心设计，让用户觉得好用而且没有逻辑错误。
*** 使用版本号来区分版本，不管是数据版本还是软件版本，版本使得我们能够在同一环境下使用不同的版本。
** 2015/10/21
*** c++缺乏给已经写好的类添加方法的能力，只能基于已有的类修改（继承或组合），产生新的类，然后使用新的类调用已有的方法和添加的方法。这样当遇到一个类已经写好，到处都在用时，整个修改类名显然不是一个好的方法了，这种情况下应该使用c++就无能为力了，这种强加的类名与方法组的绑定有时候很麻烦。c#提供了拓展方法能够用来解决这个问题，它能够在不修改类名的情况下拓展类的方法，这样就可以防止类名与方法绑定引起的麻烦了。
*** 其实拓展方法这个东西的真正意义在于它冲破了类名对其内部方法的禁锢，使得我们可以在不改变类名的情况下给类增加方法，这实际上是对现在这种过于严格的类型系统的一个突破，而且是一个不小的突破。现有类型系统最大的缺陷就是对属性与方法的限制过于严格，有了拓展方法之后这一点就不存在问题了。
*** static的本质是什么？本质是常量，是变化之中的不变，是一种权限控制，伪装的public、private这些东西。我们使用类来给事物抽象模子产生对象，然后这个模子里的所有东西可以随意使用这个模子里面的属性，但有些方法是不需要使用属性的，开放这种权限非常容易引入副作用，因此用static限制一下。
	1、用它来限定某个属性与方法不应该与这个类的其他成员扯上关系，不用创建对象就可以访问，不管哪个对象访问获取的结果是一样的，没有"副作用"。
	2、用来限定某个类不能生成对象，这个类不是一个用来生成对象的模子，它只是用来将抽象变化的过程中一些不变的东西，没有"副作用"的东西给固定下来。
*** TODO C++引入了命名空间，却没有好好的使用命名空间，相比之下，c#与java就好很多，只要是同一个命名空间里面的东西，不管这个类在哪里，应该都是可以直接使用的，为什么要强行加入一个include呢。
*** 实际上在编程过程中，多数情况下只需要函数就可以了，并不需要类这个像函数又不是函数，总是在关键时候给你使绊子的东西。
*** 其实设备控制的难度在哪里呢？1、联动；2、调试。
*** 平行化架构的优势就在于各个模块之间互不影响，不会出现一旦上层设施出问题，下面所有人都会无法响应。这在编程中非常重要，尤其是协作的时候，要确保一个人与另一个人之间彼此平行，这样才能一起开发。
*** 在一个大型的软件里面，如何做到模块与模块间解耦
** 2015/10/22
*** 关于c#中region的使用，多数情况下，一旦在你的代码中出现了region，就表明你这个类或函数太大了，你应该考虑将这个部分代码转移到新的类或函数中，小到让别人很容易的就能看出这个类或函数是干啥的，这样才是优质的代码。
*** region只不过是一种辅助别人看代码的手段，作用类似于注释，只不过比注释多了个折叠的功能。同注释一样，这东西应该尽可能的少用，良好的代码应该是让别人一看就可以看懂的，并不需要借助于这种辅助的提示设施。真要用，最多一般也就用events、properties、methods、fields就好了。
*** 关于谈对象这个事，奉劝大家不要急，想要找个优秀的对象自己首先得优秀。与其花时间不断的换对象，不如冷静下来花时间提升自己，只要自己足够优秀，找起对想起来就会非常容易而且任你挑选。
*** 关于写代码的层次问题，不需要别人来给你规定代码的层次，你自己就可以形成自己的代码风格，形成自己的层次。我自己的代码层次为UI一层，业务一层，逻辑一层，一般的业务这三层就够了。比较简单的情况下，三层就是三个类文件。如果业务比较复杂，会有三组类，但逃不开这三个东西。一般业务层最难复用，UI层比较难复用，逻辑层最好复用，所以要尽可能的多抽象代码到逻辑层。
*** 对付switch...case...有个非常取巧的办法是使用参数类型重载，直接让编译器根据参数类型去寻找相应的函数，这是一个非常取巧，而且非常常用的规避分支判断的方法，配合继承，这样就能在不修改函数、不修改类型的拓展代码了。
*** 实际上类型系统提出了类型的概念，我们在使用类型系统的时候要充分使用这个东西，比如：继承、重载就是最典型的使用类型系统的例子。
*** 尽可能的多用var、多用auto这种不需要显示声明类型的符号，这样写出的代码比较像动态语言写出的代码，逼格比较高。
*** TODO 自己设计一个分词器，运行读入自己随手写的字符串并解析出里面的内容。这样做意义有多大，为什么不直接用json写点词进去，然后直接解析呢？虽然用json也可以parser，但更简单的方法还是自己写一个mini的parser，这样使用起来更加简单方便。
*** 把程序中的数据全部手写到json里面去，运行的时候来从文件中直接取出想要的东西，我完全不用自己手写parser，就可以轻易享受parser带来的好处。
*** 会用parser（不需要会写）的人可以用配置文件来随意操纵程序。会用解释器的人可以用程序（实际上也是特殊的配置文件）来随意创造程序。emacs就是后者的典型。
** 2015/10/23
*** 现有的类型系统即使最初并不是一个好的系统，但经过这么多代的修改，不断的完善，现在已经发展成为一个完备的系统了，可以满足绝大多数情况下的需要，当前最完备的静态类型语言大概是c#了。这就是完备的力量，最初的抽象肯定会在某些地方存在欠缺，但只要不断改进完善，最后即使是无法做到最简，也可以在大多数情况下完成事情了。
*** 关于状态展示，如何统一管理状态展示，只要数据一变就在界面上即时刷新呢？应该建立一个容器，然后每隔一段时间将这个容器中的所有元素遍历一遍进行显示，用户只需要在这个容器中注册一下，就可以实现状态的及时显示，不用去额外设置，这样才是比较简单方便，耦合性比较小的做法。
*** 关于分词，
*** 关于一个类中各个模块之间的交互，如果某一个模块需要另一个模块的数据，只需要通知另一个人在他的类中给出接口，然后你就可以在容器类中调用这个接口获取数据，然后传给自己的模块，这是比较一般的通信方式。也许可以使用static来通信会更好点。
*** 为什么要生成AST？
*** 树是什么？树不过是一个类本身又有它这个类的对象的集合。类似的，如果这个类对象只有一个，那么它是链表。
*** 关于代码测试，基本的代码覆盖还是很有必要的，因为在代码运行的任何一个地方都有可能崩。
*** 其实代码崩溃的原因无非就是碰到了未预料到的情况。
*** 关于代码分层结构层次间的通信，上层数据要想丢给下层直接用参数就可以了，这是很简单的逻辑，也很容易实现。但下层数据要想回传给上层就麻烦一些了，一种做法是下层提供获取数据的接口，然后上层去主动调用这个接口，实时获取说需要的数据，这是常见的做法，不过这种做法不实时，无法做到数据一改就马上在上层显示。当然，要做到实时也是可以实现的，方法就是使用事件。
*** 事件的本质是什么？实际上就是下层给上层传递数据的一种手段而已。在常见的分层结构的设计中，上层总是处于指导地位，下层即使产生了数据它不主动去取依然白搭。由于上层并不知道下层什么时候产生数据，所以采用这种设计的程序无法做到实时显示下层数据，需要额外工具的支持，这种工具就是事件，它可以主动的将下层的数据推给上层去处理，避免了轮询的资源浪费。但其实这种方法经过了一个中间过程，比较麻烦，如果不是比较重要的必须的数据还是不要这么麻烦为好。多数情况下直接把对象推给下层然后让下层去处理也许更合适。
*** c#为什么要设计属性这个东西？我们经常碰到这样的情况，先设置私有的字段，然后再设置一个或几个公有的方法来访问这个字段值，这实际上是在没有属性的情况下使用字段以及方法伪造出来的一个伪属性，把本来应该在一个地方写的东西分开在了几个地方来写，书写以及维护起来都比较麻烦，但有了属性，这个问题就不存在了，我们可以把这两个东西写在一起了。
*** 多问几个为什么，中国人总是习惯于去学怎么用，却不喜欢去问为什么，以至于学习到的知识一旦到了具体应用的时候只会照葫芦画瓢，不会根据具体的情况去变通，更不懂怎么去独立设计一套这个东西，这是非常错误的。
*** 无论是写什么函数库，一定要抱着这样的思想，你是写出来为别人提供服务的，首先应该想想别人可能需要什么，然后主动提供出来，应该保持基本的信息完备性，当别人提出来而你发觉自己没有这方面的接口一般就表示这设计的失败。
*** 既然上层可以控制下层，那么如果我在下层中也把上层对象的引用放进去，那么不就可以反过来控制上层对象了吗！这样实际上形成了一个流程环，上层可以操纵下层，下层也可以操纵上层。
*** 我喜欢不断的修改自己的代码，不断改不断改，直到越来越短，短到不能再短，然后获得巨大的成就感。当然这种短并不是把几行代码写在一行，然后看起来短的那种短，而是真正简化了逻辑、优化了流程，简化了不需要的代码，使得代码非常容易读懂的那种短。
** 2015/10/26
*** 如何实现层级查找？往下？
*** map的本质其实就是做索引。
** 2015/10/27
*** 面向对象的编程思想――――给每个对象一个类，然后使用这个类的集合来管理这个类，一层嵌一层。
*** 编程中，做的事越少，所需要的参数越少，事越多所需要的参数就越多。所以，一般底层，干一些职责比较单一的事的层参数会比较短，接口层，涉及到具体的业务层参数会比较长。
** 2015/10/28
*** 调试if、for等复合判断语句时，最好打断点的位置是if、for所在的那一行，而不是里面，防止因为条件不满足而不进入语句内部导致的断点无法到达，当然，还有一种方法是在所有的分支路径里面打上断点，这样稍微麻烦点。
*** MAP的本质是文件夹，文件夹名为key，内部文件为value。
*** 遍历文件夹下的子文件的时候，我需要一个方法获取它所在的文件夹名，以便我将它加入到相应的文件夹数据中，这个时候将文件夹名存放在每个文件中就非常有必要。
** 2015/10/29
*** 如果程序的模块化做的不好，那么必然导致代码膨胀，随便修改个地方都会要到处改，牵一发而动全身，非常容易出错，后期的维护就是一场灾难，所以，为了是程序始终容易维护，必须做好模块化。
** 2015/10/30
*** obj.do(args)与do(obj,args)前者是主动句，后者是被动句，主动句有着更好的意义表达以及意义的连贯流畅，使用c#的拓展方法可以将被动句转换为主动句。
*** 类型到底是什么，有一些共同的属性与方法，可以进行求值。从这一点上来说，函数也是类型，它与其他像整型、字符串型这些东西并没有什么太大的不同。
*** 使用继承不断进行功能扩充与拓展，既不影响原有的代码，又能在需要原有类的地方直接使用新的类，实现新的功能。这是垂直拓展，还有一种就是水平拓展，拓展的方式就是将原有类的对象放到新的类里面，然后用新的类来实现原有类的功能，同时对原有类进行一些扩充。垂直拓展不需要修改原有类的代码，但耦合性高，水平拓展需要修改原有代码，但耦合性低。
*** 编程过程中，步子跨的太大容易扯到蛋，慢慢来，循序渐进，一点一点进步。
