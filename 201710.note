* 2017/10
** 2017/10/09
*** 调研性质的东西时间最难估，因为永远不知道前方还有什么坑等着你。
*** What is complicated in unit tests is not the tests itself — it is the art of separating as much code as possible so that it is unit-testable. And code that is unit-testable is code that has little dependencies on other modules, and does no I/O.    ————Gil Tayar《Testing Your Frontend Code: Part II (Unit Testing)》
*** 前端测试的坑：
	* 移动端测试
	* mock
	* nightwatch custom-command
*** 关于发布订阅模式有三个核心的api————publish（发布，也叫trigger/dispatchEvent）、subscribe（订阅，也叫on/addEventLinstener）、unsubscribe（取消订阅，也叫unbind/removeEventLinsener）。注意没有取消发布，因为发布是同步的，瞬时的，当然无法取消，而订阅是异步的，它会一直等待发布的消息，当然可以取消了。
*** 关于mock，js最强的mock工具叫sinon，没有之一。
** 2017/10/10
*** 关于const，const只是表示引用不可修改，并不表示引用的对象不可修改，比如：
#+BEGIN_SRC javascript
const obj = {
	aaa: 111,
	bbb: 'aaa',
}

obj.aaa = 222; // 正确，可以修改const指向对象的数据
// obj = {} // 错误，不能修改常量引用
#+END_SRC
*** IMPORTANT sinon的核心在于监听与替换函数实现。spy是监听者，它可以监听到函数被调用的情况，比如函数参数、调用次数、this等，被监听的函数依然会被调用，只是会将调用信息记录下来以便做断言；stub不仅可以监听，还可以替换实现，它可以强制让函数返回某个值而不是原值，被替换的函数不会再被调用；mock是带断言的spy，它的作用也是监听，只不过它集成了断言，能够设置指定情况下的断言，仅仅用在特殊场合。
*** IMPORTANT 编程的过程中，保持单一入口或是几个入口是非常重要的，只有这样才会有最强的控制力。比如:
	1. react的render
	2. redux的store dispatch action to reducers
	3. vuex的store dispatch action, action getter state and commit mutation,mutation update state.
	4. koa的use middleware
	5. ajax的封装库等等
	这些都是尽量减少了入口实现了更好的控制力。
*** 什么是plugin？plugin实际上是一个定义好格式的配置对象，写好框架代码，读取配置对象中指定的属性与方法，就能将新功能集成到原系统中，用户对框架是完全黑盒的，这样才能保证代码安全，不出bug。
*** TODO 统一的Mock机制，比如一个开关，打开后使用mock的数据，关闭后使用接口的数据。当APP启动，所有接口请求前，如果mock处于打开状态，创建一个沙盒，使用mock的数据，后期可以自由控制mock开关，选择使用的数据。好处：
	1. 统一的mock机制，解除后端依赖，无需后端接口写好才开始开发。
	2. 代码规范，所有mock的代码一目了然，mock的代码与正式代码隔离。
*** 测试Tips：
	1. 重要的问题，复杂的逻辑，最可能出现问题的地方，只有写代码的人自己才清楚。
	2. 每次出现问题，把它写进测试用例，这样就能很大程度上减小再次出现的几率。
*** VIP、单点、用券 * 用户是否登陆套餐
** 2017/10/11
*** 默认情况下，使用sinon的stub的callsFake是会替换掉原有函数的，原函数不会被调用，这时候如果你还想调用原有函数，只需要使用一个闭包将原函数存起来然后在fake函数中重新调用一下就好了，如下：
#+BEGIN_SRC javascript
// stub
const originFunc = def.fn1;
sinon.stub(def,'fn1').callsFake(arg => 'ooo' + originFunc(arg));
#+END_SRC
	这一技巧同样适用于不想全函数替换，仅仅是想改变下调用参数的情况，如下：
#+BEGIN_SRC javascript
// stub
const originFunc = def.fn1;
sinon.stub(def,'fn1').callsFake(arg => originFunc(arg + '222'));
#+END_SRC
	总之，有了替换就有了一切，修改原始函数可以通过闭包来实现。
*** TODO sinon change this, change arguments
*** IMPORTANT 一个函数中调用了另一个函数，如果我们想要修改被调用的这个函数的实现，使用stub是一个好的选择。但并不是任何时候都是，我们完全可以不用sinon，直接使用修改函数实现也能达到目的，比如：
#+BEGIN_SRC javascript
// stub not use sinon
const originFunc = def.fn1;
def.fn1 = function(arg){
  return 'asdf'
};
console.log(abc());
def.fn1 = originFunc;
#+END_SRC
	这取决于你对js的掌握程度。这实际上也是sinon的stub的实现原理：
	1. 当我们stub一个函数时，sinon会把这个函数存起来，然后当我们调用stub对象的各种api的时候，sinon会帮我们去生成一个新的函数用来替换被stub函数的实现，然后当我们模拟完毕，调用restore的时候就重新将原函数还原为stub之前的，这样就实现了函数替换与恢复。
*** DONE 原生页面 vs h5页面：
	1. 原生页面具有性能好、可以调用各种底层传感器的优势，同时也有本地打包、适配困难的劣势。适合于一些比较复杂、对性能要求高的场景。
	2. h5页面具有热更新容易、适配简单的优势，同时也有性能差、无法调用底层传感器的劣势。适合于一些比较简单的页面、活动页、需要快速更新的场景。
	3. 两者优缺点正好是互补的，要根据实际情况选择合适的方式。
*** TIPS 在自动化测试中，我们经常会碰到由于API自己会输出信息干扰到了结果输出，导致生成的结果很难读的情况，这一问题实际上很好解决，在before hook中将console.log hook成空，然后在after hook中恢复就可以了。
*** IMPORTANT sinon的API设计中为什么要将obj与fn拆分开来而不是将他们写在一起呢？比如sinon.spy(obj,fn)而不是sinon.spy(obj.fn)呢？
	因为如果合并在一起的话是进行传递的话是形成了一个新的引用，然后改变了新引用的值，当函数返回时这个改变就恢复了，而拆开的话改变的是所引用对象的值。简而言之，前者改变的是引用，而后者才是所引用的值。
*** 何等的幸运，赶上了最好的时代，人的能力无限大。
*** IMPORTANT 我常常以为emacs具有极强的拓展性，便于定制什么的。但实际上网页本身也具有很强的拓展性，通过使用tempermonkey，我们能够对网页添加钩子，注入我们的自定义脚本。使用前端最熟悉的html+javascript+css对页面进行功能拓展，实现比如改变页面内容、页面样式、小窗口播放、去广告等各种功能。唯一不足的是我们只能操作网页，无法站在更高的层级，比如空白页面、浏览器等这些层面实现功能定制。
** 2017/10/12
*** TIPS 所有页面，基本都是差不多的逻辑：
	AndroidParams --> otherParams --> pageData --> renderPage --> bindEvents --> focusLogic --> goAndBack
*** TODO 关于Android与js间的相互通信，实际上很简单，只需要通过windows.Android这个公共对象就可以了。java端在这个对象上写入方法提供给js，然后js就可以调用了，反之亦然，这应该是最简单的方式了。
*** IMPORTANT focus逻辑如何写，如何与vue无缝结合？这么来写，将focus给单拎出来，我们只需要在需要focus的元素上加上一个focus-id,然后所有有关focus的问题围绕这个id来进行，单独放在某个地方。这样一方面是非常灵活，同时也不损失任何功能性，还可以使用缓存统一提高性能，因为focus逻辑本来就不跟其他东西相关，我们没有任何实现不了的东西，实在是非常完美。我们也可以在它实现方案上加上scope的概念，实现区域逻辑。id是关键，通过id，我们能够实现显示逻辑与focus逻辑解耦。
*** TODO browser-sync
*** getAndroidParams始终是一个变数，它使得我很难下断言。我必须搞清楚它的来源，对它坐下模拟用例才好写。是通过cookie来取的coupon，而cookie是在androidParams中的。当getAndroidParams时，如果不在安卓环境下，getParams必然会报错，这样会跳到函数的catch分支中去，此时返回用来测试的AndroidParams.
*** 写测试实际上非常类似于自问自答，自己设置问题，然后自己解答。
*** redux/vuex只不过是一套实现对数据增删查改的API而已，使用它们来进行数据管理格式比较统一，读起来比较简单，容易维护。并没有其他什么了不起的东西。
*** TIPS webtv-vue的webpack打包做了哪些事情呢？它只不过是将views下的二级目录下的main.js打包到了dist/static下对应的js与css，同时在dist目录下生成了对应的html而已。最后在dist下开了一个服务器，这样就可以在浏览器中打开对应页面了。
*** TIPS vuex中：
	1. dispatch触发set的唯一入口。为什么不直接set呢？因为直接set各自调用自己的set，会导致结果无法追踪。
	2. getters是state的唯一出口。我们当然可以直接从state中取数据。但这会导致关联数据的计算无处安放地方。比如某个状态在state中存的是1/2/3，但外部需要使用的是状态一/状态二/状态三这样的中文。我们需要对state进行下处理了然后暴露给外部，这时我们使用getters。还比如state中存了很多数据，但是我们需要提取出一个数据块给外部，这时也可以用getters。
	3. commit是mutation的唯一入口。它将数据提交到store存储。然后我们可以在vue中使用computed或是props取回来。
	4. TODO store往往是通过好几次mutation到正确状态的，如何模拟？
	这实际上是一个非常好用的编程技巧，将一堆函数使用同一个入口，是的这些函数的调用变得可追踪，这才是redux/vuex的核心思想。
*** IMPORTANT 写测试用例就是一个逐步去除依赖，一个个区块测试，然后把这些区块合并在一起的过程。最底层是工具函数，上层是MVC的模块（实际上就是数据、UI以及把这两者整合起来的部分），再上层是集成。写测试用例写多了对深入了解系统是非常有帮助的。
*** 将vue-cli-test使用vuex重构。
*** 测试用例之难难在哪里？
	1. 没有办法调试————不要使用PhatomJS,也不要开什么single-run,使用chrome，然后在chrome中调试,当修改源码的时候自动跑测试，美中不足的是需要手动刷新页面。
	2. 报告经常会混入一堆乱七八糟的输出————使用sinon mock掉console.log
** 2017/10/13
*** data props computed————vue组件数据的三大入口。
*** action是mutation的封装，它给予了mutation异步的能力。我们可以通过commit一个mutation或者dispatch一个action来修改store的数据，前者可以通过哦mapMutations来简化，后者可以通过mapActions来简化。修改后我们需要从store中取回数据，这时我们也有两种方法，一是使用state，获取原始数据，有个简化方法mapState。还有一种就是getters，获取衍生数据，也有一种简化方法mapGetters。这样两个入口、两个出口，是的vuex的API相当简单清晰。
*** 有时候，我们想要获取变量名，但变量名又获取不到，这时可以利用一个等价关系：
	abc.def等价于abc['def']
	注意：这两种形式并不完全等价，后者还可以包含特殊字符。
*** vue中，即使使用了单文件组件，依然需要在外层使用components来引入组件，然后用template字段触发渲染，然后在字段值中将data中的数据作为props传递过去，否则页面上什么也不会有的。
** 2017/10/16
*** 关于focus逻辑有两种实现方法，一种是提供数据与方法，然后在模块外调用提供的方法实现focus，一种是只提供数据，然后全部在模块内实现focus方法。第一种方法实现起来比较简单，但写出来的代码不大好看。第二种实现起来会复杂点，特别是数据格式的设计，但要是实现了可以最简单的实现focus逻辑。
*** 如果想在promise的异步调用链中如果想插入新的异步调用，有两种实现方式。一种是加个then，然后加上异步处理逻辑，另一种是在then中return一个promise，这样也可以把异步调用插入的现有的异步链中，我们甚至可以用promise把几个异步调用合成一个然后返回实现链合并。
*** parent/data/props这就是一个组件的三要素了，不管是vue还是react都遵循这个原则。
*** 将component与store完全分离，以便于分离测试component与store。一旦组件中出现了vuex的东西(最常见的是mapState/mapMutation/mapActions/mapGetters）,单元测试就很不好写。应该只将关键的数据流写进vuex，而不是将所有的数据统统写进vuex。尽量将数据以props的方式传入，而不从vuex。
*** TODO 为什么不能在模板中写表达式？
*** 关于async/await，await必须写在async里面，但是调用async函数的时候是不需要在外边再加一个async的。也就是说，当前仅当函数中出现了await时才需要加async，初次之外，即使调用了async的函数也是不需要加await的。这是我以前一直记错了的地方，经验害死人啊。
*** 在函数前加async并不代表将这个函数变成异步函数了，在你调用await之前它依然是同步函数，跟不加async时没有任何区别。但一旦碰到await，它会将当前context给保存起来转而去执行其他同步函数，也就是说，此时才变成异步的了。
** 2017/10/17
*** 现有的将容器组件与展示组件分开的方式对测试是很有好处的，展示组件是很好测试的，但容器组件就比较难了，需要通过各种mock手段，即使写出了测试用例作用也很有限。
*** 对开放出的api要有感觉，任何复杂的系统，其底层接口实际上就那么几个，我们在这些底层接口的基础上进行封装，一旦这些接口发生了改变，我们只需要修改这几个封装的地方就可以适配到我们的系统。同理，只要几个很少的API就可以做到很强大的事情，比如console.log，就那么点东西，但是基于它的封装却能使我们的系统异常强大。
*** chrome的控制台是一个非常强大的控制台，能够使用它就不要使用坑爹的cmd。
*** IMPORTANT 测试驱动开发有什么好处呢？它能让程序员自发的去除多余的依赖，以搭积木的方式来完成程序的开发，这样最后写出来的程序无论是测试还是维护都非常方便。
** 2017/10/18
*** TIPS 其实之前我已经有意无意的使用过多次测试驱动开发了，我一般会另外开一个空白的工程，排除其他影响，只试验我自己想要试验的部分，然后在把它集成进入系统，这实际上就是测试驱动开发，先写测试，然后开发，虽然与TDD的原意是不完全一致的，但其实思想是差不多的。
*** 维护一个数据结构总比维护一个算法容易，因为算法比数据结构易变得多，也容易出问题得多。但使用数据结构容易损失灵活性，要注意抽出本源数据组成数据结构，而不是关联数据，这样能够将对灵活性的影响减小对最低。
*** TODO 也许可以先将scope外使用老算法，将scope间使用新算法。
*** 组件应该只跟数据（在vue中就是props），给定数据，渲染出正确的输出，不应该在外部根据数据做多余的事情。应该是纯展示的，数据不一样，展示就不一样，数据变了，展示就变了，这是组件最大的作用。
*** TODO what is vue's mixin ? what is it's function ?
*** 测试驱动开发有什么好处呢？它强制我们以一种搭积木的方式来写程序，这样写出来的程序可复用性会非常好，一旦出现相似需求复用起来会非常容易。
*** 在vue中，我们可以直接调用组件的method中的方法，这是一种测试措施，我们可以通过这种方式来验证组件的功能是否符合预期，能否得到正确的结果。
*** 实际上，在vue中，将通过new Vue（{...}）得到的对象命名为vm是一种很差的命名，应该将它命名为组件的名字，它实际上就是组件对象，我们可以通过这个对象得到组件的模板、methods、state等并修改它们，得到新的数据，它就是组件嘛。
*** TIPS vue实际上并没有做很多的东西，它实际上就写了一个函数（new Vue(...)），然后通过复杂的配置，使得我们可以很轻松的配置与组合这个函数，实现我们自己的业务逻辑。
*** 如何理解抽象？抽象实际上就是一个盒子，它能在开发人员与用户间建立一个中间层，只要定义好接口，开发人员与用户都能有很好的自由度来实现自己的功能。用户需要新的功能时，开发无论把代码写成什么样子，只要呈现的方式符合用户预期，就没有任何问题，以往老的功能也不会受到影响。
*** 实际上，单单vue的组件或是vuex的数据是很好测试的，但是一旦将这两者合起来一起用，测试就变得困难了，即使使用了各种奇淫巧技mock的情况下。
*** IMPORTANT mock是一种虚拟的场景，它代表不了实际情况，强行使用过多的mock使得测试通过是一种自己骗自己的行为，应该尽量减少mock，只有在我们不想触发三方状态变化的时候才应该使用mock，比如网络请求、文件系统等。
*** 如何写可测试的代码？应该尽可能的让我们的代码函数化，变成一个个函数，或是函数块（类实际上就是一种函数块），分离块之间的依赖，这样每个单独的块都是可以直接测试的，给定什么输入，会有什么输出都会心中有数，外部将这些部分组合起来，功能就实现了。
*** 展示型的组件是一种死的组件，它像是一个纯函数，给定什么输入，就会有什么输出。
*** IMPORTANT 统一数据获取、统一loading展示、统一错误处理、统一focus处理、统一页面跳转、统一测试用例等等。为什么要这样呢？因为只有统一了才会有优化空间，才能实现一改全改，才能实现像换就换，才能实现hook处理。
*** 无交互的纯渲染组件、有状态有交互的智能控件
*** TODO 测试中有个层次问题，应该从哪个层次去测试组件呢？
** 2017/10/19
*** 减少props传入，只传源数据，不传关联数据。只有这样才能尽量避免因为源数据与关联数据不一致导致的错误。
*** vue组件如何处理loading状态？
*** 组件就像一个函数，props就是函数参数，应该尽量保持函数参数的简洁与清晰。
*** 写测试用例到底有什么意义？需求做完后去补确实意义很有限。它真正的意义在于开发前去写，它能指导开发，让开发者站在用户的角度去审视一个组件怎样才能易于使用，应该传什么东西，得到什么，这样做出来的东西接口就会比较清晰，耦合也比较小。
*** TODO 其实vuex中充满着一个思想，消灭this，使用函数参数。比如mutation、action。为什么这样呢？这样能把函数依赖清晰的表示出来，避免模块内依赖，进而大大方便测试。虽然这样有时候会损失方便性。
*** IMPORTANT 回头看vue/vuex的设计，实际上它测试之初就很好的考虑到了可测试性，可测试性的关键是解除依赖，使得所有的代码都能像工具函数一样，只要给定输入，就能得到输出，不需考虑其他问题，要做到这一点需要有函数式编程的思想，但又要兼顾当前程序员的书写习惯，在两者间取得一个平衡。vue的答案就是参数化依赖，不要使用全局变量（this实际上是类函数间的全局变量，甚至IO也是一种全局变量），把所有的依赖都用参数显示的表达出来，这样测试就会非常好写。甚至可以说，vue/vuex（特别是vuex）之所以这样设计很大程度上是为了便于测试。
*** 关于vuex的测试，主要有getters、mutations与actions的测试，由于actions、mutations是同步的，而且将所有的依赖参数化了，测试起来非常好测，直接用指定的参数调用就好了。测试action会稍微麻烦些，由于action会调用外部api，需要使用mock处理下，然后就可以测试了。
** 2017/10/20
*** vue有了vuex后为什么还是需要data呢？是为了存储一些临时性的数据，比如input框的输入，只有点击了确定以后这个输入才会被传递到vuex，在之前存在data里就好了。
*** vuex的computed是用来设置当一个数据发生变化的时候更新组件数据的，它的源数据可以来自于data，也可以来自于外部，这点要格外注意，这样就会造成一个问题，一个组件的输入除了props以外，还有个computed。
*** 有个编程技巧，如果一个函数在调用前必须先调用下另一个函数，这种设计多数情况下不是一个好的设计，因为函数调用间存在依赖了，这种情况下有个技巧：
#+BEGIN_SRC javascirpt
	fn2(){
	  if(!fn1Called){
	     fn1();
	  }

	  // fn2 logic
	  // ...
	}
#+END_SRC
	这样直接将fn1给隐藏起来，用户只需要调用fn2就自动完成了fn1调用，使用起来就简单多了。
*** 关于vue与vuex的输入与输出：
    1. vue：
	   1) 输入有两个————props与computed
	   2) 输出也有两个————methods与watch
	2. vuex:
	   1) 输入有两个————mutation与action
	   2) 输出有两个————state与getters
	3. 这两者的输入与输出正好是相反的，vue的输入一般与vuex的输出放在一起，vuex的输出一般与vue的输入放在一起，这样协同配合，共同完成业务需求。
*** 在vue中，我们可以在组件实例上直接访问computed/methods，如果是data，需要加上个$data前缀。
*** 写测试用例实际上对开发者要求还是比较高的，它要求开发者能够把系统拆成很散的一块块，去除多余的依赖，然后写测试用例，这需要开发者多系统的结构非常清晰，能够很快搭建起一个简单的测试环境。
*** es6的导出函数写法似乎专门是为导出函数准备的，它使得我们能够以非常简单的语法轻松导出多个函数，这样我们能非常方便的对单个函数进行测试。
*** 异步事件必须要有个通知机制来告诉上层事件完成了，promise就是这种机制，但是promise需要程序编写者的支持，否则你是不可能知道一个异步事件结束的。
** 2017/10/21
*** store dispatch action、action commit mutation、mutation change state.
*** 使用vue/vuex要注意，多数时候UI产生的数据还需要经过一定的处理再传递到vuex，这个时候直接把这个数据封装逻辑写在UI上是不合适的，更好的方式是UI调用自己的method，然后在method里面封装数据，最后在调用vuex的method将数据提交到vuex。除了在自己的method里面封装数据外，还有个封装数据的地方，通过vuex的action，
** 2017/10/23
*** 我们最开始写程序时，喜欢将数据与代码写在一起，后来渐渐发现数据总是要改，查起来不方便，就将数据转移到了函数头中，这样稍微好了一些，然而还是不彻底，再后来就有了config，config实际上是数据与代码分离的一种非常常见的处理方式。
*** this实际上就是一个隐性的参数，跟普通的函数参数没有什么不同。我们可以使用call/apply传入this，正如我们可以使用括号参数传入其他参数一样。
*** 单元测试：
	1. 目标————测试重要的、含有复杂逻辑的函数
	2. 如何写测试？
	   1. 最好写测试的部分————工具函数
	   2. 类方法测试
		  1) mock this，配合参数输入，断言输出。
		  2) 使用call/apply
	   3. VUE组件测试
		  - 找输入输出，输入props/computed,输出组件对象，然后断言组件对象的属性，调用方法结果（vue是可以使用组件对象直接获取状态，调用方法的，这大大方便了测试）
		  - 使用了store的组件
	   4. vuex测试
		  - getters(虚拟state，断言返回值)
		  - mutations(虚拟state，断言state)
		  - actions(虚拟store，使用sinon mock commit，查看参数是否正确)
	3. 写可测试的代码
	   - 多写、多抽纯函数
	   - 少用全局变量
	   - 参数化依赖
	   - 将函数导出
	   - 将IO与逻辑分离
	4. 工程实践
	   + run dev的同时run unit
	   + 修改test/index.js，只跑自己页面的测试用例
	   + vuex,导出getters/mutations/actions,不建议导出state，但可以复制出state的数据然后修改,一个模块可能会有多个state
	   + vue组件，将复杂逻辑抽到各自的工具函数中去
	5. 测试驱动开发
	   + TDD vs BDD
		 - http://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/
		 - 一个描述的是函数是否功能正确，一个描述的是系统应该是什么样子，防止跑偏。
	   + 优势
		 - 先描述系统，然后进行开发，强制开发人员做一些前期的设计
		 - 鼓励代码解耦，先分模块开发，然后拼装在一起
		 - 提高代码质量，不好写测试的地方通常写的都不好，要么做了太多的事要么依赖太多
		 - 避免了补测试需要根据方法实现补case测不出问题的尴尬问题
	   + 方法
		 - 先写测试，让它失败
		 - 实现功能，通过测试
		 - 先写架子，再写细节
*** 其实es6的模块化、vue的component、vuex的state,getters,mutations,actions，对测试都是非常友好的，他们暴露出了大量的API，测试起来就变得非常容易了。
*** js's decorators是一种使得我们可以在函数调用前和调用后做一些额外的工作的方法，我们可以在函数调用前获取函数的名字、对象、访问权限，借此做一些额外的事情，实现比如日志打印、mixin/
*** UI是store的一种副作用更新，我们只要操作store，UI就应该跟着自动变化。这也许就是vuex的核心思想。
** 2017/10/24
*** js借助于函数参数的解构赋值与默认值实现了key arguments,极大强化了js参数的表现力。
*** 代码调整建议：
	1. html,不要使用component is，使用组件的名字
	2. 文件，出了common的放在外面以外，其他的放在模块内，比如const util
	3. 图标，统一使用iconfont
	4. 组件，规范化、可用性，梳理
	5. 样式，bem ?
*** tv components?
	- card
	- button
	- grid/layout
	- input
	- slider
	- menu
	- pagination
	- autocomplete
	- modal
	- notification
	- loading
	- table
** 2017/10/25
*** TIPS 关于算法？不要抱怨业务中没有算法，很多时候这是因为你没有将数据与代码拆分开，只要他们拆开了，算法就出现了。同时，也好测试了。
*** css规范化：
	+ ant design
	  + 将样式放到组件内，放到内部单独的style文件夹中
	  + 使用less语法
	+ element
	  + 将样式放到外部单独的文件夹，便于定制主题
	  + 使用postcss-salad的定制语法
	+ iview
	  + 将样式放到外部单独的文件夹，便于主题定制
	  + 使用less语法
*** TODO 看下element-ui中的跑马灯，始终居中是怎么实现的。
*** TIPS 今后实现组件的四大参考————ant design of react、bootstrap、iview、elementUI.
** 2017/10/26
*** TIPS 关于js的sort，首先它是会改变数组值的，这不符合函数式编程的要求，其次，当它返回true时，默认情况下它返回的结果是从小到大排列的，这更符合实际需求，因为我们不知道最大的会有多大。另外，如果你不想改变原始数据的话，你可以使用ramda的sort或者使用结构先将数据复制一份出来。
*** 关于es6的解构，它是一种介于浅拷贝与深拷贝之间的拷贝，对于基础数据类型它会深拷贝，对于引用数据类型，它会浅拷贝，这样就既保证了效率，又保证了可用性，但这也容易让人掉进坑里，需要小心。
*** TIPS 为什么javascript可以统治互联网？javascript虽然本身不是一门好的语言，但是它具有上手极其容易，极高的开发效率，受众广从而易推广的特点。这就使得任何想法，想要找一个工具简单实现的时候，使用它是最简单快捷，而且不愁推广的。比如语言标准、模块化与组件化、数据驱动UI等，最初都是用js才得以普及的，虽然这些东西渐渐被typescript、java等在重写，但你依然不能否认js的初期价值。
** 2017/10/27
*** 领取黄金
	+ 以前的领取黄金作废，使用新接口
	+ 手机端页面是否需要实现
	+ 
** 2017/10/31
*** jsonp原理：请求回来一个函数调用，调用本地函数取得数据。
*** 对每一个partical调用canvas api不可取，应该将canvas存起来在最后调用一次canvas api就行了。
*** h5动画性能优化都是相同的，都是将循环中做的工作移出来。
** 2017/11/01
*** TODO 使用链表提升动画性能。
*** 关于测试流程的规范？如何提高测试效率，避免账号与退单问题。
*** TODO 待办：
	+ pingback/cashier.js getFrVersion.
	+ qr-code易用性问题，size与width.
	+ sleep提取问题.
	+ buyPackageListen提取.
*** TODO 领取成功后我需要变成购买页逻辑，这部分怎么重用？我是否可以把购买与轮询合二为一呢？肯定是可以的。
** 2017/11/02
*** 实际上写代码是个非常精细的活，需要各种地方仔细的考量，如果一开始就扎进各种细节里，写代码是非常费劲的。用户初期只需要写很少的代码来验证它们的想法就可以了，对正确性要求不高，这也就是js这么流行的原因，但改做的事情还是要做的，后期正确性会变得越来越重要，js省略的这些还是要还回来的，这时用户就会选择其他的语言。
*** TODO 函数参数管理
*** 关于requestAnimationFrame的callback的时间单位，它显示的是从页面创建（tab页，不是整个浏览器）到当前的时间，单位是毫秒，是个浮点数。
** 2017/11/03
*** 关于css动画与js动画，css动画只能改变元素的样式，不能操作dom，而js则不止可以改变样式，还可以操作dom。
*** 关于联调，如何加快联调进度的讨论。
	+ 介绍下你们那边的测试环境，你们通常是怎样测试的。
	+ 测试环境的数据从哪来，与线上环境数据的差别，哪些数据是共享的，哪些是独立的。
	+ 哪些业务使用测试环境测，哪些使用线上环境测。
	+ 如何避免测试通过了到线上依然出现的问题。这些问题主要出现有哪些地方。
	+ 你们希望我们这边怎样来测试，哪些数据是我们可以自己弄的，哪些是需要你们协助的。
	+ 如何避免需要你们那边手动改数据库进行测试的问题，我们如何自己手动跑通整个测试的数据流。
	+ 关于业务组，你们会会调用passport、订单组的接口外，还会调用哪些部门的接口，如何保证需要跨多个业务部分进行联调时使用的数据一致。
*** aaa:
	+ 没有绑定手机号
	+ 没有会员赠送、一种、两种的展示
	+ 
