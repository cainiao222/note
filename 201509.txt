* 2015/09
** 2015/09/01
*** 什么是抽象？抽象就是等价代换，这其中变量起着核心的作用。
** 2015/09/02
*** 总有一个地方是需要经常被改动的，代码结构清晰有个非常简单的原则，尽量将这部分代码集中到一起，这样改起来就会比较容易。
** 2015/09/06
*** TODO 面向对象编程强行将函数封装在对象里，然后将函数也称之为对象。这种方式是不正确的，导致了JAVA需要很多多余的设计模式来模拟函数，是不正确的。
*** 软件为什么要安装，很多时候也许是为了软件重用，有很多库是可以被公用的，软件安装可以提前检测这些东西，如果有就不需要额外安装，这在网络不发达，传输复杂的时代也许还是有点用的，但现在网络发达，很多时候不需要安装的软件比需要安装的软件好用的多。
** 2015/09/07
*** 在编程的道路上，也许我真的是入了邪教了。我总是试图发现一些编程方面的奇特技巧，拒绝相信任何被明令禁止的东西，总是喜欢用自己的理解去判断这些东西，觉得有时候有道理的我就是喜欢用，即使别人不理解也无所谓。
** 2015/09/08
*** 作为一个公司的领导者，非常重要的一点就是要避免公司内部互相打架，竞争，内耗，这种无意义的消耗并不产生实际价值，是非常要不得的。
*** 什么时候需要接口，只有需要被频繁更换的零件才需要接口，在编程时要特别留意这些东西在哪里。
*** MapManager数据组织：
1、按照楼层以及类别将数据分散在很多文件中（楼层数*类别数*3）。
2、按照建筑编号（4位）、类别（2位）、楼层号（3位）、设施号（5位）为所有对象编号。
（为每个设施编个号的意义在于可以直接根据设施编号找到对象的设施）。

** 2015/09/10
*** 与代码相比，模型更重要，代码只是模型的表述而已。模型对了，整体的框架就对了，至于具体哪一块的细节可以先随便点，以后再去整。
*** 到底什么是继承？可以用来做什么？继承配合虚函数可以用来确定算法的大致骨架，成为一种算法模式的抽象。这是非常重要的一点好处。也是c++即使虚函数表会降低性能也要这么干的原因。
*** 什么是抽象？抽象就是固定不变，抽出变化，也就是一个分类的过程。
*** 如果在写代码的过程中发现哪一部分在一个地方修改不方便，比较好的方法就是将这一部分抽象到参数部分，从外部输入，这样就可以将这一部分暴露给外部，实现分类也就是抽象。
*** 使用函数参数抽象是一种如此重要的抽象方法，必须熟练运用。
*** c#标准的命名风格并不喜欢写m_前缀，这样造成一个缺陷就是我无法区分成员变量与局部变量，比较好的做法是如果是成员变量的话，加上this指针，这样就区分开了。
*** 尽可能的将耗时操作放到其他的线程里面，在主线程里面只要发送个状态就好了，就是每当主线程要进行耗时操作时，不直接进行操作，而是直接发送一个操作的信号给其他线程，由其他线程来完成这个操作，这种异步的操作才是编写好多线程程序的关键。
*** 将start与stop的代码倒着写总是没有问题的，很多时候都不用仔细考虑会不会有冲突，直接就这样写基本都不会有问题。
*** 其实start、stop是一个关于连续的、自动运转的过程的一个强有力的抽象。而enum、filter、map、accmulate是一个关于信息筛选的一个强有力的抽象。
*** 优美的接口比优美的实现更加重要，所以不要过于在于类成员变量是否有多余的，如果是为了类接口的合理性而放弃成员的合理性是可以接受的。
*** 函数实际上非常类似于电路，我想要抽象某个部分，就将这一部分转化为参数，留下一个输入口，然后别人调用这个函数的时候将具体的参数值传递进来，将数据通过导线传给函数，这样就完成了函数调用。
*** 友元类的本质是什么？友元类的本质是一个放权的过程。在某个类里面声明了友元类，就是把这个类的所有权限放给它的友元类。不同于继承只开放部分权限，它是开放所有权限的，可以用来。。。
** 2015/09/11
*** 如果是在同一个线程里面使用同一个变量，变量使用的先后顺序实际上已经隐式的规定了，这种情况是不需要加锁的。但是如果是在并发执行的几个线程里面使用同一个变量，先后顺序就无法预计了，这种情况下就需要加锁了。
*** 函数的参数以及返回值都是导线，参数是传入导线，返回值是传出导线，函数体是电路，这个电路将参数进行一定的处理再通过返回值传出，这样就完成了一个功能。
*** 在提取代码到函数时，如果发现某个变量没有，有两种方法，一种是增加参数，在参数中把这个变量传进来，还有一种方法是把这个参数放到函数外面，然后用返回值把已有的代码传出去。这两种方法都能实现未知变量对接，可以根据具体情况合理选用。
*** 面向对象有一个非常重要的好处就是非常便于开关式操作，需要增加个功能，就将这个功能全部添加在一个新的类中，然后当你不需要这个功能的时候直接注掉这个类对象就行了，什么都不会留下，尽最大限度的保护了原有代码，防止引入新的BUG。
*** 当函数的参数过长时，可以将函数的参数拆分在几个函数里面分别传入，这样可以将参数进行下简单的分类，总比很长的参数要好，但这样拆分会产生一个问题就是函数的调用是有顺序的，不能乱序调用。
*** 使用一个管理类来管理所有的API，然后在这个类里面将API分成几个对象，然后每个对象实现部分API，最后只需要给别人提供这一个管理类就可以了，这是一种API的书写技巧。
*** vs无法直接查看map的值，这点可以说是vs的一个缺陷，无意中造成了我们无法在调试器中实时观测到容器的数据，以致于不喜欢用map。但这个缺陷是很容易弥补的，直接打出来就好了。
*** 树形结构数据组织，每次只读取可以满足实际需求的最高层级，如果需要继续往下读就到相应节点继续往下，保证内存中的数据始终处于较小的规模。
** 2015/09/12
*** 嵌套结构必然离不开递归，同时只要看到嵌套，应该第一反应出来可以用递归来求值。
*** 为什么判断如此重要，以至于要被划分到六个基本的运算符里面去？因为有了判断，我们能够将不同的情况当做同样的情况来一起处理。现实世界本来就是复杂的，有各种乱七八糟的情况，而有了判断，我们能够将这些情况一起处理，这是一种非常霸道强力的抽象手段，为我们提供了一种将实际上两种不同的东西抽象在一起的手段，在程序设计的前期还是非常简单好用的。
*** 过度使用判断抽象出来的程序是缺乏层次的，代码粗糙的，在程序设计的前期也许能够为我们带来方便，但随着后期抽象的进行，应该对这种抽象继续进行精化，产生更多的层次，使得代码更加的易于理解。
*** TODO 自己实现一个求值器，然后逐渐往里面添加新特性。
*** 其实currying是一个非常容易实现的东西，它仅仅只是将参数很多的list变了一个形式而已，并没有什么难的。
*** 要将currying加入到求值器中很容易，只需要在需要currying的地方做个判断，如果需要currying，就先把表达式currying一下了再进行求值。其实也就是加入了一个条件判断而已。所以说判断就是最简单粗暴的抽象方式。
*** 如何给求值器加入嵌套求值？实际上也非常简单，也是加入一个判断。当给参数求值的时候先判断这个参数是否还需要求值（也就是是否已经是atom了），如果是直接返回参数值，如果不是就再调用计算函数一次，这样就可以实现嵌套求值了。
*** 今天是有重大意义的一天，今天我不借助于其他的参考资料完成了简单的计算器，然后给这个计算机加入了嵌套求值、currying这些非常牛逼的特性。
*** c#property的本质是通过成员访问函数。没有property时我们只能通过函数来访问成员，不能通过成员来访问函数，但是有了property，我们就可以通过成员来访问函数，变成双向访问了。
** 2015/09/14
*** 使用额外的函数参数来对遍历列表的结果进行收集，这是一种强有力的编程技巧。可以用来记录函数的执行结果，对执行结果进行二次处理。具体的应用有尾递归优化、continuatiaon等，非常有用，必须熟练掌握。
*** 使用额外的函数参数相当于定义了一个变量，可以用来存储很多东西。
*** 理解代码有好几个维度，使用类函数来理解是一个维度，还有一个维度是使用类成员来理解。
*** 作为一个高端的程序开发人员，在看到一个新的类型的时候想到的不应该是显示生活中的这个东西，而应该是一团数据。
*** 继承应该说是最简单的表现层次的方法，基类里面不要掺杂具体业务相关的东西，只需要包含一些数据相关的东西就好了，然后再继承它，掺杂进一些业务相关的东西，这样写出的代码会非常容易复用。
** 2015/09/15
*** lisp解决问题很多时候采用的是线性逼近的方法，由尚未解决的问题逐渐向已经解决的问题靠拢，只要解决了基本的问题，再通过一定的规则逼近尚未解决的问题，就解决了这个问题。使用这种方法的关键在于发现基本问题的解以及想出由这个基本问题向所要解决问题靠拢的规则，这个规则一般用递归来表述。
*** 使用编码的最大好处是可以根据统一的号码来管理所有的对象。
*** ID实际上就是变量，当添加了ID以后要想改变ID的行为只需要价格对应关系就可以了，这才是ID最大的作用。
*** 到底什么是变量？变量实际上就是对应关系，使用一个东西来代表另一个东西，在使用的时候通过查表来寻找这个东西所代表的值，这样通过改变对应关系就能够在不改变代码的情况下改变程序的行为。
*** 如果层次关系不一样，那么复用起来就会非常困难。
** 2015/09/16
*** 额外的参数并不影响计算，要是影响接口，可以通过再用其他参数较少的函数来调用的方式来解决。所以，随便去加参数吧，没什么大的坏处。
*** TODO 可否设计这样一个菜单？这个菜单就是一个list，往里面随便添加一项立马就能在实际的菜单上看到这个东西并且可以点击跳转到提前设置的函数里面，真正实现所见即所得。
*** 关于代码的复用，越是底层的东西越容易复用，越是到上层的业务，复用起来越困难。
*** 代码的重复并不是在任何情况下都不可容忍，如果两个东西实际上做的事并不完全相同，只是碰巧代码暂时一样，那么这种情况是不需要把这种重复的代码给提取出来的，这是被允许的，因为两个都要变化，后期可能就不是完全一样的了。
*** 继承的本质是什么？是根据实际的需求不断的提炼出来的代码的层次结构，把与业务相关的代码往下面提，与逻辑相关的往上面提，这样就会非常好复用。
*** 怎样在完全不改变已有代码的情况下拓展功能，做到代码的水平拓展，这是一个非常有学问的事。要做到这一点，继承是不能被忽略的最强大的工具，没有之一。
*** OgrDataProvider类中掺杂进了具体的代码逻辑，主要就是楼层这个概念，导致并不能完全复用，需要修改。这点要引起注意，以后一定要将具体的业务与逻辑分开，业务代码不能掺杂进逻辑里面，否则会给复用带来麻烦。
*** 由类提炼出接口这是一个进步，因为这意味着代码的可复用性又上了一个台阶。
*** 继承就像一条贼船，上去了就再也下不来了。这是建立在代码设计不合理的情况下的，如果代码设计合理，各个API所在的层级得当的话，继承确实是非常强大的代码复用手段。随便加个public、private就可以确定哪个函数可以用，哪个函数不可用，这么方便的开关到哪里去找。
*** 为什么当初设计接口时只将函数定义进去，而不将类成员给定义进去，因为对于同一个东西往往动作都是那么几个，是不变的，但是为了实现这几个动作可以采用的数据表示却是可以千变万化的，一旦放开这个东西，接口的纯度就会大大降低，极大影响抽象的质量。
*** 冯磊此人函数类抽象、接口倒是写的比较清晰，就是不注意函数参数。
*** 函数参数与返回值不能瞎用，通过函数名只能让人猜到这个函数大概是干啥的，但想要进一步的了解这个函数的功能还需要配合函数参数以及函数返回值，如果这两个东西也清晰的话就可以不用看函数体直接猜出这个函数是干啥的。只有所谓的IPO都清晰明确的情况下这个函数理解起来才会简单易懂，而不用看具体的函数代码。
*** 你做过哪些比较有意思的事？
	1、我是用emacs的，这里这样说并不是想引起emacs与vi的战争，我想说的是我使用emacs然后自己写了个做笔记的插件。用什么编辑器并不重要，重要的是使用编辑器的方法，很多人喜欢用一个编辑器，然后为了一个很小的功能去网上漫天寻找插件，其实有时候还不如自己去写一个。
	2、我也使用云盘，但不同意很多人用云盘只是将自己的一些照片、数据资料等传上去，我将自己经常使用的软件也给传上去了（当然只能是绿色版的软件），这样我就可以在不同的地方同步基本一致的办公环境（我只是用同步版的云盘）。
	3、我启动程序的方式也跟一般人不一样，我自己建立了一个文件夹，然后把这个文件夹加到了环境变量里面，把程序的快捷方式丢在这个文件夹里面。这样我就能通过win+R，然后输入快捷方式的名称快速启动程序了。当然，这个文件夹是放在云盘里面的，这样我不管在哪启动程序的方式都是一样的。
*** 要想看明白一个函数是干什么的，搞清楚这个函数的输入输出非常关键。因为有指针、引用这东西，所以很多时候并不是函数参数就是输入，返回值就是输出。先弄清楚了输入与输出以后，看一个函数到底是干什么的就非常容易了。
*** 最近一年来，我写的代码还是挺多的，多数代码都是我自己思考，自己摸索着写出来的，当然也踩了不少坑。这种方式有利于培养对各种代码写法优劣判断的感知，培养对代码的深入思考，是非常好的。现在这种感知已经基本形成，是时候看别人的代码了。看别人的代码特别是优秀的代码有利于代码的广度。两者结合才是最正确的学习方式。
** 2015/09/17
*** 使用额外的数据参数，所能做的也就收集收集计算结果了。可是，使用额外的过程参数，所能做的事就多了，这种方式能够极大的增强函数的表达能力，必须好好研究掌握。
*** 如果在在递归的外面还有其他计算，而这个递归又必须计算到最基本的情况了才能计算出结果，那么就必然会产生一个先变长后变短的递归链条，这种计算方式会大大消耗时间和空间，要注意避免，比较好的方式是将这种方式变为等长的迭代计算，这种变换一般要使用额外的参数来记录计算的中间结果。
*** 实际上使用额外的计算参数有可能会产生出一个逆递归的过程，递归在逐渐变得简单，可是这个参数却可能逐渐变得复杂，越来越接近于最终的结果，在最后递归完成时，就可能在这个参数上得出了最终的计算结果。最典型的例子就是迭代计算阶乘。
*** 如果说数据参数是写lisp程序的核心的话，那么函数参数就是lisp程序的精髓。
*** 使用额外的数据变量作为参数可以完成数据收集，使用额外的过程变量作为参数可以完成在任意时刻中断处理，真正达到图灵的表达能力。
*** 实现复杂抽象的秘诀就是不断给已经能够解决的简单问题进行命名抽象，然后忽略细节。直接用这个新抽象去解决问题。
*** 判断是一个对问题进行水平切分的手段，通过切分，能够将几种不同的情况放在一起来处理。
*** lisp的let实际上做的就是一个额外的变量绑定，这个绑定的值在递归的时候都是不会变化的，所以let的引入首先并不需要对以前的程序做多大的修改，然后使用let表示法比用lambda来表示要简单清晰。
*** 只需要简简单单的将let当做一个外部变量就可以了，然后let的引入实际上使用的还是lambda,所以并不会引入副作用。
*** let虽然能处理一些简单的参数传递问题，却不能依据参数对计算过程做点处理，所以只有在简单的需要值的情况下才使用let，复杂的还是用lambda好用。
*** c++中，函数的访问属性与函数是否是虚函数是成员函数的两类属性，它们之间的关系可不是一个简单的问题。这两个维度的函数划分其实是非常不好的，容易打架的。比如如果父类的某个函数是public的虚函数，但你在子类实现的时候将这个函数重新实现了一遍，但是你将这个函数的访问属性改成了public的，最后让父类指针指向子类对象调用这个函数，依然访问的是子类的对象。这就是打架了。
*** c++代码在编译的过程中必定有一个为所有类生成虚函数表的过程，每个类都有一个或几个自己的虚函数表，当new这个类的时候，编译器要为new出的对象声明一片空间来指向这个类的虚函数表们，当具体的调用发生的时候，编译器会根据具体的指针类型去寻找对应的虚函数表，找到对应的函数进行调用。哇，这是多么复杂的计算模型啊。
*** c++语言恐怖的编译器哦，它在背后做了太多的事情，你永远也弄不懂。
*** c/c++语言之所以获得这么大的应用完全是因为这两货接近硬件，基本就是冯诺依曼结构的配套翻版，能够最好的运行在这种结构的机器上，不需要多余的东西，能够获得最大的效率。但其实冯诺依曼结构的计算机已经是比较落后、比较简单原始的计算架构了，迫切的需要一种新的计算机架构来继续推动程序的发展。
*** 冯诺依曼体系计算机的最大瓶颈就在于就在于总线，多个元器件之间采用一条共享的总线来进行通信，必然会造成总线拥堵不堪，突破这一瓶颈的新思路就在于设计互不干扰的多条总线，现在被提的很多的量子计算机与神经网络计算机都是在突破这一瓶颈上所作出的一点尝试。
*** 其实进一步来说，冯诺依曼架构的瓶颈在于并行。只有一个计算器、控制器、存储器的结构即使这个单元再牛逼，也无法为越来越复杂的业务提供最快速的响应，未来还是应该把更多的精力放在多个单元的协调工作上，无论是量子计算机、神经网络、还是云计算都是试图突破这一瓶颈上做的一些尝试。
*** TODO c++的编译器其实总是知道指针的类型，这个只要使用typeid(p).name()就可以获取；它也知道除了void指针以外的指针所指向的实际数据的类型，这个只需要使用typeid(*p).name()就可以获取。有了这两个类型，实际上可以做很多的事。
*** 当使用一个void指针来接收其他类型的对象时，表面上看这个对象的类型信息好像丢失了，但实际上，你依然可以用typeid(*p).name()来取到实际指向对象的类型。所以，c++编译器实际上是知道指针的类型与指针所指向的对象的类型的，只不过对于void指针，你需要随便进行一下类型转换，然后再使用typeid(*p).name()去获取实际的类型。
*** 使用状态来先标记耗时操作，到点击执行的时候才将操作执行，可以将同步的操作变为异步的操作，提升程序响应速度，改善用户体验。这是一个非常实用的技巧。
*** 阿炳的二胡其实已经被神化了，也许他真的是拉的很好，但任何一件东西一旦缺乏了变化，那么这个东西就离死不远了。二胡如果只有那一个调调的，那么它注定是不能长久的。
** 2015/09/19
*** 函数调用总是可以变成let形式的，let列表实际上就是一个函数调用，实际上let只是做了一个函数调用的参数移位而已。
*** elisp并不能直接把函数丢在list最前面实现求值，求值要使用(funcall fn args)这种形式，这是由于elisp的求值模型决定的。
*** TODO boost的any、utility好好研究。
*** 研究智能指针的实现，我们不应该仅仅局限在使用层次上，要看到它其实是一种用来抽象开始代码与结束代码的工具。如果你有一个函数开始的代码与结束的代码基本不变，总是中间的代码在变，那么你完全可以使用智能指针的方式将前面的代码与后面的代码抽象到一个对象里面去。
*** 站在抽象的角度来理解语言是一个非常好的维度，无论是变量、函数、条件判断、作用域、函数库、继承、封装、虚函数、访问属性等等等等，实际上都只是一个用来抽象的工具而已。一门好的语言总是应该把心思花在它所提供的抽象计算模型上，而不应该是指望使用各种奇淫巧计去对这门语言的缺陷进行修修补补。
*** 其实我完全可以设计出一个比冯磊说设计的接口更加优秀的接口。
*** 使用shared_ptr来传递大对象，修改对象的值，防止大对象的拷贝开销。这种技巧要掌握。
** 2015/09/20
*** 其实if的本质是分类，将我们要解决的问题由无序变为有序，以便于处理。每一种分类方式都不可能完全对，这不要紧，可以通过后期的再分类来修正我们的问题模型。牛逼的分类方式能够用最少的情况囊括所有的情况，做到问题模型的最简化。
*** 既然if的本质是分类，那么必然会有一个与之相反的本质为合并的东西，这种东西就是变量，有函数变量与数据变量两种情况。
** 2015/09/21
*** 冯磊说提供的抽象是把所有的点线面、楼层、商铺当成同样的东西――――feature。这样就能用相同的读取方法读写所有的对象，但这种方法能够避免针对不同的shp要使用不同的读写类，缺陷就是这个读取的方法要处理很复杂的情况，提高了复杂度。
*** 一个良好的数据管理接口需要提供读数据、写数据、查找数据、修改数据的能力。在实现之一目标的过程中，我们需要对接口进行良好的抽象，提供简单易懂的操作模型。
*** 如何建模？建模的过程中应该把握好分寸，把哪些概念暴露给外部，这是一个非常值得思考的问题，如果把所有的细节都暴露出去，必然造成难学难用，封装也失去了意义。应该站在用户的角度把那些比较简单，可以看得到的概念暴露出来就可以了。就比如在步导采集的项目中，我们对用户公开了――――点图层、线图层、面图层、图幅选择框、底图这些概念，隐藏了――――所有点线面都是Feature、使用拷贝来创建FeatureDefn，这种折衷就是我们在提供简单抽象模型上所做出的努力。
*** 冯磊在实现简单模型的目标上做出了很多努力，得到了一些东西，同时也放弃了一些东西，这些放弃的东西很重要的一点就是重复代码，在他写的代码里面有很多的重复代码。这种放弃带来的好处是――――函数相对较少，比较容易理解。但重复代码过多了，也不好说这种折衷是值得呢，还是不值得。
*** 什么是数据字典？数据字典实际上就是语义模型，就这么简单。之所以它要提供各个名词的解释，因为这就是我们的语义模型，是需要提供给外部知道的东西。
*** 什么是类？类是一个容器，可以将其他的几个类封装在一起，然后隐藏这些类的部分细节，给外部提供更加简单的接口。
*** TODO 也许到我分享的时候我的分享主题会是――――抽象。
*** 无法做到写一个函数测一个函数，这是静态编译型语言的一个缺点。
*** 什么叫做人工智能？人工智能并不是说在设备上装一个传感器，然后在手机上装个app来控制就叫人工智能了。人工智能指的是能够提前感知外界的信息并进行分析然后对信息作出反应，这才叫人工智能。前面所介绍的人工智能只是完成了第一步，并没有做到第二步与第三步，所以并不叫人工智能。它只完成了I，并没有完成P与O，还得依靠人工来完成，这种人工智能就非常傻了。其实我们平时所写出的程序其本质上也是对输入进行处理输出，应该也可以算作是人工智能了，当然，智能程度的高低就依赖于处理信息的效率与质量了，只要是高校与高质量的，那么一样是很牛逼的人工智能。
** 2015/09/22
*** 在使用cond来进行抽象的时候，要注意抽象的顺序，把简单的、不用递归的情况写在前面，把复杂的需要递归的情况写在后面，如果要cond有几层，多数情况下将这几层的条件合并，写成一层会容易理解些。将简单的情况写在前面不止是出于理解的需要，还有优化性能的需要，将耗时操作放在后面，可以减少这些代码调用的可能性。
*** 友元类是什么？友元类实际上就是一个开关，就是有时候当你实现一个类时，你可能想使用另一个类的某些无法访问的函数，也即你想完全掌控另一个类，这个时候你就需要在另一个类里面添加这个类为它的友元类，这样就相当于添加了一个例外，将另一个类的所有权限完全放给了这个类，同时对另一个类也不需要做过多的修改，随时可以改回去。
*** 尽可能的拓展新的代码，而不是修改已有的代码，即使修改也要把破坏程度降到最低，这才是正确的写代码之道。
*** 何为标准？标准就是针对各家乱七八糟的规范所作出的一个折衷，所以标准必然是非常保守的，只保留基本定义的，所以标准有个非常重要的作用就是可以用来在不同的规范之间进行转换，只要都遵守了共同的标准，那么互相装换、协同工作起来将会轻而易举。
*** 其实接口也是一个标准，是工具的设计方与使用方说明好的一个共同协议，有了这个共同的协议，这两方就能一起协同，共同工作了。
*** 缓存实际上也就是一个if分支罢了，写在获取函数的前面，逻辑是如果缓存变量已缓存，那么直接读，否则从其他的地方读，然后将读取状态置为已读。
*** 理解GDAL库有一个非常关键的概念OGRFeature。GDAL库所作出的最精髓的抽象就在这了。一切地理对象，不管是点线还是面，都是这种类型的对象，所有的数据都存储在它里面。它主要有两个部分：Field以及Geometry，分别存储对象的属性数据以及空间数据。然后其他所有的东西都是直接或间接的处理这两个类的数据，只要掌握了这两个类其他的类只要翻翻文档就可以轻松掌握了。
*** struct给予了我们一种方式来解释一片内存数据的值，而union允许我们以几种不同的方式来解释一片内存数据的值，前者是横向的，后者是纵向的。它们两者配合起来使用可以让我们最快的取出一片数据的各个部分的各种意义的值。
*** 如果一个函数在返回的时候崩溃，那么十有八九是函数里面的某个对象的析构函数出了问题。这种情况下简单的排查方法就是一个对象一个对象的注释掉。
** 2015/09/23
*** 互联网这东西，看似极大的丰富了信息来源的渠道，但实际上也有一个非常隐晦的缺陷――――使我们接收信息的来源和渠道，越来越趋同，没有你知道而其他人不知道的信息。信息的扁平化严重，信息的分享、观点的发布都异常的容易，使得创新的成本不断下跌。我们在本质上，已经很难和别人保持太大的不同。
*** TODO 冯磊接口的设计有很多值得借鉴的地方，但也有不少地方不够合理，我是否需要重新设计？
	首先需要重新设计的就是ShpProvider的接口部分，有很多参数的设计不够合理，存在不少不必要的、容易引起歧义的、重复的、诡异的参数，需要重新设计。
	然后是DataManager部分，DataManager不应该是将所有的函数重新转接实现一次，而应该只包含Provider，然后给用户获取Provider的操作，然后再通过Provider去实现具体的功能。
*** 类是什么？类其实就是一个容器，你可以在里面装东西，数据也好，函数也行，然后这个容器本身也可以装其他容器或是被其他容器装。通过一层一层的叠加渐渐的将东西的条例给理出来了，然后别人就可以比较简单方便的取用容器里面的东西了。
*** 模型有多重要？只要定义好了模型，实现起来将非常的容易。
*** 将一堆函数组织起来完成一个复杂的操作，不可避免会有很多多余的操作，优秀的库就是有这种能力将多余重复的操作降到最低。
*** 重要的数据不要出现两份，这是一个重要的设计原则。
*** 如果一个函数库比较小，一般直接通过bool返回值标识函数调用是成功还是失败就可以了，如果函数库比较复杂，就用一个枚举值标识错误的类型，这是非常常见的用法。
*** GDAL坑死人的API，Open一个DataSource的时候必须额外添加一个true参数才能修改这个DataSource的数据，否则这个DataSource的数据将是只读的，这倒不算什么，关键是这种错误的报错非常不直观，让人难以想到。
** 2015/09/24
*** 我为什么使用安卓而不用ios？因为我是一个开发人员，我喜欢折腾我的数据。我喜欢用这个应用下载的东西用另一个东西去打开，去编辑，而ios在这方面做的很差。我个人使用终端有个不可忽略的重要习惯就是同步，我希望我能随时随地修改我的数据，一端修改，多端同步。我既然已经在除了ios的其他平台(windows、Android)上轻松做到了这一点，我何必去整个很困难的ios去自寻烦恼呢。
*** 为什么我还是需要一个比较好用的手机？因为手机就是一个小型的移动终端，可以帮助我用来处理我的数据，它跟电脑实际上是一样的。那么与我需要一个强悍的电脑用来高效工作一样，手机依然也得跟上去。
*** 给耗时操作添加一个状态变量来进行缓存。如果数据以缓存，直接取，没有才进行操作。如果耗时太长，还要将操作拆分成几次，分次缓存。这就是所谓的lazy evaluation。是非常重要的编程技巧，能够大大改善用户体验。
*** 实际上类成员就是一个缓存，如果你觉得某个东西要经常从磁盘取比较麻烦的话，比较好的方法就是将这个东西做成类成员，只有在没有数据的时候才去从磁盘去取，否则直接返回就行了。
*** 写工具与写函数库的区别在于，写工具代码你可以随便写，不用考虑哪部分代码放在哪个地方会比较合适，但写函数库要格外注意这点，要考虑到各种可能的调用情况，合理安排代码，避免代码重复调用，兼顾效率、可用性、可维护性等各方面的事情。
*** 我藏不住秘密，也藏不住忧伤，正如我藏不住爱你的喜悦，藏不住分离时的彷徨。我就是这样坦然，你舍得伤，就伤。
*** 函数库就像是一个有n个开口的水槽，所有的开口并排着，你无法确定别人先调用那个函数，所以通常的，在调用每个函数之前你需要先检测下调用这个函数的条件是否满足，如果不满足，需要返回错误，这是很多重复代码出现的根本原因，这些是避不了的。
*** 效率与通用性是冲突的，你如果想效率高，需要针对具体的业务定制存储、逻辑，这样效率肯定高，但也失去了通用性；如果你想可复用，那么就必须设计出共通的模式，不可能针对哪一个做出专门的设计，这样效率自然不会很好。一般情况下，通用性大于效率，是需要被重点考量的对象，由此丧失一些效率是可以被接受的。
*** 设计函数API时，一个很重要的设计原则就是考虑通用性，如果你设计出了一个函数只有在非常极端的情况下才会被调用，那么这个API的设计是失败的。
*** protected属性的设计目的，就是为了继承，只有在继承的条件下，protected才表现出于private不同的特征。所以，如果你觉得一个类不会有子类来继承它，直接将所有的protected函数写成私有的就好了。
** 2015/09/25
*** 对于文本编辑器，有一个被很多人忽略了的信息来源是文本本身。当我们对文本编辑器进行抽象时，我们总是假定我们所编辑的文本可以是任何东西，我们需要对这种未知的东西进行抽象，进行各种常用的操作。这样设计出来的东西虽然能够对无意义的文本进行各种处理，但有意的忽略掉文本内容的方式实际上使得我们失去了一个非常重要的信息来源，使得我们的在编辑某些具有特定意义的文本（比如代码）的时候，无法继续提升编辑器的智能化水平。
*** IDE与文本编辑器不同的地方就在于IDE可以针对所输入的内容进行解析，使得它能理解出更多的东西，更好的堆我们的代码进行调整。在IDE看来，代码是语法树，我们能够对其中的各种语法元素，比如变量、函数、类等进行各种操作，而在文本编辑器看来，代码就是一堆无意义的字符，显然前者能够表现出更高程度的智能，更加的好用。
*** 其实文本编辑器也是可以参照着IDE来完成自我进化的，这种文本编辑器叫――――结构化编辑器。这种编辑器能够理解各种结构化的文本内容，把它解析固定的结构，针对这种结构进行处理，从而提升编辑器的智能，这是一个很好的编辑器进化方向。
*** 我为什么不需要印象笔记？因为如下原因：
	1、我并不需要整个大段大段的摘抄，我觉得这样得来的东西依然是别人的，不是自己的。何况一篇很长的文章通常只能在某一个或几个方面给我一点启发，让我写点感想，我并不需要那么长的一整篇文章。如果有时候真的觉得某些句子写的好，直接复制那几句话就行了。
	2、关于图的问题。图相比于文字太过显眼，如果我引入图的话是否会让我无法专注于文字本身呢？这个问题我还没有答案，也许有天我会加入图片支持吧。
	3、关于为啥不使用现成的工具而要自己写。其实我并不是完全自己写啊，我只是基于emacs的org-mode然后在上面做了非常少量的改装而已。为何不使用印象笔记，因为印象笔记我完全没有拓展能力，如果我觉得某些地方不合我意的话我就只能期待新版本，这相比于自己拓展当然也就差了点。
*** 代码只是文本，而文本并不是代码本身。――――王垠《谈Parser》
*** 代码实际上就是一个字符串，一种对程序的编码格式而已，与ZIP、JPEG一样，我们需要先对它进行解码Parsing，也就是Parser干的事。――――王垠《谈Parser》
*** AST数据结构其实才是程序本身，而程序的文本只是这种数据结构的一种编码形式。――――王垠《谈Parser》
*** 我们为什么要进行解码？因为计算机存储用的结构与使用这个东西所使用的结构是不一样的。
*** 数据结构是一个非常重要的东西，很多重要功能的实现实际上是依托于数据所提供的信息的，如果数据结构设计得差，无法提供相应的数据或是提供数据所需要的开销太大，那么功能的实现也就无从说起了。
*** 关于数据结构，很多人容易陷入的一个误区就是以为数组、链表、队列、树、图这些就是数据结构了。实际上真正的数据结构绝对不是这些，它是针对一类问题说设计出的一整个数据模型，需要使用那些信息，这些信息怎么组织，丢在哪几个类里面，哪里使用数组，哪里使用列表，哪里使用映射等等，这些才是数据结构，其实叫数据模型更准确一些。
*** 上：金麟岂是池中物，一遇风云便化龙。
	下：九霄龙吟惊天变，风云际会浅水游。
	横批：成也风云，败也风云
*** 代码的行数越少，出错的几率就越小，这句话实际上不够准确。正确的说法是不可靠的代码行数越少，出错的几率越小。这实际上是鼓励我们使用函数库，不在无关紧要的地方下功夫去写代码，直接调用别人写好的库，这样能较少不可靠的代码，这样出错的几率以及出错以后差错都会变得容易很多。
*** 智能，是所有产品的发展趋势，手机也不例外。
** 2015/09/26
*** 让身体走上良性循环。
*** 中国象棋与宫廷权谋。
