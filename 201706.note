* 2017/06
** 2017/06/05
*** apache rewrite url能够将对一个地址的访问映射到另一个地址，借此可以实现隐藏服务器目录结构、服务器本地模拟等目的。
*** TIPS media query需要写在下面，如果写在上面，由于css是从上往下解释执行的，上面的样式尽管生效了，但马上又会被下面的样式覆盖掉，从而造成没有生效的错觉。另外，它的width指的是layout viewport的width，也就是逻辑像素，并不是物理像素，若想针对物理像素设置样式，请使用device-width。
*** TIPS 关于css样式书写，按照如下顺序从上到下分组：定位、盒模型、内部样式。这样，主体按照从外到内的样式进行布局，整体组织才能比较简单。
*** TODO 关于type为text/html的script标签说明————
	+ 首先，它里面是一段html，
*** tmodjs,模板外置解决方法，它的思想是将模板单独拎出来写成一个函数，然后外界只需要传入数据，就能拼出最终的模板了，不失为一种很轻量级的解决方案。
*** 模板的本质实际上就是一个函数，将数据传递进去，然后就可以生成最后的html。
*** tmodjs确实是一种非常简单的语法，它就是简单的使用双括号扩充了两种语法：
	1. {{var}}
	   变量语法
	2. {{fn args1 | args 2 |...}}
	   函数语法，可以传参，使用|分隔，可以自定义函数，内置函数就这么几个：
	   1. {{if rest}}
	   2. {{each rest}}
	   3. {{include rest}}
	   4. {{fn rest}}
	以上基本就是tmodjs的全部了，没有什么特殊的。
** 2017/06/06
*** data class现在的编程语言喜欢搞这个，但这个东西实际上就是scheme里面的define-struct.
*** TODO 如果全用函数式编程，条件分支怎么表达？
*** TODO 如何处理几个函数调用之后的依赖？
*** 为什么要用vuejs，实际上用的是它的双向绑定，使用它来实现数据的自动化联动，如果数据项都基本没有，那么用又有什么意义呢？
*** 在vue的模板中，我们可以在子组件中使用slot指明一个位置给父组件传递内容，通过name父组件可以将模板传递给子组件的不同部分，实现模板分发，这在编写容器组件时非常方便。在vue中，我们通过props传递数据，通过slot传递模板，
*** IMPORTANT 作用域插槽是一种非常特殊的插槽，它区别于普通的slot的地方在于普通的slot没法在模板中间包含其他的数据，但如果加上作用域插槽，我们就可以做到这一点了，它所做的事情不止是替换子组件中的模板，还能根据子组件指明的数据重新求值，是一种更加高级的slot。
*** Vue 组件的 API 来自三部分 - props, events 和 slots ：
    1. Props 允许外部环境传递数据给组件，它传递的是数据
	2. Slots 允许外部环境传递模板给组件，它传递的是模板
	3. Events 允许组件传递数据给外部环境，触发外部环境的副作用，它传递的是成果数据
*** IMPORTANT slot是vue特有的概念，可以说是vue最大的革新了，它的主要作用是实现模板复用，使用它来写容器组件将十分方便，是vue里面非常重要的一部分。
*** kebab-case ，camelCase ，或 TitleCase，重建的命名方法也就这几种了。
*** 实际上sourcemap的原理非常简单，无非是在页面打开的时候同时开一个ftp服务器给chrome，让chrome控制台可以读取本地文件系统中的文件就可以了，所以，不管什么打包工具，想要支持sourcemap都是非常简单的。
*** browserify与webpack一样，都可以用来打包，不同的是webpack是专为打包而设计的，可以打包各种文件，包括css、图片、jsx等，而broserify最初目的只是让我们在浏览器端可以想服务器端一样写js代码，它只可以打包js，如果想打包其他文件需要配合其他插件。webpack吸收了broserify的部分思想，同时比broserify更加的强大易用。更详细的这两者的比较参见这里：
	http://blog.namangoel.com/browserify-vs-webpack-js-drama
*** TIPS webstrom的两个快键键：
	Ctrl+Shift+Up move statement up
	Ctrl+Shift+Down move statement down
	可以上下移动整个方法与属性，用于调整函数顺序还是非常好用的。
*** TIPS cookie与session都是用来弥补http无状态协议缺陷的，使用它们我们能够进行一些持久化状态判断，比如用户信息、购物车等，还是挺有用的东西。
*** 组件化这个东西对于css而言，如果没有变量，基本没法玩，因为组件的参数没法应用于css，无法针对特定的参数调整状态，在样式这一块就会非常受限。
*** 关于css的模块化，如果暂不想用webpack、broserify这些东西，可以直接使用less，这样直接就模块化了。
*** less是一门极其简单的编程语言，它只是在传统css的基础上引入了变量与函数(mixin)而已，连循环这种简单构造都没有，可以说是非常简单了，顶多有个条件（when/and）,比大多数的模板还要简单，如果这么简单都学不会的话，那就不要编程了。
*** TODO 注意background-size的cover与contain。
*** gulp通过gulp.src(...).pipe(gulp.dest(...))来完成一个路径中的文件来映射到另一个路径中的文件，在映射的过程中，我们能够指定各种处理，这就是gulp的核心原理。当然，还有个gulp.watch（...），实际上就是一个高级版本的gulp.src（...），每当src中的文件发生变化的时候自动跑一下脚本。
*** 使用gulp的各种插件可以轻松的对文件夹下的文件进行各种操作，比如：
	1. gulp-concat（文件夹下文件连接）
	2. gulp-merge（文件合并）
	3. gulp-rename（文件重命名）
	4. gulp-uglify(文件压缩混淆)
	非常方便。
** 2017/06/07
*** IMPORTANT broserify也许是最简单的给前端添加require函数的方法了，使用它可以配合gulp可以非常方便的将js以及它所依赖的js文件打包在一起，提供给浏览器调用。我们只需要安装gulp、gulp-browserify，然后写一个task，指定入口与出口，就可以了，非常简单，代码如下：
	var gulp = require('gulp');
	var browserify = require('gulp-browserify');

	gulp.task('hehe',function () {
        return gulp.src('./tmp3/aaa.js')
            .pipe(browserify())
            .pipe(gulp.dest('./dist'))
	});
	gulp.task('default',['hehe']);
*** IMPORTANT 模块与组件乃至服务的关系：
	1. 模块专注于页面区域，组件专注于可复用。
	2. 模块封装的是业务逻辑，组件封装的是展示逻辑，与业务无关，而且只有与业务无关才可以实现可复用，掺杂进很多具体业务逻辑的组件必然是很难被复用的。
	3. 模块使用组件来完成业务逻辑，组件给模块提供服务，相当于一个UI的工具库。模块实际上是一个容器，它用来存放组件与业务逻辑。实际上业务逻辑也是有一定的可复用性的，它也应该放到一个公共库中去，这就是服务服务，可以看成是业务逻辑的工具库。到了这一层，模块应该尽量制作一些路由分发之类的工作，具体的工作尽量交给下层去完成。
*** TIPS 在node中stdout就是一个使用fs.createWriteStream(...)创建出来的流，我们完全可以自己创建文件流来将stdout中的内容写入到文件中。
*** IMPORTANT 需要注意，gulp中使用的pipe方法是node的Stream自带的方法，并不是gulp自己的方法，只要是流就会有这个方法。
*** gulp中，vinyl是一个通用的文件与文件夹封装器，它一般用来创建一个通用的文件流(包括文件夹)。
*** precss实际上就是一个less/sass/stylus，可能语法细节有差异，不过差别不大。
*** less中的extend有什么作用呢？它是更高级的mixin，用于继承某个基础样式同时避免直接复制，它不需要像mixin一样写一个函数，直接就可以将一个已有选择器的样式搬过来同时避免复制。
*** TODO 数据可视化非常有用，特别是某些领域，比如算法可视化、依赖关系可视化、树数据结构可视化等。
*** TIPS MaDGe，js依赖可视化工具，能够生成js依赖关系树并配合graphviz图形化显示，非常好用。如果得到一个文件的依赖文件的话也简单，使用Madge使用的库————dependency-tree就可以了，它可以直接打印出某个js文件所依赖文件的全路径，然后你就可以用来做自己想干的事情了。
*** IMPORTANT 流是编程中一个极其重要的概念，不知可以用于常见的IO领域，比如文件读写，还可以用在很多其他的地方，比如gulp的核心、Observable的核心都是流。因为流代表了一种更加通用的模式（异步的Monad），数据一点一点过来，被封装成一个个对象，流过一个个函数，通过这种统一的流程处理，这一模型可以用在编程的方方面面。
*** TODO Mobx
*** IMPORTANT 原生的JSON对象远比我们预想的要强大，它不止能够用来在对象与字符串间相互转换，还能遍历这个对象，实现对象的查找替换，实现这一技巧的关键就在于JSON.stringify/JSON.parse这两个函数的第二个参数上，这是一个回调参数，我们可以在这里实现对象树遍历。这才是这两个方法更加广阔的意义。
