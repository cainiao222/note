* 2017/06
** 2017/06/01
*** Glue是一个比较高层的框架，着力于解决重用性问题。它将页面逻辑纵向拆分为三块————组件、行为与服务，每一块都尽量避免混入其他块的逻辑，使得可复用性大大提高。
	1. 使用组件（实际是模块）来表示页面上的一块区域，着力于抽象一些显示方面的逻辑。通过gule.define定义，使用postMessage将组建的数据传出，在需要的地方使用onMessage接收。
	2. 组件中可能有很多重复的交互，使用行为来对这些交互进行打包，使得可以很容易的被集成进组件。通过gule.createBehavior来定义。
	3. 使用服务来进行数据共享，比如共享数据、工具函数等。通过gule.createService来定义。
*** Glue优势：
	1. 高复用性。通过对组件进行UI拆分、交互拆分，交互处理拆分，使得组件能够轻松的组合与重用。
	2. 松耦合。通过将依赖转移到统一的glue对象上，避免了模块间、服务间的直接依赖，降低了耦合，提高了重用性。
*** Glue的缺陷：
	1. 没有html模板，无法自定义标签，仅仅通过html在写复杂交互的时候回导致需要大量的js代码做辅助。
	2. 没有双向绑定，需要开发人员手动添加事件监听与处理，写大量的重复代码。
	3. 直接操作DOM，性能很可能有问题。
	4. 配套资源缺乏，比如数据管理、组件库、路由等。
*** Vue是一个混合型的框架。它参照了很多框架，比如：
	1. 定义新标签实现模块化是参照web组件规范。
	2. 指令、过滤器、父子组件消息传递、Watch是参照angular。
	3. 计算属性是参照Mobx。
*** Vue缺陷：
	1. 缺乏高层的代码结构定义。
	2. 缺乏功能拆分指导，模块化受影响。
*** 有几对非常类似且有效的编程技巧。
	1. 尽量避免相互依赖，应该使用统一的依赖中心来管理依赖，这样相互依赖才会被降到最低。比如事件系统、requirejs/seajs/webpack的依赖管理，甚至是函数式编程。
	2. 不要直接修改状态，要通过统一的入口来管理状态，只有这样状态才是可追溯与维护的。比如Redux、Flux、Mobx等。
*** IMPORTANT 业务逻辑是编程过程中最难被重用的部分，在编程时要尽可能的减少这一部分的代码，只有这样才能尽最大限度的提高代码的可重用性。
*** TIPS 在页面使用meta name="viewport"标签可以防止在移动端页面内容被缩放，需要注意。
*** css的1px并不一定是设备上的一像素，它有可能代表着几个像素。换句话说，css中的像素代表的是独立像素，而设备上的像素是物理像素，他们之间是存在着一个比例的，这个比例叫做devicePixelRatio（有些许兼容性问题）。分辨率越大，css中1px代表的物理像素就会越多，devicePixelRatio的值也越大，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。
** 2017/06/02
*** PC转移动学习路径：
	1. viewport，分为三种：
	   1. visual viewport，屏幕视口，给用户看的视口。（大概400px宽）
	   2. layout viewport，布局视口，给浏览器进行布局排版的视口，用户在屏幕视口中查看。（大概980px宽）
	   3. ideal viewport，完美视口，将屏幕视口与布局视口的宽度设为一致的视口，这样就不会有滚动条了。设置了完美视口之后，浏览器就能根据屏幕视口进行布局了。需要注意的是，即使设置成了完美视口，如果视口中某个元素的宽度超出了视口宽度，滚动条依然会出现。（设置后大概400px宽）
	   4. 一个html页面中，如果不显式设置viewport，那么移动端的浏览器会使用layout viewport进行布局，也就是大概980px宽度，这样页面会被缩小很多，看起来很费劲，但换行基本上还是保留原有的，用户需要通过缩放才能看清页面的内容。显式设置后，页面使用visual layout进行重新布局，元素会变成正常大小，但是由于屏幕缩小了很多，换行问题会非常严重，需要重新调整。
	2. 像素，分为物理像素与逻辑像素，物理像素是实际设备的像素，逻辑像素是为了兼容旧页面而虚拟出来的像素，这两者存在一个比例关系，devicePixelRatio。
	3. em与rem。这两个单位都是相对于文字大小的单位，能够实现不同文字使用不同宽度的自适应布局。区别在于em是相对于元素本身的字体大小，更便于模块化；而rem是相对于根html元素的大小，不用考虑继承关系，计算起来更加简单。如何选用呢？很简单，设置文字大小时使用rem，设置其他的比如margin/padding/border这些用em。
	4. media query，一般写在页面顶部，里面的设置也不多，一般也就设置下字体大小而已。
*** em与rem都是相对于文字大小的单位，随着移动端的流行，这两个单位越来越火了，为什么呢？在传统的PC端，像素是不变的，1个物理像素就是一个屏幕像素，不管什么显示器都是一样。但移动端不是，移动端物理像素千变万化，由此带来的dpr经常变，厂商们先是使用viewport来做自适应，但不好用，因为不统一。迫切需要一个统一的单位来做到这一点，也就是文字大小，这就是em与rem得以流行起来的根本。
*** keyframes实际上是最初级的的css变量定义方案，通过@keyframes定义一个变量，然后在animation属性中直接使用，就实现了css动画，非常简单。
*** 如何实现FFI呢？很简单，将函数调用序列化，定义一个通用的格式，然后在两边提供服务解析字符串调用本端的函数再调用另一端的服务把数据传回。
*** 关联数据与衍生数据。在编程的过程中广泛存在，需要一个通用的模式来实现这一关系，它就是vue里面的计算属性。
*** vue与react数据流对比。对于数据传入，两者使用的方式都是props，但数据传出方式不一样，react使用的是props回调，而vue使用的是基于$emit/$on的事件系统，这种方式引入了额外的API，实际上不如react的优雅。
*** TIPS 关于vue中计算属性与$watch方法的对比，计算属性的目标是计算出一个衍生属性的值，它是可以在模板中直接使用的，而$watch只是为了执行一些联动，它的目的并不在于算出一个属性，而在于联动，比如改变页面的样式，做http请求等。
*** TIPS vuex实际上可以理解为redux在vue上的类似实现。用统一的store来管理公用状态，来实现回滚，状态可追溯等。
*** react并不是双向数据绑定的，它是单向数据流的（可以说是单向数据绑定）。数据通过props流动到组件内部，当用户操作导致状态变化，它需要用户自己主动去调用render（setState会自动调用render）才能实现UI更新，尽管这样要求用户多写了点代码，但也带来了很强的灵活性，比如允许我们修改很多状态之后一次实现UI更新，提高效率。
*** 其实从头实现一个程序框架这些东西并不复杂，只要定义好规则就可以了，实现起来没有多费劲。
*** 为什么现在像react/redux/mobx这种状态管理框架越来越火了？因为前端的业务越来越复杂，而对付复杂的唯一手段就是拆分，组件化就是这么来的，但是页面拆分之后，状态也跟着一起拆分了，而状态与状态之间往往是有联系的，如果状态分散在到处，想要维持它们的一致性就会非常困难，要在修改状态的过程中插入一些钩子也不行了，于是就出现了各种状态管理库来统一管理这些状态。
*** 实际上状态管理的本质是封装，是一种高层的抽象，通过它，我们能够对状态管理规范化，管理化，维护起来也就更加的轻松。
*** 关于状态管理，最重要的一句话是————单向数据流，这一思想来自于Flux。为什么要单向？因为只有这样，才能避免互相依赖。
*** 不要直接修改状态，要修改数据，然后基于数据重新渲染得到新的状态。
*** redux数据流：
	store.dispatch(action) -> reducer(state, action) -> store.getState()
** 2017/06/05
*** apache rewrite url能够将对一个地址的访问映射到另一个地址，借此可以实现隐藏服务器目录结构、服务器本地模拟等目的。
*** TIPS media query需要写在下面，如果写在上面，由于css是从上往下解释执行的，上面的样式尽管生效了，但马上又会被下面的样式覆盖掉，从而造成没有生效的错觉。另外，它的width指的是layout viewport的width，也就是逻辑像素，并不是物理像素，若想针对物理像素设置样式，请使用device-width。
*** TIPS 关于css样式书写，按照如下顺序从上到下分组：定位、盒模型、内部样式。这样，主体按照从外到内的样式进行布局，整体组织才能比较简单。
*** TODO 关于type为text/html的script标签说明————
	+ 首先，它里面是一段html，
*** tmodjs,模板外置解决方法，它的思想是将模板单独拎出来写成一个函数，然后外界只需要传入数据，就能拼出最终的模板了，不失为一种很轻量级的解决方案。
*** 模板的本质实际上就是一个函数，将数据传递进去，然后就可以生成最后的html。
*** tmodjs确实是一种非常简单的语法，它就是简单的使用双括号扩充了两种语法：
	1. {{var}}
	   变量语法
	2. {{fn args1 | args 2 |...}}
	   函数语法，可以传参，使用|分隔，可以自定义函数，内置函数就这么几个：
	   1. {{if rest}}
	   2. {{each rest}}
	   3. {{include rest}}
	   4. {{fn rest}}
	以上基本就是tmodjs的全部了，没有什么特殊的。
** 2017/06/06
*** data class现在的编程语言喜欢搞这个，但这个东西实际上就是scheme里面的define-struct.
*** TODO 如果全用函数式编程，条件分支怎么表达？
*** TODO 如何处理几个函数调用之后的依赖？
*** 为什么要用vuejs，实际上用的是它的双向绑定，使用它来实现数据的自动化联动，如果数据项都基本没有，那么用又有什么意义呢？
*** 在vue的模板中，我们可以在子组件中使用slot指明一个位置给父组件传递内容，通过name父组件可以将模板传递给子组件的不同部分，实现模板分发，这在编写容器组件时非常方便。在vue中，我们通过props传递数据，通过slot传递模板，
*** IMPORTANT 作用域插槽是一种非常特殊的插槽，它区别于普通的slot的地方在于普通的slot没法在模板中间包含其他的数据，但如果加上作用域插槽，我们就可以做到这一点了，它所做的事情不止是替换子组件中的模板，还能根据子组件指明的数据重新求值，是一种更加高级的slot。
*** Vue 组件的 API 来自三部分 - props, events 和 slots ：
    1. Props 允许外部环境传递数据给组件，它传递的是数据
	2. Slots 允许外部环境传递模板给组件，它传递的是模板
	3. Events 允许组件传递数据给外部环境，触发外部环境的副作用，它传递的是成果数据
*** IMPORTANT slot是vue特有的概念，可以说是vue最大的革新了，它的主要作用是实现模板复用，使用它来写容器组件将十分方便，是vue里面非常重要的一部分。
*** kebab-case ，camelCase ，或 TitleCase，重建的命名方法也就这几种了。
*** 实际上sourcemap的原理非常简单，无非是在页面打开的时候同时开一个ftp服务器给chrome，让chrome控制台可以读取本地文件系统中的文件就可以了，所以，不管什么打包工具，想要支持sourcemap都是非常简单的。
*** browserify与webpack一样，都可以用来打包，不同的是webpack是专为打包而设计的，可以打包各种文件，包括css、图片、jsx等，而broserify最初目的只是让我们在浏览器端可以想服务器端一样写js代码，它只可以打包js，如果想打包其他文件需要配合其他插件。webpack吸收了broserify的部分思想，同时比broserify更加的强大易用。更详细的这两者的比较参见这里：
	http://blog.namangoel.com/browserify-vs-webpack-js-drama
*** TIPS webstrom的两个快键键：
	Ctrl+Shift+Up move statement up
	Ctrl+Shift+Down move statement down
	可以上下移动整个方法与属性，用于调整函数顺序还是非常好用的。
*** TIPS cookie与session都是用来弥补http无状态协议缺陷的，使用它们我们能够进行一些持久化状态判断，比如用户信息、购物车等，还是挺有用的东西。
*** 组件化这个东西对于css而言，如果没有变量，基本没法玩，因为组件的参数没法应用于css，无法针对特定的参数调整状态，在样式这一块就会非常受限。
*** 关于css的模块化，如果暂不想用webpack、broserify这些东西，可以直接使用less，这样直接就模块化了。
*** less是一门极其简单的编程语言，它只是在传统css的基础上引入了变量与函数(mixin)而已，连循环这种简单构造都没有，可以说是非常简单了，顶多有个条件（when/and）,比大多数的模板还要简单，如果这么简单都学不会的话，那就不要编程了。
*** TODO 注意background-size的cover与contain。
*** gulp通过gulp.src(...).pipe(gulp.dest(...))来完成一个路径中的文件来映射到另一个路径中的文件，在映射的过程中，我们能够指定各种处理，这就是gulp的核心原理。当然，还有个gulp.watch（...），实际上就是一个高级版本的gulp.src（...），每当src中的文件发生变化的时候自动跑一下脚本。
*** 使用gulp的各种插件可以轻松的对文件夹下的文件进行各种操作，比如：
	1. gulp-concat（文件夹下文件连接）
	2. gulp-merge（文件合并）
	3. gulp-rename（文件重命名）
	4. gulp-uglify(文件压缩混淆)
	非常方便。
** 2017/06/07
*** IMPORTANT broserify也许是最简单的给前端添加require函数的方法了，使用它可以配合gulp可以非常方便的将js以及它所依赖的js文件打包在一起，提供给浏览器调用。我们只需要安装gulp、gulp-browserify，然后写一个task，指定入口与出口，就可以了，非常简单，代码如下：
	var gulp = require('gulp');
	var browserify = require('gulp-browserify');

	gulp.task('hehe',function () {
        return gulp.src('./tmp3/aaa.js')
            .pipe(browserify())
            .pipe(gulp.dest('./dist'))
	});
	gulp.task('default',['hehe']);
*** IMPORTANT 模块与组件乃至服务的关系：
	1. 模块专注于页面区域，组件专注于可复用。
	2. 模块封装的是业务逻辑，组件封装的是展示逻辑，与业务无关，而且只有与业务无关才可以实现可复用，掺杂进很多具体业务逻辑的组件必然是很难被复用的。
	3. 模块使用组件来完成业务逻辑，组件给模块提供服务，相当于一个UI的工具库。模块实际上是一个容器，它用来存放组件与业务逻辑。实际上业务逻辑也是有一定的可复用性的，它也应该放到一个公共库中去，这就是服务服务，可以看成是业务逻辑的工具库。到了这一层，模块应该尽量制作一些路由分发之类的工作，具体的工作尽量交给下层去完成。
*** TIPS 在node中stdout就是一个使用fs.createWriteStream(...)创建出来的流，我们完全可以自己创建文件流来将stdout中的内容写入到文件中。
*** IMPORTANT 需要注意，gulp中使用的pipe方法是node的Stream自带的方法，并不是gulp自己的方法，只要是流就会有这个方法。
*** gulp中，vinyl是一个通用的文件与文件夹封装器，它一般用来创建一个通用的文件流(包括文件夹)。
*** precss实际上就是一个less/sass/stylus，可能语法细节有差异，不过差别不大。
*** less中的extend有什么作用呢？它是更高级的mixin，用于继承某个基础样式同时避免直接复制，它不需要像mixin一样写一个函数，直接就可以将一个已有选择器的样式搬过来同时避免复制。
*** TODO 数据可视化非常有用，特别是某些领域，比如算法可视化、依赖关系可视化、树数据结构可视化等。
*** TIPS MaDGe，js依赖可视化工具，能够生成js依赖关系树并配合graphviz图形化显示，非常好用。如果得到一个文件的依赖文件的话也简单，使用Madge使用的库————dependency-tree就可以了，它可以直接打印出某个js文件所依赖文件的全路径，然后你就可以用来做自己想干的事情了。
*** IMPORTANT 流是编程中一个极其重要的概念，不知可以用于常见的IO领域，比如文件读写，还可以用在很多其他的地方，比如gulp的核心、Observable的核心都是流。因为流代表了一种更加通用的模式（异步的Monad），数据一点一点过来，被封装成一个个对象，流过一个个函数，通过这种统一的流程处理，这一模型可以用在编程的方方面面。
*** TODO Mobx
*** IMPORTANT 原生的JSON对象远比我们预想的要强大，它不止能够用来在对象与字符串间相互转换，还能遍历这个对象，实现对象的查找替换，实现这一技巧的关键就在于JSON.stringify/JSON.parse这两个函数的第二个参数上，这是一个回调参数，我们可以在这里实现对象树遍历。这才是这两个方法更加广阔的意义。
** 2017/06/08
*** TIPS hosts文件实际上是一个本地的DNS,系统先通过它进行域名解析得到IP,找不到再去远程的DNS服务器去找，也可以说是一个钩子，我们通过它能够干很多事，比如请求截获，请求统计，甚至请求伪造，都是非常容易的。另外，不止电脑上可以设置host，通过路由器也可以设置，而且更有用。比如你可以将服务器上的代码放到本地的另一台机器，并在这台机器上启动服务，然后将远程服务器域名映射到这台机器，这样你就可以直接在这台机器上调试远程代码了。
** 2017/06/09
*** TODO template标签
*** 在vue中，我们使用props来传递数据，使用slot来传递模板。
*** IMPORTANT 关于函数式编程中如何处理状态依赖问题有个简单的解法————不断merge，每个异步操作会引入一定的数据到函数调用链，你需要做的是把新的数据merge进原始数据（不要直接merge，最好merge到新加的字段，便于以后维护），然后继续传递到下一个异步函数，这样后面的函数就总是可以取到之前所有数据，就避免了还需要额外引入全局状态的尴尬。通过这种方式，能够渐渐构建起一颗状态树，维护起来就非常轻松了。
*** TIPS 现在前端各种构建工具大行其道，为什么呢？这些构建工具有什么好处呢？它能使我们超越语法，站在更高的角度思考问题。
*** 绝对不要小看了模板字符串的潜力，模板字符串中的变量不止可以是普通的js变量，还可以是其他的模板变量，这样我们就实现了模板的可嵌套。
