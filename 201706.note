* 2017/06
* 2017/06
** 2017/06/01
*** Glue是一个比较高层的框架，着力于解决重用性问题。它将页面逻辑纵向拆分为三块————组件、行为与服务，每一块都尽量避免混入其他块的逻辑，使得可复用性大大提高。
	1. 使用组件（实际是模块）来表示页面上的一块区域，着力于抽象一些显示方面的逻辑。通过gule.define定义，使用postMessage将组建的数据传出，在需要的地方使用onMessage接收。
	2. 组件中可能有很多重复的交互，使用行为来对这些交互进行打包，使得可以很容易的被集成进组件。通过gule.createBehavior来定义。
	3. 使用服务来进行数据共享，比如共享数据、工具函数等。通过gule.createService来定义。
*** Glue优势：
	1. 高复用性。通过对组件进行UI拆分、交互拆分，交互处理拆分，使得组件能够轻松的组合与重用。
	2. 松耦合。通过将依赖转移到统一的glue对象上，避免了模块间、服务间的直接依赖，降低了耦合，提高了重用性。
*** Glue的缺陷：
	1. 没有html模板，无法自定义标签，仅仅通过html在写复杂交互的时候回导致需要大量的js代码做辅助。
	2. 没有双向绑定，需要开发人员手动添加事件监听与处理，写大量的重复代码。
	3. 直接操作DOM，性能很可能有问题。
	4. 配套资源缺乏，比如数据管理、组件库、路由等。
*** Vue是一个混合型的框架。它参照了很多框架，比如：
	1. 定义新标签实现模块化是参照web组件规范。
	2. 指令、过滤器、父子组件消息传递、Watch是参照angular。
	3. 计算属性是参照Mobx。
*** Vue缺陷：
	1. 缺乏高层的代码结构定义。
	2. 缺乏功能拆分指导，模块化受影响。
*** 有几对非常类似且有效的编程技巧。
	1. 尽量避免相互依赖，应该使用统一的依赖中心来管理依赖，这样相互依赖才会被降到最低。比如事件系统、requirejs/seajs/webpack的依赖管理，甚至是函数式编程。
	2. 不要直接修改状态，要通过统一的入口来管理状态，只有这样状态才是可追溯与维护的。比如Redux、Flux、Mobx等。
*** IMPORTANT 业务逻辑是编程过程中最难被重用的部分，在编程时要尽可能的减少这一部分的代码，只有这样才能尽最大限度的提高代码的可重用性。
*** TIPS 在页面使用meta name="viewport"标签可以防止在移动端页面内容被缩放，需要注意。
*** css的1px并不一定是设备上的一像素，它有可能代表着几个像素。换句话说，css中的像素代表的是独立像素，而设备上的像素是物理像素，他们之间是存在着一个比例的，这个比例叫做devicePixelRatio（有些许兼容性问题）。分辨率越大，css中1px代表的物理像素就会越多，devicePixelRatio的值也越大，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。
** 2017/06/02
*** PC转移动学习路径：
	1. viewport，分为三种：
	   1. visual viewport，屏幕视口，给用户看的视口。（大概400px宽）
	   2. layout viewport，布局视口，给浏览器进行布局排版的视口，用户在屏幕视口中查看。（大概980px宽）
	   3. ideal viewport，完美视口，将屏幕视口与布局视口的宽度设为一致的视口，这样就不会有滚动条了。设置了完美视口之后，浏览器就能根据屏幕视口进行布局了。需要注意的是，即使设置成了完美视口，如果视口中某个元素的宽度超出了视口宽度，滚动条依然会出现。（设置后大概400px宽）
	   4. 一个html页面中，如果不显式设置viewport，那么移动端的浏览器会使用layout viewport进行布局，也就是大概980px宽度，这样页面会被缩小很多，看起来很费劲，但换行基本上还是保留原有的，用户需要通过缩放才能看清页面的内容。显式设置后，页面使用visual layout进行重新布局，元素会变成正常大小，但是由于屏幕缩小了很多，换行问题会非常严重，需要重新调整。
	2. 像素，分为物理像素与逻辑像素，物理像素是实际设备的像素，逻辑像素是为了兼容旧页面而虚拟出来的像素，这两者存在一个比例关系，devicePixelRatio。
	3. em与rem。这两个单位都是相对于文字大小的单位，能够实现不同文字使用不同宽度的自适应布局。区别在于em是相对于元素本身的字体大小，更便于模块化；而rem是相对于根html元素的大小，不用考虑继承关系，计算起来更加简单。如何选用呢？很简单，设置文字大小时使用rem，设置其他的比如margin/padding/border这些用em。
	4. media query，一般写在页面顶部，里面的设置也不多，一般也就设置下字体大小而已。
*** em与rem都是相对于文字大小的单位，随着移动端的流行，这两个单位越来越火了，为什么呢？在传统的PC端，像素是不变的，1个物理像素就是一个屏幕像素，不管什么显示器都是一样。但移动端不是，移动端物理像素千变万化，由此带来的dpr经常变，厂商们先是使用viewport来做自适应，但不好用，因为不统一。迫切需要一个统一的单位来做到这一点，也就是文字大小，这就是em与rem得以流行起来的根本。
*** keyframes实际上是最初级的的css变量定义方案，通过@keyframes定义一个变量，然后在animation属性中直接使用，就实现了css动画，非常简单。
*** 如何实现FFI呢？很简单，将函数调用序列化，定义一个通用的格式，然后在两边提供服务解析字符串调用本端的函数再调用另一端的服务把数据传回。
*** 关联数据与衍生数据。在编程的过程中广泛存在，需要一个通用的模式来实现这一关系，它就是vue里面的计算属性。
*** vue与react数据流对比。对于数据传入，两者使用的方式都是props，但数据传出方式不一样，react使用的是props回调，而vue使用的是基于$emit/$on的事件系统，这种方式引入了额外的API，实际上不如react的优雅。
*** TIPS 关于vue中计算属性与$watch方法的对比，计算属性的目标是计算出一个衍生属性的值，它是可以在模板中直接使用的，而$watch只是为了执行一些联动，它的目的并不在于算出一个属性，而在于联动，比如改变页面的样式，做http请求等。
*** TIPS vuex实际上可以理解为redux在vue上的类似实现。用统一的store来管理公用状态，来实现回滚，状态可追溯等。
*** react并不是双向数据绑定的，它是单向数据流的（可以说是单向数据绑定）。数据通过props流动到组件内部，当用户操作导致状态变化，它需要用户自己主动去调用render（setState会自动调用render）才能实现UI更新，尽管这样要求用户多写了点代码，但也带来了很强的灵活性，比如允许我们修改很多状态之后一次实现UI更新，提高效率。
*** 其实从头实现一个程序框架这些东西并不复杂，只要定义好规则就可以了，实现起来没有多费劲。
*** 为什么现在像react/redux/mobx这种状态管理框架越来越火了？因为前端的业务越来越复杂，而对付复杂的唯一手段就是拆分，组件化就是这么来的，但是页面拆分之后，状态也跟着一起拆分了，而状态与状态之间往往是有联系的，如果状态分散在到处，想要维持它们的一致性就会非常困难，要在修改状态的过程中插入一些钩子也不行了，于是就出现了各种状态管理库来统一管理这些状态。
*** 实际上状态管理的本质是封装，是一种高层的抽象，通过它，我们能够对状态管理规范化，管理化，维护起来也就更加的轻松。
*** 关于状态管理，最重要的一句话是————单向数据流，这一思想来自于Flux。为什么要单向？因为只有这样，才能避免互相依赖。
*** 不要直接修改状态，要修改数据，然后基于数据重新渲染得到新的状态。
*** redux数据流：
	store.dispatch(action) -> reducer(state, action) -> store.getState()
** 2017/06/05
*** apache rewrite url能够将对一个地址的访问映射到另一个地址，借此可以实现隐藏服务器目录结构、服务器本地模拟等目的。
*** TIPS media query需要写在下面，如果写在上面，由于css是从上往下解释执行的，上面的样式尽管生效了，但马上又会被下面的样式覆盖掉，从而造成没有生效的错觉。另外，它的width指的是layout viewport的width，也就是逻辑像素，并不是物理像素，若想针对物理像素设置样式，请使用device-width。
*** TIPS 关于css样式书写，按照如下顺序从上到下分组：定位、盒模型、内部样式。这样，主体按照从外到内的样式进行布局，整体组织才能比较简单。
*** TODO 关于type为text/html的script标签说明————
	+ 首先，它里面是一段html，
*** tmodjs,模板外置解决方法，它的思想是将模板单独拎出来写成一个函数，然后外界只需要传入数据，就能拼出最终的模板了，不失为一种很轻量级的解决方案。
*** 模板的本质实际上就是一个函数，将数据传递进去，然后就可以生成最后的html。
*** tmodjs确实是一种非常简单的语法，它就是简单的使用双括号扩充了两种语法：
	1. {{var}}
	   变量语法
	2. {{fn args1 | args 2 |...}}
	   函数语法，可以传参，使用|分隔，可以自定义函数，内置函数就这么几个：
	   1. {{if rest}}
	   2. {{each rest}}
	   3. {{include rest}}
	   4. {{fn rest}}
	以上基本就是tmodjs的全部了，没有什么特殊的。
** 2017/06/06
*** data class现在的编程语言喜欢搞这个，但这个东西实际上就是scheme里面的define-struct.
*** TODO 如果全用函数式编程，条件分支怎么表达？
*** TODO 如何处理几个函数调用之后的依赖？
*** 为什么要用vuejs，实际上用的是它的双向绑定，使用它来实现数据的自动化联动，如果数据项都基本没有，那么用又有什么意义呢？
*** 在vue的模板中，我们可以在子组件中使用slot指明一个位置给父组件传递内容，通过name父组件可以将模板传递给子组件的不同部分，实现模板分发，这在编写容器组件时非常方便。在vue中，我们通过props传递数据，通过slot传递模板，
*** IMPORTANT 作用域插槽是一种非常特殊的插槽，它区别于普通的slot的地方在于普通的slot没法在模板中间包含其他的数据，但如果加上作用域插槽，我们就可以做到这一点了，它所做的事情不止是替换子组件中的模板，还能根据子组件指明的数据重新求值，是一种更加高级的slot。
*** Vue 组件的 API 来自三部分 - props, events 和 slots ：
    1. Props 允许外部环境传递数据给组件，它传递的是数据
	2. Slots 允许外部环境传递模板给组件，它传递的是模板
	3. Events 允许组件传递数据给外部环境，触发外部环境的副作用，它传递的是成果数据
*** IMPORTANT slot是vue特有的概念，可以说是vue最大的革新了，它的主要作用是实现模板复用，使用它来写容器组件将十分方便，是vue里面非常重要的一部分。
*** kebab-case ，camelCase ，或 TitleCase，重建的命名方法也就这几种了。
*** 实际上sourcemap的原理非常简单，无非是在页面打开的时候同时开一个ftp服务器给chrome，让chrome控制台可以读取本地文件系统中的文件就可以了，所以，不管什么打包工具，想要支持sourcemap都是非常简单的。
*** browserify与webpack一样，都可以用来打包，不同的是webpack是专为打包而设计的，可以打包各种文件，包括css、图片、jsx等，而broserify最初目的只是让我们在浏览器端可以想服务器端一样写js代码，它只可以打包js，如果想打包其他文件需要配合其他插件。webpack吸收了broserify的部分思想，同时比broserify更加的强大易用。更详细的这两者的比较参见这里：
	http://blog.namangoel.com/browserify-vs-webpack-js-drama
*** TIPS webstrom的两个快键键：
	Ctrl+Shift+Up move statement up
	Ctrl+Shift+Down move statement down
	可以上下移动整个方法与属性，用于调整函数顺序还是非常好用的。
*** TIPS cookie与session都是用来弥补http无状态协议缺陷的，使用它们我们能够进行一些持久化状态判断，比如用户信息、购物车等，还是挺有用的东西。
*** 组件化这个东西对于css而言，如果没有变量，基本没法玩，因为组件的参数没法应用于css，无法针对特定的参数调整状态，在样式这一块就会非常受限。
*** 关于css的模块化，如果暂不想用webpack、broserify这些东西，可以直接使用less，这样直接就模块化了。
*** less是一门极其简单的编程语言，它只是在传统css的基础上引入了变量与函数(mixin)而已，连循环这种简单构造都没有，可以说是非常简单了，顶多有个条件（when/and）,比大多数的模板还要简单，如果这么简单都学不会的话，那就不要编程了。
*** TODO 注意background-size的cover与contain。
*** gulp通过gulp.src(...).pipe(gulp.dest(...))来完成一个路径中的文件来映射到另一个路径中的文件，在映射的过程中，我们能够指定各种处理，这就是gulp的核心原理。当然，还有个gulp.watch（...），实际上就是一个高级版本的gulp.src（...），每当src中的文件发生变化的时候自动跑一下脚本。
*** 使用gulp的各种插件可以轻松的对文件夹下的文件进行各种操作，比如：
	1. gulp-concat（文件夹下文件连接）
	2. gulp-merge（文件合并）
	3. gulp-rename（文件重命名）
	4. gulp-uglify(文件压缩混淆)
	非常方便。
** 2017/06/07
*** IMPORTANT broserify也许是最简单的给前端添加require函数的方法了，使用它可以配合gulp可以非常方便的将js以及它所依赖的js文件打包在一起，提供给浏览器调用。我们只需要安装gulp、gulp-browserify，然后写一个task，指定入口与出口，就可以了，非常简单，代码如下：
	var gulp = require('gulp');
	var browserify = require('gulp-browserify');

	gulp.task('hehe',function () {
        return gulp.src('./tmp3/aaa.js')
            .pipe(browserify())
            .pipe(gulp.dest('./dist'))
	});
	gulp.task('default',['hehe']);
*** IMPORTANT 模块与组件乃至服务的关系：
	1. 模块专注于页面区域，组件专注于可复用。
	2. 模块封装的是业务逻辑，组件封装的是展示逻辑，与业务无关，而且只有与业务无关才可以实现可复用，掺杂进很多具体业务逻辑的组件必然是很难被复用的。
	3. 模块使用组件来完成业务逻辑，组件给模块提供服务，相当于一个UI的工具库。模块实际上是一个容器，它用来存放组件与业务逻辑。实际上业务逻辑也是有一定的可复用性的，它也应该放到一个公共库中去，这就是服务服务，可以看成是业务逻辑的工具库。到了这一层，模块应该尽量制作一些路由分发之类的工作，具体的工作尽量交给下层去完成。
*** TIPS 在node中stdout就是一个使用fs.createWriteStream(...)创建出来的流，我们完全可以自己创建文件流来将stdout中的内容写入到文件中。
*** IMPORTANT 需要注意，gulp中使用的pipe方法是node的Stream自带的方法，并不是gulp自己的方法，只要是流就会有这个方法。
*** gulp中，vinyl是一个通用的文件与文件夹封装器，它一般用来创建一个通用的文件流(包括文件夹)。
*** precss实际上就是一个less/sass/stylus，可能语法细节有差异，不过差别不大。
*** less中的extend有什么作用呢？它是更高级的mixin，用于继承某个基础样式同时避免直接复制，它不需要像mixin一样写一个函数，直接就可以将一个已有选择器的样式搬过来同时避免复制。
*** TODO 数据可视化非常有用，特别是某些领域，比如算法可视化、依赖关系可视化、树数据结构可视化等。
*** TIPS MaDGe，js依赖可视化工具，能够生成js依赖关系树并配合graphviz图形化显示，非常好用。如果得到一个文件的依赖文件的话也简单，使用Madge使用的库————dependency-tree就可以了，它可以直接打印出某个js文件所依赖文件的全路径，然后你就可以用来做自己想干的事情了。
*** IMPORTANT 流是编程中一个极其重要的概念，不知可以用于常见的IO领域，比如文件读写，还可以用在很多其他的地方，比如gulp的核心、Observable的核心都是流。因为流代表了一种更加通用的模式（异步的Monad），数据一点一点过来，被封装成一个个对象，流过一个个函数，通过这种统一的流程处理，这一模型可以用在编程的方方面面。
*** TODO Mobx
*** IMPORTANT 原生的JSON对象远比我们预想的要强大，它不止能够用来在对象与字符串间相互转换，还能遍历这个对象，实现对象的查找替换，实现这一技巧的关键就在于JSON.stringify/JSON.parse这两个函数的第二个参数上，这是一个回调参数，我们可以在这里实现对象树遍历。这才是这两个方法更加广阔的意义。
*** TIPS 正则是非常强大的文本处理工具，但也是有限的，它最大的问题在于它是不存储状态的，找到需要处理的文本处理后状态就丢失了，如果想要继续处理又要继续搜索，所以它要配合编程语言来做接下来的事情，但也不是那么方便。它在需要不停的读写文本的情况下处理能力有限，这种情况下我们需要更加强大的处理工具————解释器。通过解释器对文本进行语法分析并将所有的元素记录下来，下次读写时就能直接复用了，大大提升了效率。
** 2017/06/08
*** TIPS hosts文件实际上是一个本地的DNS,系统先通过它进行域名解析得到IP,找不到再去远程的DNS服务器去找，也可以说是一个钩子，我们通过它能够干很多事，比如请求截获，请求统计，甚至请求伪造，都是非常容易的。另外，不止电脑上可以设置host，通过路由器也可以设置，而且更有用。比如你可以将服务器上的代码放到本地的另一台机器，并在这台机器上启动服务，然后将远程服务器域名映射到这台机器，这样你就可以直接在这台机器上调试远程代码了。
*** 互联网是怎样进行DNS解析的呢？实际上这是一个数学问题————有个非常大的集合，集合中的每个元素都有自己的位置，一个元素知道了另一个元素的位置如何尽快的找到这个元素。解决方法也很简单，就是分类再分类，先找到地址所在的大类，然后再找到下一级的小类，再往下一直到具体的地址。到具体的实现上，每个节点只需要知道自己这个类管哪些地址，然后报告是不是在本类里面就好了，并不需要存储所有的数据。
*** 路由器实际上就是一个小电脑，它只提供一个服务————找地址。会有很多的包流过路由器，它只需要判断这个包是不是给它的，是就留下继续处理，并把处理后的包扔出去，不是就直接扔出去，就这么简单。
** 2017/06/09
*** TODO template标签
*** 在vue中，我们使用props来传递数据，使用slot来传递模板。
*** IMPORTANT 关于函数式编程中如何处理状态依赖问题有个简单的解法————不断merge，每个异步操作会引入一定的数据到函数调用链，你需要做的是把新的数据merge进原始数据（不要直接merge，最好merge到新加的字段，便于以后维护），然后继续传递到下一个异步函数，这样后面的函数就总是可以取到之前所有数据，就避免了还需要额外引入全局状态的尴尬。通过这种方式，能够渐渐构建起一颗状态树，维护起来就非常轻松了。
*** TIPS 现在前端各种构建工具大行其道，为什么呢？这些构建工具有什么好处呢？它能使我们超越语法，站在更高的角度思考问题。
*** 绝对不要小看了模板字符串的潜力，模板字符串中的变量不止可以是普通的js变量，还可以是其他的模板变量，这样我们就实现了模板的可嵌套。
** 2017/06/12
*** 常用算法总结：
	1. 分治法，分治法基本就可以理解为递归算法。
	2. 动态规划算法，动态规划算法是一个带有前后依赖关系的分治法，所以它也是一个递归算法。
	3. 贪心算法，贪心算法需要证明，并不一定能得到最优解。
	4. 回溯法，回溯法是一个树形搜索解空间树的通用算法，它一般使用深度优先来进行搜索。
	5. 分支限界法，分支限界法可以理解为更高级的回溯法，它也是树形搜索算法，只不过它使用的是广度优先，可以实现剪枝，及早从已经不符合条件的分支中脱离出来不再搜索。
*** 树形搜索有个固定的模式，如下：
	function treeSearch(arg){
	    if(cond(arg)){
		    return res;
		}
		else{
		    for(let i = 0;i < arr.length;++i){
			    treeSearch(iter(arg));
			}
		}
	}
	解释下，大致就是一个循环里面包一个递归，这样每次递归都将搜索这个层级的所有解，然后一个个处理，这样最后一直判断到所有的层级结束，这样就实现了遍历一棵树。
*** TIPS webpack自己写loader比gulp还要简单，我们可以轻松的自己写一个loader。
*** IMPORTANT js将文件内容拆成一行一行处理：
	source.split(/\r?\n/).forEach(function(line){...}
	瞬间体会到了正则的强大。
*** IMPORTANT build真的能干非常多的事，而且在build期做了运行期就不用做了，效率也能得到保证，而且在build期干能够让我们摆脱语法的束缚，写出我们自己的DSL。比如简体中文转繁体、less转css、table转js对象等。
*** VUE中，我们使用双括号语法绑定内容，使用v-bind绑定属性。
	v-if、v-for都是一个属性，使用它来实现条件与循环。
*** 写带UI的程序与写函数一样，讲究一个熟练，需要长期的联系，才能越来越熟练。写代码最忌讳蒙，蒙着蒙着就蒙对了的写代码态度是非常危险的。
*** IMPORTANT 数据在哪里定义，理想情况下就应该在哪里修改，所以，对于VUE的组件而言，通过props传递进组件的数据，不应该直接在子组件中修改，而应该通过事件传回父组件修改，这样才能实现数据与对数据的管理是在一起的。
** 2017/06/13
*** TODO 前端开发的模式，想写算法一样写模式
*** 对于js代码，我们可以使用函数传参，实现运行时数据绑定；但是对于css，由于css没有函数，所以不能用函数来实现样式数据绑定，这时可以使用js函数操作style对象，从而实现样式的数据绑定。
*** 数组的方法比如map/filter/find/indexOf等不止可以用于基础数据类型，还可以用于引用数据类型，可以说，它们其实是不区分类型的。
*** 数据驱动UI，不要主动去操作UI，应该操作数据，然后数据重新渲染更新UI。
*** UI只是容器，尽量不要操作数据，当有数据修改时，应该上报新的数据，而不是自己直接修改。
*** 实际上webpack所做的事情非常简单，无非是用数组来管理所有依赖，在所有文件外包了一层，然后加了段启动代码，我们自己用gulp就可以轻松实现。
*** 模块加载无非是要解决这样一个问题，保证所依赖的代码在代码运行之前已经被执行并返回执行的结果给代码使用。
*** webpack也许是唯一一个支持各种模块写法、各种文件的打包工具了，使用起来非常简单。
*** 在webpack中，我们可以轻松的写自己的loader做为钩子，在进入其他loader之前或是之后把处理出来的文本进行下续处理。要做到这一点，理解loader的链式调用非常重要。
** 2017/06/14
*** 其实最好的markdown文档是马克飞象的介绍文本，基本上markdown常用的语法上面都包含了，而且可以对照看效果，非常方便。
*** 一个文档中常见的元素其实并没有多少，这些都在markdown中被定义了，主要有：
	1. 树结构（#）
	2. 列表（-）
	3. 公式($或$$)
	4. 表格（|）
	5. Tips（>）
	6. 复选框(- [])
	7. 超链接（[]()）
	8. 粗体、斜体、阴影、脚注(**、*、`、[^])
	9. 代码（```）
	10. 分隔线（------）
	markdown只标注出这些元素，至于元素具体的样式markdown并不关心，这相当于编程中的变量，使得统一调整样式非常方便，不需要程序员来关心。
*** TIPS 马克飞象有这一套非常简单易记的快捷键，虽然与emacs的org-mode相比还差上不少，但已经可以称得上好用了。
*** TODO 什么是context？context是一个对象，表明函数使用到了哪些变量。
** 2017/06/15
*** TODO return这个东西也许是不需要的东西，我们完全可以去掉return使用callback来传递成果数据，这样定义出来的语言写出来的代码会不会更加的整洁？
*** webpack的loader有两种写法，同步写法与异步写法，即使是异步写法，它也会按照loader中指定的顺序从右往左串行执行。
*** 编辑器与IDE最大的差别就在于AST，但是vscode是一个另类，它是带有语法分析的，难能可贵的是它虽然带有语法分析，但依然能保持一个编辑器般大小的体积。它的语法提示功能即使是对比webstrom也是毫不孙色的。另外，它集成git、集成终端、集成调试等等，几乎就是一个开箱即用的IDE了。
*** VUE也有自己的render函数，这个render函数与react的render函数基本上是一样的。Vue的模板实际上是被翻译成了render函数然后渲染出来的。
*** IMPORTANT 不要忽略了const，const能将修改集中在一起，一旦赋值，不允许修改，这不就是最简单的不可变数据吗，函数式编程苦苦追求的东西，实现起来竟然如此简单。
*** 组件的分类：
	1. 接入型container。会跟service、服务器、数据源打交道，会将数据往下传给展示型组件。
	2. 展示型。数据进，dom出。模板写展示型组件更合适，超过JSX。这种组件视图逻辑很简单，但样式可能会有相当的复杂度。
	3. 交互型。比如各类加强版的表单组件，通常强调复用。
	4. 功能型。比如<route-view>、<transition>，作为一种拓展，抽象机制存在。JSX在写功能型组件时是远超模板的。因为它获得了JS完全的自由度。
	   ————Vue作者尤雨溪
*** Higher-Order Components，组件转化props成UI，而高阶组件转化组件成新的组件。
*** 关于交互型组件是这样的，它是事件的抽象，只暴露事件，不加以处理，这样才能在不同的业务逻辑间复用。
** 2017/06/16
*** TIPS 当我们抽函数时，经常碰到这样的一样困境————出错处理，在没有throw/try...catch以前，我们只能通过返回一个错误码的方式，这样在多层嵌套的时候需要一层一层的return，非常麻烦，其实解决这一问题的方法很简单————这种情况使用throw来代替return就可以了，这样就不用一层一层return了。
*** async表明一个函数会返回一个Promise，await等待这个promise resolve了继续往下执行。
*** every page is a class.
*** 模板与jsx最本质的差别在哪里呢？
	1. 模板只有变量，可以将指令看成是函数，但指令写起来比较复杂。
	2. 而JSX就是js，它有js的一切，包括变量、函数、条件、循环等。
** 2017/06/19
*** 打开新页面之后的恢复现场问题是一个很重要的问题，不是那么好解决。比较简单的解决方案是使用多页面，然后通过返回，这样可以借助于浏览器的记忆功能直接返回到原始状态。
*** TIPS h5的transform的scale、skew都是是相对于元素中心的，并不是左上角，而且不管旁边的元素，如果旁边有其他元素，会压盖这个元素，这一默认方式使得card的focus事件实现起来相当容易。
*** TODO 键盘上下左右控制焦点是如何实现的？
*** org-mode：
	1. 插入tips(使用<q tab能够快速插入):
	#+BEGIN_QUOTE
	简单测试
	#+END_QUOTE
	2. 插入代码（使用<s tab快速插入）：
	#+BEGIN_SRC javascript
	function abc(){
       console.log('abc');
    }
	#+END_SRC
** 2017/06/20
*** IMPORTANT 函数（组件也是函数）最大的意义就在于封装，封装的意思是减少入口与出口并提供出来，外界只需要通过入口与出口来与组件进行沟通就行了，并不需要关心函数细节，这极大的简化了开发，是的分工合作成为可能。
	面向对象的三个基本特征————封装，继承与多态中，最重要也是最基础的就是封装，继承与多态都只是一种更好的利用封装的手段，比如继承就是拓展封装，多态就是我们可以把多种状态看成是一个封装。
	不止面向对象，函数式编程的基础也是封装，只不过函数式编程更强调函数的复用而已。
*** 三星项目tab页上下左右键切换原理：
	- 左右切换，左右切换很简单，就是focus上一个下一个tab而已。
	- 上下切换，上下切换稍微复杂点。首先它并没有记忆坐标，它记录的是下标，如果没有已记忆的下标，focus到第一个；如果有，focus到记忆的下标。
*** 三星项目上下左右滚动原理：
	- 
*** TIPS 其实es6有了模板字符串后jsx的作用真的没什么卵用，也就只是效率差别了吧，在复杂情况下，jsx比基于字符串拼接的模板字符串有更好的性能表现，除此之外，像jsx的条件、循环结构等使用模板字符串都可以轻松实现，简单情况下直接使用模板字符串就好了。
*** TODO 如何模块化的进行数据组织？
*** IMPORTANT 组件是什么？不过是一个函数，但又与普通的函数有点差别————它有自己的状态，而且多数组件是异步的，因为用户操作是异步的，一旦涉及到异步就只能通过回调来将数据传出，这也就是为什么react/vue组件都不约而同的选择了使用事件或回调来传出数据的原因。
** 2017/06/21
*** 摘抄：
	1. 常量是什么？实际上就是一个返回固定值的函数，而且无参无外部变量依赖，可以看成是一个纯函数。
	2. 将变量常常量化是函数式编程的一个重要理念，不要修改变量，要返回新的变量。
	3. Immutable做的事实际上就是将变量常量化了！只要优化得当，将变量常量化实际上并不会带来多少内存开销，同时这一方式会带来很多好处，比如测试。
	4. 状态依然是可以使用的，但要将状态限制在足够小的范围内，比如封装在一个函数里，这样这个函数依然是纯的，易于测试的。
	5. 使用函数参数显示的指明依赖要比在直接引用外部作用域中的变量这种隐式依赖要好，函数理应只有一个依赖注入的入口，就是函数参数。隐式引用外部环境中的变量会让程序变得难以理解与测试。
	   ————子回《"函数是一等公民"背后的含义》
*** 关于let与const，应该尽量使用const，如果要修改变量的值，应该生成一个新的变量。
*** 普通标识与样式标识的使用要分清，普通标识用来做标记，表明一个元素是什么，不用来承载样式，也不能用来承载样式，样式标识不一样，它用来承载样式，如果一个元素，你觉得它应该有些样式，那么用样式标识，如果不是，仅仅是标识作用，那么用样式标识。
*** ES5 对象的扩展(Object.preventExtensions)、密封(Object.seal)和冻结(Object.freeze)
