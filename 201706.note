* 2017/06
** 2017/06/01
*** Glue是一个比较高层的框架，着力于解决重用性问题。它将页面逻辑纵向拆分为三块————组件、行为与服务，每一块都尽量避免混入其他块的逻辑，使得可复用性大大提高。
	1. 使用组件（实际是模块）来表示页面上的一块区域，着力于抽象一些显示方面的逻辑。通过gule.define定义，使用postMessage将组建的数据传出，在需要的地方使用onMessage接收。
	2. 组件中可能有很多重复的交互，使用行为来对这些交互进行打包，使得可以很容易的被集成进组件。通过gule.createBehavior来定义。
	3. 使用服务来进行数据共享，比如共享数据、工具函数等。通过gule.createService来定义。
*** Glue优势：
	1. 高复用性。通过对组件进行UI拆分、交互拆分，交互处理拆分，使得组件能够轻松的组合与重用。
	2. 松耦合。通过将依赖转移到统一的glue对象上，避免了模块间、服务间的直接依赖，降低了耦合，提高了重用性。
*** Glue的缺陷：
	1. 没有html模板，无法自定义标签，仅仅通过html在写复杂交互的时候回导致需要大量的js代码做辅助。
	2. 没有双向绑定，需要开发人员手动添加事件监听与处理，写大量的重复代码。
	3. 直接操作DOM，性能很可能有问题。
	4. 配套资源缺乏，比如数据管理、组件库、路由等。
*** Vue是一个混合型的框架。它参照了很多框架，比如：
	1. 定义新标签实现模块化是参照web组件规范。
	2. 指令、过滤器、父子组件消息传递、Watch是参照angular。
	3. 计算属性是参照Mobx。
*** Vue缺陷：
	1. 缺乏高层的代码结构定义。
	2. 缺乏功能拆分指导，模块化受影响。
*** 有几对非常类似且有效的编程技巧。
	1. 尽量避免相互依赖，应该使用统一的依赖中心来管理依赖，这样相互依赖才会被降到最低。比如事件系统、requirejs/seajs/webpack的依赖管理，甚至是函数式编程。
	2. 不要直接修改状态，要通过统一的入口来管理状态，只有这样状态才是可追溯与维护的。比如Redux、Flux、Mobx等。
*** IMPORTANT 业务逻辑是编程过程中最难被重用的部分，在编程时要尽可能的减少这一部分的代码，只有这样才能尽最大限度的提高代码的可重用性。
*** TIPS 在页面使用meta name="viewport"标签可以防止在移动端页面内容被缩放，需要注意。
*** css的1px并不一定是设备上的一像素，它有可能代表着几个像素。换句话说，css中的像素代表的是独立像素，而设备上的像素是物理像素，他们之间是存在着一个比例的，这个比例叫做devicePixelRatio（有些许兼容性问题）。分辨率越大，css中1px代表的物理像素就会越多，devicePixelRatio的值也越大，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。
** 2017/06/02
*** PC转移动学习路径：
	1. viewport，分为三种：
	   1. visual viewport，屏幕视口，给用户看的视口。（大概400px宽）
	   2. layout viewport，布局视口，给浏览器进行布局排版的视口，用户在屏幕视口中查看。（大概980px宽）
	   3. ideal viewport，完美视口，将屏幕视口与布局视口的宽度设为一致的视口，这样就不会有滚动条了。设置了完美视口之后，浏览器就能根据屏幕视口进行布局了。需要注意的是，即使设置成了完美视口，如果视口中某个元素的宽度超出了视口宽度，滚动条依然会出现。（设置后大概400px宽）
	   4. 一个html页面中，如果不显式设置viewport，那么移动端的浏览器会使用layout viewport进行布局，也就是大概980px宽度，这样页面会被缩小很多，看起来很费劲，但换行基本上还是保留原有的，用户需要通过缩放才能看清页面的内容。显式设置后，页面使用visual layout进行重新布局，元素会变成正常大小，但是由于屏幕缩小了很多，换行问题会非常严重，需要重新调整。
	2. 像素，分为物理像素与逻辑像素，物理像素是实际设备的像素，逻辑像素是为了兼容旧页面而虚拟出来的像素，这两者存在一个比例关系，devicePixelRatio。
	3. em与rem。这两个单位都是相对于文字大小的单位，能够实现不同文字使用不同宽度的自适应布局。区别在于em是相对于元素本身的字体大小，更便于模块化；而rem是相对于根html元素的大小，不用考虑继承关系，计算起来更加简单。如何选用呢？很简单，设置文字大小时使用rem，设置其他的比如margin/padding/border这些用em。
	4. media query，一般写在页面顶部，里面的设置也不多，一般也就设置下字体大小而已。
*** em与rem都是相对于文字大小的单位，随着移动端的流行，这两个单位越来越火了，为什么呢？在传统的PC端，像素是不变的，1个物理像素就是一个屏幕像素，不管什么显示器都是一样。但移动端不是，移动端物理像素千变万化，由此带来的dpr经常变，厂商们先是使用viewport来做自适应，但不好用，因为不统一。迫切需要一个统一的单位来做到这一点，也就是文字大小，这就是em与rem得以流行起来的根本。
*** keyframes实际上是最初级的的css变量定义方案，通过@keyframes定义一个变量，然后在animation属性中直接使用，就实现了css动画，非常简单。
*** 如何实现FFI呢？很简单，将函数调用序列化，定义一个通用的格式，然后在两边提供服务解析字符串调用本端的函数再调用另一端的服务把数据传回。
*** 关联数据与衍生数据。在编程的过程中广泛存在，需要一个通用的模式来实现这一关系，它就是vue里面的计算属性。
*** vue与react数据流对比。对于数据传入，两者使用的方式都是props，但数据传出方式不一样，react使用的是props回调，而vue使用的是基于$emit/$on的事件系统，这种方式引入了额外的API，实际上不如react的优雅。
*** TIPS 关于vue中计算属性与$watch方法的对比，计算属性的目标是计算出一个衍生属性的值，它是可以在模板中直接使用的，而$watch只是为了执行一些联动，它的目的并不在于算出一个属性，而在于联动，比如改变页面的样式，做http请求等。
*** TIPS vuex实际上可以理解为redux在vue上的类似实现。用统一的store来管理公用状态，来实现回滚，状态可追溯等。
*** react并不是双向数据绑定的，它是单向数据流的（可以说是单向数据绑定）。数据通过props流动到组件内部，当用户操作导致状态变化，它需要用户自己主动去调用render（setState会自动调用render）才能实现UI更新，尽管这样要求用户多写了点代码，但也带来了很强的灵活性，比如允许我们修改很多状态之后一次实现UI更新，提高效率。
*** 其实从头实现一个程序框架这些东西并不复杂，只要定义好规则就可以了，实现起来没有多费劲。
*** 为什么现在像react/redux/mobx这种状态管理框架越来越火了？因为前端的业务越来越复杂，而对付复杂的唯一手段就是拆分，组件化就是这么来的，但是页面拆分之后，状态也跟着一起拆分了，而状态与状态之间往往是有联系的，如果状态分散在到处，想要维持它们的一致性就会非常困难，要在修改状态的过程中插入一些钩子也不行了，于是就出现了各种状态管理库来统一管理这些状态。
*** 实际上状态管理的本质是封装，是一种高层的抽象，通过它，我们能够对状态管理规范化，管理化，维护起来也就更加的轻松。
*** 关于状态管理，最重要的一句话是————单向数据流，这一思想来自于Flux。为什么要单向？因为只有这样，才能避免互相依赖。
*** 不要直接修改状态，要修改数据，然后基于数据重新渲染得到新的状态。
*** redux数据流：
	store.dispatch(action) -> reducer(state, action) -> store.getState()
** 2017/06/08
*** TIPS hosts文件实际上是一个本地的DNS,系统先通过它进行域名解析得到IP,找不到再去远程的DNS服务器去找，也可以说是一个钩子，我们通过它能够干很多事，比如请求截获，请求统计，甚至请求伪造，都是非常容易的。另外，不止电脑上可以设置host，通过路由器也可以设置，而且更有用。比如你可以将服务器上的代码放到本地的另一台机器，并在这台机器上启动服务，然后将远程服务器域名映射到这台机器，这样你就可以直接在这台机器上调试远程代码了。
** 2017/06/09
*** TODO template标签
*** 在vue中，我们使用props来传递数据，使用slot来传递模板。
*** IMPORTANT 关于函数式编程中如何处理状态依赖问题有个简单的解法————不断merge，每个异步操作会引入一定的数据到函数调用链，你需要做的是把新的数据merge进原始数据（不要直接merge，最好merge到新加的字段，便于以后维护），然后继续传递到下一个异步函数，这样后面的函数就总是可以取到之前所有数据，就避免了还需要额外引入全局状态的尴尬。通过这种方式，能够渐渐构建起一颗状态树，维护起来就非常轻松了。
*** TIPS 现在前端各种构建工具大行其道，为什么呢？这些构建工具有什么好处呢？它能使我们超越语法，站在更高的角度思考问题。
*** 绝对不要小看了模板字符串的潜力，模板字符串中的变量不止可以是普通的js变量，还可以是其他的模板变量，这样我们就实现了模板的可嵌套。
