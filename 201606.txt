* 2016/06
** 2016/06/01
*** 做前端久了，其实很容易形成树形思维，因为web的基础html就是一颗非常明显的树结构，这其实是非常有好处的。像mfc/c#/wpf这种界面库非常完善的语言做起开发来，由于用到树的地方已经被程序封装起来了，我们并不关心它的内部其实是一颗树，这虽然方便了界面开发，但却让人不知道内部树的存在，对深入理解程序不利。
*** 大量的使用函数能够延迟整体的计算过程，我们所需要的所有东西都是在真正需要的时候现算出来的，这样能够保证数据的正确性，但坏处是重复计算过多会降低效率。我们也可以提前将需要的东西存起来，需要的时候直接取，这样就能避免重复计算的开销，但这样我们需要维护所存储的东西的正确性，一旦它所关联的东西修改就要及时更新存储，会带来额外的管理开销。事实上，大量使用函数就是所谓的lazy evaluation，而是用存储就是所谓的egar evaluation，这两种求值方式各有优劣，需要根据实际情况选用。
*** 尽量不要使用var，应该使用let，因为首先，从表意准确性上来说，这两个关键字都是实现的变量绑定，使用let实际上更加准确，其次let具有块级作用域，能够避免很多由于var的函数级作用域引起的bug，var所具有的唯一优势也就是效率了，但效率是一个前期无需多加考虑的因素，所以，还是不要用var了吧，用let就行了。
*** 在js的函数调用中，如果没有显示的指定调用函数的对象，那么js会默认使用全局对象windows来绑定到this上当做当前对象，所以，如果想对原有对象进行续处理的话，需要使用call/apply来进行函数调用，这就是这两个函数存在的意义了。
*** 其实js的this就是一个隐式指定的参数，这种方式隐藏了非常关键的东西，很容易让人误用或是疑惑不解，还不如显示的制定一个对象来的方便。
*** 只提供唯一一个修改数据的接口，这样只要你略微修改这个接口，就可以在所有相关联的地方实现一改全改了。
*** 如果只是在函数里面用，使用for比使用forEach更加的灵活强大，但如果需要在函数外面使用，允许用户自定义，这时使用forEach就更胜一筹了，因为可修改性更强。
** 2016/06/02
*** d3使用select的方式来取界面上的元素，这种方式太依赖于元素的id与class等标签，而这些标签实际上属于界面内部的具体实现细节，是不应该暴露给用户的，这应该可以被称作是使用d3来写ui的一大缺陷。d3只适合于用来将数据展示在界面上，至于展示之后的交互，d3还是只能基于css元素选取，这就是d3的短板了。
*** TODO d3使用将数据直接当定到了dom元素上，这种方式
*** 那么，到底什么样的框架才适合于用户交互呢？这只有那种非常容易绑定js变量并渲染的框架才能够胜任，比如使用jsx的React。
** 2016/06/03
*** 异步与并行虽然在计算速度上有优势，但却会打破顺序进行的执行流，使得程序的执行流如幽灵一般的难以预测，调试与跟踪都会非常费劲。所以，如果不是对性能有很高的要求，还是尽量少用。
*** 在通常的编程中，对程序速度要求很高的代码只是很少的一部分（比如主渲染模块），在其他的大部分情况下，速度是个无关紧要的东西，一毫秒与一百毫秒没啥差别，在这种情况下，保证代码的可读性、可维护性才是更加重要的东西。
*** reduce本身是收集的意思，它能将数组里面的东西收集到一起。
*** js中，直接使用数据很多时候有自己的局限性，比如无法使用外部函数，无法获取自己等，比较好的办法是在这个数据外面封装一层函数并返回这个数据，这样这个数据就变得灵活可修改了。
*** TDD vs BDD，测试驱动开发对比行为驱动开发。
*** 界面相关的测试为什么这么难？很大的原因也许是它们输入比较难以描述，如果我们能够解决这一点的话，那么测试这些程序也就能变得比较简单了。
*** 测试的关键――――输入、输出。覆盖？
** 2016/06/04
*** 不要设计过于复杂的功能，即使做出来了也没人会用。
*** TODO 函数设计的艺术――――设计可复用、容易复用的函数。
** 2016/06/06
*** 尽可能多的使用纯函数式编程，不要使用外部变量，因为只有这样写出来的代码才是可以被追踪的，不会有一个变量到处修改的情况。这种写法能够保证一个变量的作用域尽可能的小，不可能允许到处都可以修改。
** 2016/06/07
*** 使用forEach实际上容易造成不好调试的问题，因为使用for是在一个函数，是在一个函数，而使用forEach则是在不同的函数，在forEach函数里面看不到外面函数内未引用的变量。
*** 使用util文件夹作为一个临时的代码仓库，暂时不知道放在哪里的工具函数先放到这个文件夹中，以后函数多了就能够实现再分类了，这样能够提升代码组织质量。
*** 如何隐式的促使团队成员写出高质量的代码？首先要树立这样的心态――――你不能整天挂在口头上，指望别人写出高质量的代码，你得自己主动的去改。你必须自己把代码写的简单易懂，写的即使别人想写出垃圾代码都很难得程度。这听起来不可能，但实际上是可能的，有个很简单的秘诀就是尽量是得每个函数都很短小，让别人很容易就可以找得到自己的东西应该放在哪里，这就要求我们多写函数，多抽象函数。
*** 合作开发写代码存在着这样一种规律，只要一个人创造了一种模式，其他人做类似需求时就会照着这种模式去抄，而不管这种模式好不好维护，好不好理解之类的事，所以，只要你在创造的时候本省模式优秀或是把别人的烂模式改的优秀了，其他人即使是照抄，写出来的代码也是优秀的。
** 2016/06/08
*** 基本上凡事出现flag的代码部分都是可以单独抽象出一个判断函数的，这样做之后，带来的是更加优秀的代码可读性、可维护性与可拓展性。
*** 实际上iD里面的parentRelations就是一个查表操作，遍历数据容器里面所有数据，查找满足函数给定参数的对象，实际上就是一个遍历，类似于数据库的通过一个表查找到另一个表的操作。通过这个函数，iD在一个容器里面实现了分表。
*** 不要在代码里面写flag，一旦出现flag，最好将他提出到单独的函数中，这样写出来的代码表意清晰，容易理解与维护。
*** 变量与函数的最关键的特性在于复用，变量使得我们可以复用一个数据，函数使得我们可以复用一段代码，他们抽象出了模子，然后通过求值使得我们能用一样的形式表示一堆操作，实现简化。
*** 测试实际上有助于研发能力的提高，修改核心流程时，我们无法保证所有已有的旧代码依然能够正常工作，这个时候，测试能够逐一进行检验，找到我们思维遗漏的地方，提醒我们问题。所以有个称职的测试在后面支撑还是很爽的。
** 2016/06/09
*** 后代选择器是一个非常好用的东西，这种选择器应该被大规模的使用，正是因为有了它，我们无需给html里面的每一个dom元素取一个唯一名字，只需要给一些关键的容器取个好名字，然后就可以通过它取到任意一个元素，即使子元素重名了也无所谓。实际上它的最大作用是实现了嵌套作用域。
*** 模块化的开发css也是非常重要的，一般比较合适的规则是――――一个或一类js文件对应一个css。
*** 编程最关键的概念在于抽象，能够把重复出现的东西抽象出来，以最合适的方式进行复用，这才是真正的编程能力。
** 2016/06/12
*** 可能是overflow:hidden的优先级比较低，css渲染器在解析的时候是先利用的宽高计算的位置，后用overflow:hidden渲染的隐藏。也就是先计算inline-block，即使是inline-block（行内元素），在父级元素宽度不够的时候也会自动换行，然后再overflow:hidden就是讲下一行多余的部分给隐藏了而不是将本行多余的部分隐藏。
	使用这一理解方式的结论就是overflow:hidden只能hidden一个块。
*** 在代码编写的过程中，其实写出来只是第一步，这一步能够获取的知识很有限，比如只能获取基本的用法，对抽象的理解其实作用有限。像锻炼抽象，其实得从对已经写出来代码的重构过程中来掌握。
*** 如果将父元素的布局设置成了flex布局，那么其所有子元素，包括像div这样的块级元素，都将变成行内元素，不会换行。不仅如此，他们之间诡异的一个空格字符导致的间隔也会消失，是一种非常完美的布局方式。另外需要注意的是，flex布局只会影响到其一级子元素，子元素的子元素如果是块级元素依然会换行。
*** div的外层间距是可以重叠的，不管父子关系还是兄弟关系，不管隔着几层，重叠都一样会发生。
*** 尽量不要依靠子元素去撑起父元素的尺寸，因为这样一旦子元素内容变化，父元素的尺寸也会跟着变化，比较好的做法是定死父元素的尺寸，然后定好对齐策略，这样就可以保证不管元素内容怎么变化，父元素的尺寸不会受影响。
*** 尽可能的编写可重用的样式，而不是只要元素内容稍微改变，样式就不再可用了。
*** div最重要的功能就是占位，很多时候我们其实并不需要某一层div，但是为了占位没办法，只能多套一层或几层div。
*** html的设计中，有个很重要的方面是为变化而设计，为今后可能发生变化的部分做适配。
** 2016/06/13
*** 其实自己写一个正则表达式匹配器（不要叫引擎，会让人觉得很难实现）还是很简单的。
*** 实际上不管学习什么东西，都把这个东西当做一门语言来研究一番，把编程语言里面的东西一个个的往上面去套，理解了它的模型之后再自己来实现一遍，基本就可以完全弄清楚这个东西的方方面面了。这是一种非常好的学习方法，使用这种方法学习起东西来能够学的飞快。
*** React有一个重要的突破，他把html/js的控制方向反转了。这给JS老手一下子进入一个自由天地的感觉。html/css不再是很难处理且反过来约束js的异质物，而成为了一样可以用js操控的普通对象。
	――――贺师俊
*** React为什么只做view？因为在原本的体系里这是JS老手最hold不住的地方。早一点的Angular就不一样。JS老手其实大都不喜欢Angular，因为虽然它解决了大量问题，但是像应用架构本身JS老手们都有自己的看法和喜好，很可能早就用上了Backbone或内部自制的框架。甚至JS老手早都用上了各类模块化方案了，但Angular的模块化还一团糟。相比较而言，只做view的React就更少理由被抗拒。
	――――贺师俊
*** 全栈开发提倡的并不是一个人搞定所有事情，而是一群人怎么高效地搞定一件事情。
	――――如掾《从云市场业务看全栈开发》
*** value type与reference type，也就是值类型与引用类型。实际上，值类型也许是一个根本没必要存在的类型，所有类型都统一使用引用类型来实现是完全没有问题的，就像java、scheme一样。不止没有问题，还有很多好处，比如能简化语言模型，帮助程序员写出更好的程序；能更好的帮助GC优化。
*** 可组合性是编程语言表达能力的基石，优秀的编程语言都有着非常强的组合能力，能使用最合适的方式将所要解决的问题描述的清清楚楚。
*** 其实数据库的问题哪有那么困难，它其实跟“远过程调用”（RPC）没什么两样。只要你有一个程序语言，你就可以发送这语言的代码，到一个“数据服务器”。服务器接受并执行这代码，对数据进行索引，查询和重构，最后返回结果给客户端。    ――――王垠《关系模型的实质》
*** TODO 实际上，对齐在前端是个非常复杂的问题，值得被好好的讨论下。
*** 关于盒模型box的margin与padding的选择问题，一般最好用margin，因为margin具有边距叠加这一特性，能够保证我们在有很多box放在一起的时候依然能有比较合理的边距，而使用padding就做不到这一点了。
** 2016/06/14
*** 不要使用结构太复杂的数据结构，应该把数据结构按照层级结构拆分开，一层一层的来写，这样可读性就会非常好，干起其他的来就非常简单了。
** 2016/06/15
*** 为什么推荐把代码写到很多个文件中，而不是在一个文件，因为在编码过程中，模块化是非常重要的，我们需要一个整体的框架来帮助我们理清思路，而分文件作为一种最显而易见的分模块的方式，自然应该被放到一个十分重要的位置，分文件能够给我们创造一个显示的思维壁垒，当我们需要往那个文件中添加代码时，我们就需要考虑将代码放在里面是否合适，如果合适，放在哪里比较好。
*** 面向对象编程与函数式编程应该灵活使用，如果纯用函数式编程而忽略面向对象，写出来的代码就容易出现a().b().c().d()...这样无限长的调用链的情况；而如果使用纯的面向对象编程，完成任何一个简单的功能都需要先new一个对象，而且由于会保留大量的状态，并行起来非常复杂。面向对象比较容易实现大规模的抽象，而面向函数，至少我现在想不到比较好的抽象方法。
*** TODO 做了这么久的渲染，也许我已经能够抽象出一个通用的渲染方式出来了，然后用这个渲染一举灭掉所有的渲染文件。
*** 实际上对于特效这个东西来说，现有的渲染方式是对每一个特效，遍历一遍所有的实体，过滤出需要被显示特效的实体，然后对每一个实体，在这个实体旁边渲染出特效效果。使用这种方式中间又一次额外的存储存取开销，如果能够改成――――如果这个实体需要被显示特效，就在这个实体附近把需要渲染的东西给渲染出来。这样就能够提高一点渲染效率。实际上，不管采用哪种渲染方式，我们可以发现有两个共同的问题，一个是判断一个实体应不应该显示特效，一个是如果应该显示特效，那么应该如何渲染这个特效。这就是抽象的点。
*** 为了比较容易的使用我刚刚的思路进行抽象，我需要抽象出这样几个工具函数：
	1、在指定的位置渲染某个图标。
	2、在指定的位置渲染某个文字。
	这两个函数抽象出来以后，使用它们我就能解决大部分的特效渲染问题。除此之外，还需要一些特殊的渲染方式支持，比如在道路方向上绘制箭头，指向下一个需要渲染的实体，点击某一个实体才显示等。也就是说，如何渲染可能需要额外的参数支持，根据当前的环境自动选择如何渲染。
*** 实际上，d3还是比较傻逼的，没有基本的渲染函数这个是硬伤，不要以为大公司开源的东西就有多牛逼，改傻逼还是傻逼。
*** 如何在抽象的时候兼顾灵活性，这个是对抽象者的一个极大的考验，很多人都有抽象的习惯，但抽象出来未必有人肯用，这个就是抽象的灵活性不够，无法适应别人的需求导致的。
*** 也许有问题的不是工具，而是使用工具的人。写代码的人不应该被工具所驱使，照着工具的思路取走，应该有自己的判断，针对工具的缺陷做出自己的改进，然后照着自己的思路走。比如d3，使用d3的方式去操作dom写出来的代码是很丑，但如果我们先对它进行一次封装，然后使用自己封装的函数，这样就能极大的减少这种代码出现的几率，写出来的代码一样可以非常优秀。
*** 通过一个全局变量selectedID来进行选中渲染，每次渲染的时候其实都会判断一下是否有新的选中实体，如果有，就在这个实体旁边渲染出样式，这就是选中特效的实现。选中特效实际上比较特殊，它并不需要传入额外的实体，直接就能通过读取全局变量来获取这个实体，然后渲染起来其实和其他的特效没有什么差别。
*** 绝大多数的抽象都会影响灵活性，这主要是因为抽象容易丢失数据，如果是在处理的终点丢失，这没有什么问题，但如果是在开始或中间阶段，某些功能可能就很难实现了，灵活性就没有了，这也许就是许多人虽然知道抽象出函数的好处更多，但任然不愿意抽象出函数的原因，因为这样他们就不能自由使用调用环境的外部变量了。
*** 我们使用了iD定义的entity结构，同时又使用了d3的框架来操作dom，实际上相当于我们使用了两个框架，这两个框架无法很好的配合工作，比如将这些基本组件连接起来的API，这就是使用多个框架的时候需要注意的东西，这些东西需要自己写。
*** 很多时候，我们也许只是缺乏了一个非常基本的函数，却很有可能因此要写一大堆重复的函数来重复做这件事，而且由于胡乱用外部变量导致虽然看到了这个重复，却无法抽象把它给抽象出来。
** 2016/06/16
*** 函数式编程通过参数来继续编程，对象式编程通过实现类来实现继续编程。这两者何时使用哪种并没有一定的规律，得灵活运用。
*** 尽可能的将各种修改汇于一处，要实现某个功能只需要修改一个地方，这才是模块化开发的真谛。
*** TODO 我已经写了一个框架统一了所有颜色类特效，文字类特效其实本来就不算乱，所以，接下来我所需要做的就是写一个框架一举统一所有的文字类特效与图标类特效。如何做到这一点呢？实际上所有特效都可以抽象出显示判断+渲染方式这两个特异的两部分，剩下的部分如渲染文字、渲染图标这些基本函数实际上是可以共用的。我只要把这些公用的部分写好，然后再针对每个特效写出特异的部分，那么整个特效系统就被和谐的统一了。
** 2016/06/17
*** 写代码的时候要尽可能的将一个功能的代码写在一起，这样看起代码来就不需要到处寻找代码，代码的可读性、可维护性就会非常好，而且模块化起来也很容易。尽量减少那种对一个对象突然来个点取成员的操作，因为这样别人就需要在别的地方去找这个成员是在什么地方被定义的，值是多少。
*** 编程最重要的能力就是抽象，而抽象最重要的地方在于：
	1、消灭重复，任何一段代码或变量值，只要出现了几次，就要想办法将它给抽象到一个单独的地方。
	2、职责分离，如果几件事经常混着一起做，那么最好将这几个部分分开，弄出清晰的接口，这样彼此都比较容易理解，也便于维护与重用。
*** TODO 一个函数里面的函数参数的参数只可能来源于这个函数发生调用时所处的环境，也就是这个函数内部所处的环境，由于这个环境是基于这个函数所调用时的环境所建立起来的，所以回调函数的参数多数时候都来源于其他的参数。
*** 其实css样式是个非常有意思的东西，它最常见的用法有两种，除了最最常见的用法给对象或类命名外，还有个更高级的用法是――――给功能命名，用来给对象或类加上一个样式，这一用法最常见的就是表示状态，比如active、select、red/blue/green等。接下来的问题是――――我们应该如何灵活的运用这两种用法呢？首先的原则就是每个对象或类都应该有一个类，重要的对象还应该是id，姑且称它为主类吧。主类应该是在对象创建的时候就给予到对象的类，有且最好只有一个，剩下的就是功能类了，这些类是在程序运行的过程中灵活在对象上加减的，只有熟练运用这两种类，才能够玩转css。
*** 在使用css的过程中，熟悉那些功能是css可以实现的，哪些是不能的，这非常重要。css目前能够实现的功能包括――――
	* base style
	* hover
	* toggle
	* click?
	* Animation
*** 实际上，动画是css非常重要的一部分，css仅仅通过两个属性――――transition就实现了所有的动画效果。通过这两个属性，瞬间css提升了一个维度，从此，css有了时间的概念，我们能够定义如何由一个效果变换到另一个效果，而不需要一行js。这一属性堪称抽象的典范，抽象应该允许维度之间任意组合，这样才能将模型做到最简。
*** css中，transition实际上就是渐变动画，它使得我们可以在指定的时间内将对象由一个样式变换到另一个样式，它只支持两个样式，而且只能触发一次，不能重复触发，是它完成了css中动画从无到有的转变，但它还是不够强大；animation是增强版的transition，它能够指定关键帧，让样式从一个样式变到另一个样式，从此，css有了逐帧动画，而且，它能够指定播放的次数。
*** 实际上，前端的很多抽象就是正交的，堪称抽象的典范，比如：
    1) 通过鼠标键盘事件使得在页面显示的所有元素都具有了可交互能力，能够使用各种事件然后通过js定义交互。
	2) 通过transition与animation使得所欲的元素都具备了动画能力，我们可以自由的制定元素的动画。
	3) 通过伪类的加入使得我们能够控制鼠标滑过某个元素时元素的样式，使得我们可以不需要通过鼠标事件去实现了。
	4) 通过给background-image加入line-gradient，使得我们可以给所有元素添加渐变颜色的背景。
*** css不是网站开发的关键，却是web用户体验的关键。――――oklai
*** Ctrl/Alt/Shift，很多人在一遍一遍的使用这这几个东西，却很少有人去思考下这几个键所代表的意思，以至于各种误用随处可见。Ctrl代表控制，主要用来发出控制信号;Shift代表转换（也可叫上档），主要用来将一个键转换状态，比如大小写转换;而Alt表示换挡，如果说Shift只是将一个键转换为与之关联的键的话，那么这个键能够将一个键转换为与它完全无关的另一个键。
*** ps玩的好的话其实可以像编程一样的，每一个功能就像一个函数，能够将屏幕上的图像从一个状态转换为另一个状态，只要熟悉这个转换的原理并将之灵活运用，其实是完全可以极大的发挥这个软件的作用的，比如这个：http://www.knowsky.com/442611_1.html。
*** 为什么要提倡组件式开发？还有个重要的原因是因为它能够实现一改全改，只要修改下组件的功能，所有使用这个组件的地方就都拥有了这个功能，实际上，这非常类似于给基本对象增加了一维能力，这样，我们才能够有排山倒海般的编程能力。
*** 从今天开始，我需要为我的跳槽计划做点准备了，尽可能的抽出时间学习，做一个潜龙，默默积攒实力，拼命积攒实力，等候一飞冲天。
*** 什么是函数式编程？函数式编程实际上是一种编程范式，它要求我们在编程过程中使用类似于过程式的方式，把每一件事分成几个部分，然后一个部分一个部分的去做，形成一个顺序流，函数式编程的好处是思维连贯，它可以允许我们一步步的思考问题，而不是先将问题分成一个个部分去思考，通过函数式编程，我们能够以更少的代码实现更强的抽象，而且，我们能够毫不费劲的就实现并发。
*** 虽然函数式编程要求我们一步步的去编程，但实际上，我们依然不能忽略面向对象的思想，只不过我们需要使用函数式的方式来表达出面向对象，具体来说就是不断返回this，这样我们就可以使用函数式的方式写出面向对象的代码了。
** 2016/06/19
*** TODO 将数据与渲染分离，把所有数据放到共同的地方去，实现分层。
*** 实际上，js模块加载器的实现利用到了js的命名提升规则，所有的函数定义被放到了打包的文件前面，这样就可以解决所有依赖问题了。
*** webpack实现原理：
	1) webpack会把每一个文件封装到一个函数，然后把所有的函数一起放到一个函数数组里面。然后数组下标就是moduleId,这个数组就是modules。然后从modules[0]开始，依次通过其他require函数将其他文件引入。
	2) 通过不断传入传出module.exports来维持一个公共的作用域，以便于多个函数之间的作用域共享。
*** 很多时候，多嵌套一层容器div是有好处的，最明显的就是――――一旦容器的样式改变了，它里面的所有元素都会跟着改变。
*** 顶层按照内容抽象，底层按照实现抽象，这两者互相结合，就可以保证：首先易于维护，其次开发效率高。这才是真正的编程之道。
*** 实际上，界面的渲染有时候是基于数据的，有时候是基于界面的。也就是说，有时候，我们是把数据渲染到界面上，而有的时候，我们是界面上已经有了这些东西，需要取数据。这两种方式虽然好像是一样的，但其实主次关系是相反的。
*** 虽然js允许在任意改变变量的类型，但是任意改变变量的类型会让变量表意混乱，难以理解和为何，所以，我们应该尽可能的少用这一特性。
** 2016/06/20
*** 实际上，一个很大的不常用的定制化的控件并不需要做模块化，因为一次成型，不会拿来重用，只有那些经常需要被拿来做重用的小模块才需要被仔细考量，考虑重用。
** 2016/06/21
*** 使用回调是一种将子组件数据传递到父组件的方法，而且是常用的方法，这也是事件这种机制之所以存在的最主要的原因。
*** 本来很简单的一个东西，可能由于很多人彼此之间消息不同，产生各种稀奇古怪的实现，这种东西会给后期带来巨大的维护开销。
*** 代码编写时，集中式便于管理，分布式便于拓展，如何处理这两种代码书写方式之间的冲突呢？正确的方式是只将核心需要通信的地方进行集中式管理（比如最常见的容器对象），将其他绝大部分的代码分布式管理，这样就既兼顾了管理，又兼顾了拓展。
*** 容器实际上有个非常重要的作用就是用来解决遮挡问题。将图标单个考虑肯定容易产生遮挡，正确的处理方式是使用容器。每当有的显示对象添加进来的时候就加进容器，而不是各管各的进行显示。
*** 既然道路特效可以直接在line.js中做判断并绘制，那么节点特效同样可以在labels.js中判断并绘制，与道路特效一样，我只需要抽出一个判断函数，所不同的只是我需要额外提供一个渲染方法，这样就能完成所有的节点特效抽象。
*** 以前特效各自为政，各渲各的，导致大量重复代码，更为关键的是无法统一管理，比如无法解决遮挡，无法动态调整位置。而且由于加特效时需要加大量的代码，导致bug多多，无法一改全改。重复代码导致多次遍历，多次渲染，显示的效率也比较低。
*** 完成同一件事有n种方法，但允许百花齐放其实是对代码质量的一种伤害，我们应该尽量让相同的代码不要重复出现很多次。
*** 何为渲染引擎？渲染引擎其实非常类似于垃圾回收器（GC），它应该把渲染的事都自己做了，让别人根本感觉不到渲染的存在，什么时候渲染，只有完全让别人感觉不到这东西，才是一个非常成功的渲染引擎。
** 2016/06/24
*** 不要随意修改对象结构，即使js是允许你随意修改的，因为你如果在某个地方修改了，当你在另一个地方使用这个对象的时候，别人还需要跳转到这个对象创建的地方去看这个对象到底表示什么意思。
*** 关系类特效没有缓存可能会非常慢。
*** 程序里面少数的全局变量还是必须的，它们能为整个程序的编写提供巨大的方便，不可忽视。
*** 老代码中可能有不少地方散落着珠宝，要细心发觉，将好的部分发扬光大。
*** 对拓展开放，对修改关闭，应该为别人留出方便拓展的接口，只有这样才能避免别人把你的代码修改的乱七八糟。
*** svg是一种使用dom方式定义图形并渲染的标准，由于基于dom，所以原生就支持dom事件，交互起来很方便，而canvas实际上就是一张画布，它是不支持事件处理的。
** 2016/06/27
*** 非常耗时的操作应该尽可能的丢到外层去处理，以减少函数被调用的次数，可以将这些操作的结构提成一个单独的参数，也可以只返回其他部分，避开这种运算，具体采用哪种方式以采取哪种方式可以时代码更加简洁清晰，以维护为准。
*** 在写代码是应该尽可能的多写不再需要被维护的代码，将需要一直维护的代码量减到最少。
** 2016/06/30
*** 使用perform改变数据，改变数据的时候同时使用change事件刷新显示，并将之前的数据传递给渲染引擎以产生差分，然后进行渲染。
*** 
| stroe   | component |
| reducer | action    |
store一旦更新component自动更新，component通过用户交互产生action类似于事件，事件通过reducer类似于eventHandler进行处理，处理stroe中的数据，store中的数据一旦更新，这个更新会自动通过option更新到界面。
*** 模型之间的数据同步这种事应该交给框架去维护，不应该由人来做。我们只要定义好数据映射关系，然后一旦一个修改后，另一个也会同步修改，为了效率，我们可以使用id与version来进行数据比较。
** 2016/07/01
*** 使用css来写样式相比于使用直接在元素上来写还是有些独到的好处的，最明显的就是你可以一次选择一组元素，对它们来使用样式，而不是一个一个的去设置，这样就可以大大减少样式代码了。实际上相当于把设置样式的单位由个拓展到了组，实现了一改全改（类似于变量的效果）。
*** 灵活运用css选择器，一个样式里面超过10行就需要好好考虑是否合理了。
*** 要想逻辑思维清晰最好都遵循单因子变量原则，不能同时考虑好几个变量，先规定好一个前置条件，再判断下一个条件，一个一个判断才能保证不遗漏。
