* 2014/09
** 2014/09/01
*** 采用工程化的思维来解决复杂问题。
** 2014/09/02
*** 实际上对于程序而言（exe或dll)，根本就没有函数的概念，一个程序就是一个执行路径，从入口地址开始，一路往下跑跑跑，一直到执行完毕退出，这就是机器对于程序的理解。函数只是我们人为了便于自己理解而创造出来的抽象概念。exe里面根本就没有导出函数的存在，dll里面是由于有了导出函数才可以找到每个函数对应的地址。
*** 在程序里面最有数据像输出的字符串，dll导出的函数名会被保存到生成的程序里面，代码，像exe里面的函数名什么的是不会被保存到exe的。
*** dll动态链接的原理是在生成的程序里面保存了dll里面函数的名字，然后通过这个名字能够找到函数的地址，并不是什么很神奇的东西。
*** PE文件是一种区块式增长的文件结构，这样保证了执行效率与文件大小的平衡，但也因此使得块与块之间有空隙，给了程序破解可乘之机。
*** 使用导入表可以实现代码注入，在原有程序的基础上植入外部代码来修改程序的功能。
** 2014/09/03
*** 可以在模块定义文件中指定NONAME来不将导出函数的名字写进dll，这样可以减小生成pe文件的体积，但这样就无法产生的pe也就失去了动态链接的能力，因为无法通过函数名获取函数地址了。
** 2014/09/05
*** 管理最重要的是形成一个闭环，多个因素互相牵制，达到平衡，使得每个人做事都有所顾虑，不能随心所欲，这样才能达到最好效果。
*** 程序运行基本四大区：代码区，数据区，栈区，堆区，可执行文件如pe,elf格式必须将这四个区都初始化完毕了才能开始程序的运行。很多时候我们容易忽略栈区和堆区，这样就留下了知识的漏洞，无法彻底弄清楚程序的执行过程。
** 2014/09/09
*** 如何区分一个pe可执行文件是debug还是release？很简单，用pe查看器打开看看，如果带有textbss段就表示此文件是debug的，没有就表示是release的。这个段是用来存放未初始化的代码段的，用来增量链接，debug版本一般才会打开这个特性，而release不会。
*** 如何查看一个pe可执行文件是用vs的什么版本写的？用pe查看器查看链接器版本号，也就是可选头魔法数后面紧跟的一个字节，此版本号就是vs的版本号。
*** 如何区分一个pe可执行文件是32位的还是64位的，还是很简单，用pe查看器打开此文件看它的处理器字段值，也就是pe\0\0后面紧跟的两个字节，014c表示i386,也就是32位的dll,8664表示amd64,也就是64位cpu。
*** 人的思维最大的缺陷就是无法存放大量信息，所以思考能力受到限制。弥补这一缺陷的方法就是通过纸笔，记录下思考的中间成果，这样人脑就能获得跟计算机一样的思考能力，同时还能尽可能地发挥人脑主动思维这一计算机思考做不到的特性。
*** 不止库之间会出现依赖关系，头文件之间也会出现依赖关系，这种依赖关系的出现只会导致一种结果————就是头文件以及库文件的引用出现顺序关系，必须先引用被依赖的库，再引用依赖的库才能正确通过编译，否则会出错。
*** 何谓事件？事件其实就是这样一种机制，将两个函数之间通过一个第三个的对象给串联起来，使得事件的发送者与事件的接收者完全解耦。一个事件既可以让这个函数去处理，又可以让那个函数去处理。在这种模型中，事件的产生与发送往往不需要我们去关心，我们只需要关心事件的处理，从而简化了程序员的工作量。
** 2014/09/11
*** 其实静态lib库还真就是把几个obj简简单单的放在了一起的产物，再在最前面加上了一个总头，每个obj前面加上一个小头，就这样一个lib就形成了，就是这么简单。那么如何识别一个个obj的开头与结束呢？也好说，obj的开头总是以pe header格式（optional header没有），简单点来说就是以4c01开头，最后结束后一般有其他obj的附加小头，这种头也好认，就是以/0开头，然后后面接一堆20，再接一个年月日这种格式。另外，在lib的前面是会有整个lib的函数表的，只不过没什么工具来很方便地查看这些函数而已。
*** 其实云计算就是一种电厂模式。我们使用电来驱动电器，根据使用的电量来计费，消耗电费快慢的计量是功率。而云计算使用的是计算资源来进行计算，根据使用的计算资源来计费，资源使用越多花的钱越多，往往大型游戏会消耗较多的计算资源，这也是合理的。
*** 软件工程的要求之一就是不要重复发明轮子，但实际上，这种事实际上却是在一次次的重复发生，因为解决复杂软件问题的方法总是一样的。一个问题，一旦复杂了之后总是越来越类似于这几个东西————操作系统，编译器，网络系统，数据库。所以，清晰地掌握这几个东西非常有必要，不是为了去重复发明这些东西，而是以这些东西为指导，去解决其他方面越来越复杂，越来越接近于这类问题的东西。
*** pe文件的导出表实际上就是一个指明当前文件中有哪些函数可以被外部使用，他们的名称，地址等信息的结构，也就是说想知道文件中函数的地址只有通过导出表，本来没有导出表却想找出函数的地址是不行的。比如如果静态lib的一堆obj这一coff格式的文件中没有导出函数，想直接找出某个函数的地址是不行的。不过也并不是说不能得到，其实可以利用这些函数往往都在text段前面，入口点函数下面这一性质找到先找到第一跳的函数地址，再根据跳转指令找到真实的函数地址。
*** 牢记obj目标文件中没有可选头，这是什么意思呢？由于导入目录，导出目录，重定位目录等各种目录是存在于可选头的目录列表里面的，所以obj中是没有这些乱七八糟的目录的，它只有自己的一些节以及这些节的实现。更进一步就是说obj中是不能引入引出函数的。
*** 多级地址实际上是一种将地址当做数据，以实现地址可变的做法。因为物理的地址一般是规定好的，不可变的，但是如果将这一地址作为一个数据存储在另一个地址里面的话，这个地址就变成了一个数据，而数据是具有可变的特性的，因而实现了地址可变。这实际上与代码与数据的界限是一样的。代码一般是不可变的，而数据是可变的。而某些情况下，我们确实需要代码可变，比如动态生成对象，反射读写属性，调用方法等，这种时候我们就需要将代码当成数据来处理了，这就是所谓的元编程。实现这一技术的方法有很多种，常见的有反射，模板，预处理生成代码（Qt）等实际上都是通过编程技巧实现了这一转换的。
** 2014/09/12
*** 管理永远需要信息支持，用户（被管理者）向管理者提供越多的信息，管理者越能对用户进行精细的控制。典型的例子就是插件系统，上面有很多小的插件，插件与插件之间需要通信，要实现它就必须由插件去主动向其管理者提供这些信息，管理者才能在这些插件之间去协调。
** 2014/09/15
*** c#的特性很多时候是一个开关，作为一些很简单的通用方法的实现。
*** Qt的信号槽机制提供了很简单的方法可以将信号函数与槽函数关联在一起，而且是多对多的关联，这比mfc的消息映射机制只能将多个消息映射到一个函数这种多对一的关联就强大不少了。
*** mfc消息机制的缺陷：
1、不支持一对多的消息关联，需要在一个函数中依次调用每个函数。
2、不支持附加参数类型，需要经过lparam与rparam多次转换。
3、不支持将一个类发送的消息发送给其他类对象进行处理，需要使用PostMessage来进行转发。
*** 实际上经过用心的设计，编程中的所有复杂的地方都可以得到解决。关键就是你要找到那些复杂的点来设计，而能否找到这些点就需要编程者自己的经验与行动了。
** 2014/09/16
*** 虚函数基本上可以说必须也只能配合指针使用才行，引用都不行，因为引用不可变。其实引用这个小工具仅仅是能代替很小一部分的指针使用而已，c++终究还是离不开指针。使用指针调用类函数时，如果调用的是非虚函数，编译器只会看当前指针指向的类去里面调用函数，如果是虚函数，编译器则会根据实际指向的对象类型去调用相应的函数。也就是说，非虚函数根据指针调用，虚函数根据对象调用。
*** 要实现动态的特性，就必须将相关的信息存储起来，通过修改这些存储的信息，来实现同样的访问方式访问到不同的东西。比如c++中的虚函数，在代码层面同样是a->fn()的访问方式，为啥同样是call一个地址，虚函数与非虚函数不一样呢，因为虚函数将call的信息存储下来并改变了，所以虽然都是call，但虚函数实际上确是call了两次。
*** c++中，怎样知道一个函数是不是虚函数？语言层面的支持很有限，因为子类虚函数的virtual是可以省掉的。怎样知道一个虚函数是在哪一个抽象层级上实现的？这些都是问题。
** 2014/09/17
*** 面向过程与面向对象————面向过程是一种一步步去做事情的实际处理事情的方式，适合于处理完事情后就不会再有后续的管理方面的事情，而面向对象更侧重于分工，横向分块与纵向分步骤，虽然即使分了步骤事情依然得一步步去做，但这些前期所做的划分工作由于提前登记了所属对象，将极大地方便了后期的管理工作，对需要管理的事情还是非常有必要的。实际生活的很多事情实际上都是采用的面向对象的方式，比如任务划分，进度估算，集团管理等等。
** 2014/09/18
*** 模板实际上就是一种将类型作为变量的编程方法，它允许我们在不知道类型细节的时候就可以使用该类型，包括该类型的属性与方法，根据具体的应用情形改变类型却不改变算法。模板变量实际上就是类型变量，它存储了类型这一元信息，可以用来元编程。需要注意的是，它所存储的不仅仅是类型名，还包括类型的一切，类型中的属性和方法都是可以调用的。
*** 类跟函数其实没有什么不同，类也可以当做函数来使用，并不是说面向过程就是完全不使用对象，过程代码里面可以嵌入对象，对象里面也可以嵌入过程。
** 2014/09/19
*** lisp的基本公理有七个，实际上就是七个函数，这七个函数分别是quote,atom,eq,car,cdr,cons,cond。这七个公理是构建lisp的基石，有了他们，就可以构建lisp世界的一切了。
*** 看书要懂得看重点，不管书有多厚，只捡自己感兴趣的部分去看，这在时间很紧时尤为重要。
*** 对于开源库（一般是英文），要树立一下几点认识：
1、开源库的官方文档总是很丰富的，只要耐心找，一定可以找到自己想找的东西。
2、官方文档总是最大最全的，因此很容易吓到我们。其实只要盯着自己感兴趣的部分去找着看就行了。
3、如果你盯着这些文档能够看懂，就不要去看别人去看别人写的那些入门教程，因为官方文档总是比那些文档优秀全面，能够最快地学到自己想学的东西。
** 2014/09/22
*** 查找很厚的资料时切忌从细节内容查找，应该从标题，更准确说是大标题开始查找。
*** emacs的hook就是一个函数栈，用来在某个模式加载完毕以后调用每个函数。注意由于是个栈，添加的顺序跟调用的呃顺序是个反的。
*** lisp里面的全局变量真的就是全局变量，只需要在某个运行节点处定义，在以后不管是哪个文件里面都可以使用到这个变量，不想c++还要什么extern什么的，非常方便。
** 2014/09/23
*** emacs的函数帮助快捷键C-h f可不是只能查看命令的帮助，还能查看函数的帮助，某些非activate的函数不能当做命令来输入，但是依然可以用此命令来查找函数帮助。
*** 最原始的使用网盘的想法可能仅仅是想将个人想要同步的数据放入到网盘上面去，然后就能在各个地方同步地修改这些数据，可是当使用多了之后就会出现这样一个需求————将程序也放到云盘上面去，因为程序本质上来说也是数据，程序本身也是需要同步的资源。前提是这些程序是绿色版，不依赖与其他程序，不然有可能在其它地方无法运行。继续往深层次一点想，应该将一切的程序与数据都放到网盘上面去，这样就获得了一个与硬件无关，完全同步的软件运行环境，当然，这需要极高的网速支持，近几年都不大可能实现，暂时可行的想法将不是那么大的程序与数据都放到网盘上去同步一个基本一致的运行环境。更清晰点应该这样讲————将临时性的，经常变化的文件与数据存放到本地，将其他的不是经常变化的文件存放到网盘，这才是正确的。
** 2014/09/24
*** 如何定义一个基本的工具以构造出一个复杂的系统，这个问题lisp的七个基本操作符实际上提供了一个最简化的模型，这七个东西缺一不可，无法再分。基本的应该包括如下：
1、构造cons
2、遍历car，cdr
3、判断是atom还是list的atom，是否为相同list的eql
4、求值quote，cond
只要拥有这些元素就可以排列组合出最复杂的系统。
*** 函数为什么可以看成像是字符串一样的普通数据类型，因为函数有自己的字面表示形式，能够存储在变量，能够作为参数传递。一种数据类型所应该有的功能，它都有。它其实可以看成就是一种特殊的字符串。
*** 何为函数式编程？函数式编程是继过程式编程后新出现的一种编程范式。其编程想法区别于过程式编程。前者是将一件事情分成很多步，然后一步步地去解决，使用作用域内的全局变量来存储传递数据。而后者是将一件事分成很多个函数，然后一个个函数地调用，使用函数的返回值来传递数据。也就是说，传值方式（也就是通信方式）的不同是两者最根本的区别。采用过程式编程由于采用作用域内的全局变量来通信，会大大加重代码的耦合度，使得计算难以拆分；而采用函数式编程使用函数的返回值来进行通信不存在作用域的问题，大大降低了代码的耦合性，使得代码的拆分，并行计算变得极其简单。函数式编程没有所谓的“副作用”，没有函数内部与外部互动，独立出了函数。只返回新的值，不修改系统变量，它使用参数来保存状态，保证相同的输入始终能得到相同的结果，由于某些状态总是需要保存，所以在这种编程方法中递归必不可少。一句话概括————函数是编程就是使用参数来保存数据，使用返回值来传递数据的编程方法。
*** 表达式与语句的区别————表达式是一个单纯的运算过程，总是有返回值；而语句是执行某种操作，没有返回值。函数式编程要求，只是用表达式，不适用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
*** 为什么要设计接口？设计接口能够给予某种对象一个默认的实现，帮别人将某种对象中必须实现的方法提前实现。
*** 使用使用脚本还是高级语言都能编写一样的程序，并不是脚本就一定比高级语言方便，脚本能实现的功能高级语言也能实现，而且有时候由于个人熟练程序，高级语言可能比脚本编程效率更高，效果更好。使用脚本语言编写很多时候只是为了将这一部分代码从高级语言中分离出来，以便于修改而已，高级语言并不是不能做。
*** 终于可以同步地使用一样用emacs来记笔记了，留个记录纪念下。
*** 快捷方式只是一种极度精简化的程序而已，它可以实现的功能完全可以直接用程序来实现，而且可以实现得更好。
** 2014/09/25
*** 在一个工具里面如果将所有的函数都开放给外部将获得非常恐怖的拓展能力，典型的例子就是emacs。但开放是一个问题，选择使用哪种语言来作为作为开放的媒介又是一个问题。使用传统的过程式语言无法实现热升级，不能在运行时添加新函数，替换旧函数定义，限制了程序的拓展性。而lisp作为一种函数式语言避免了这一缺点，从而将emacs的拓展性扩大到了极致。总之，emacs的拓展性之所以如此强大就是因为使用lisp语言接口开放了系统的几乎所有函数。
*** 在lisp中，既然函数只是一个普通的变量，那么自然可以做跟变量同样的事情，比如：
1、定义同名函数覆盖原有函数定义，实际上只是将新的函数定义赋值给原有函数。
2、将函数赋值给其他函数，这样就相当与给函数起了一个别名，两者都可以调用这个函数。
*** lisp中list是最小求值单元，一切function，command,operator,macro都只是在它上面做了下特殊处理而已。list有自己非常规范的求值规则，使得一切的问题变得可运算。function只是给list起了个名字，传了个参数。command只是使得function可交互。本来使用function已经能够解决大部分的问题，但总有些东西很像list但却不完全满足list的求值规则，需要事先对这些东西做下很少量的预处理才能使这些东西编程标准的list,macro应运而生。它能够先对这些类list的东西进行下处理了再求值，从而大大加强了lisp的表达能力。
*** 相比过程式语言，函数式语言其实更接近于人的思维。因为过程式语言有很多的状态量需要保存，而且往往需要保存很长的时间。而函数式语言是基于功能的，先实现什么功能得到什么结果，再将这个结果传递给什么，再实现哪个过程，一直到最后，这跟人的思维非常像，可以很容易地表达我们的思想，最后再去优化代码。
*** DONE 过程式编程，对象式编程，函数式编程是几种不同的编程方式。他们解决问题的思路是不同的。过程式编程考虑的是这个问题由那些步骤组成，每一步完成什么，如何一步步地做完这件事。对象式编程考虑的是这件问题是由哪几个对象组成，各个对象分别做什么，对象之间怎样通信。函数式编程类似于对象式编程，不过它是从函数的角度来考虑问题，而不是对象。它考虑的是这个问题是由哪几个函数组成，每个函数做什么，函数之间如何组织。它的思考方式是一种层次式的，使用函数不断嵌套式的，不是过程式的那种流式的。它是面向功能的，不是面向对象式的那种面向对象数据的。实际上重要的是你采用哪种编程方式，而不是使用哪种语言。
*** lisp支持在前面调用函数，后面实现函数，支持函数式编程，支持自定义的控制代码结构宏，光这几点就甩了c++几条街。
*** lisp的实现原理应该是这样的——主循环是一个轻量级的list求值器（REPL），在此循环体外部有着许许多多的函数（命令，宏，操作符等都是特殊函数）实现（运行环境init.mem，多半是使用哈希表实现的）,当重新定义这些实现时他们得到更新，由于一切皆变量所以一切都可以更改，然后当再次输入程序给REPL执行的时候就会使用改变了的实现来进行运算，从而实现了代码的热升级。
*** list中除了宏这种极少见的特殊动物以外，其他的都必须要满足list特殊的求值规则，第一个参数必须是使用defun或是lambda定义的函数，不能是变量，哪怕这个变量是指向函数的都不行。指向函数的变量要使用funcall或是apply来调用。其余的每个参数都必须是可求值的，出现symbol或是function基本都要用引号语法糖。
** 2014/09/28
*** 在c++中，如果子类实现了父类中的某个虚函数，不管在父类中这个虚函数是公有的还是私有的，子类的声明中是公有的还是私有的，都将体现出多态的特性，也就是父类指针指向子类总是调用子类的方法。
*** 我会有那么一天为了别人而去做我自己很不喜欢的事情吗？难道这就是所谓的成长？所谓的成长，难道就是为曾经的快乐而感伤，为今天的不幸而哀叹吗？如果真是这样，我宁愿不要成长。
** 2014/09/29
*** emacs复制粘贴快捷键：
1、M-w 复制 kill-ring-save
2、C-w 剪切 kill-region
3、C-y 粘贴 yank
*** 编写复杂程序的基本准则——将紧密耦合的东西放在一起，不是紧密耦合的东西放在不同的地方，一旦业务逻辑发生变化，只需要修改变化的部分而不需要修改整体。
*** 使用emacs的技巧是慢慢积累的，不是一蹴而就的。一开始就像完全掌握是不可能的，渐增式的学习不断迭代才是正确的。
** 2014/09/30
*** 可以在远程主机上执行代码，这就是非常大的漏洞了。常见的方式是可以访问远程主机的数据，但不能执行代码，这才是一种安全的模式。这种漏洞的例子其实很常见，比如sql注入，最近的bash环境变量漏洞等都是这样。
*** 对象之间相互通讯的关键在于协议，只要通信的双方规定好协议，然后两方都遵守，这样通信工作就能正常进行了。典型的例子是各种网络协议，还有程序中不同组件，不同部分之间要想正常通讯也是一样，规定好协议就行了。
*** 常见的线程同步的方式有以下几种：临界区，事件，互斥量，信号量。不管使用哪种同步方式，其实原理都是一样的，当执行到需要同步的部分时，先看看事先设置好的公共变量的状态，如果状态可用就执行，同时将状态设置为不可用知道执行结束。实际上就是事先定义好使用哪种方式来实现线程间通信，以便执行到同步代码的时候来告诉其他线程。
*** 在软件架构的设计中分层的思路能大大降低模块间的耦合度以及复杂性，但同时也会大大提高通信的成本，因为不同层次或模块之间需要一种统一的协议来协商通信，多了一个协议的组装与解析过程，这在通信情况很频繁的情况下是不可忍受的。
*** GUI与UI不是一个东西，GUI是图形接口，而UI只是接口，这两个东西的区别大了去了，一般分层架构最上层是UI层，但UI并不等于GUI，UI包括GUI但又不仅仅是GUI，还会有很多其他类型的UI，比如CUI(控制台UI)。