** 2016/09/01
*** centos7使用了firewalld来管理防火墙，借助这个命令提供的firewall-cmd命令，我们可以非常轻松的管理防火墙，非常方便。
*** 使用firewall-cmd来管理防火墙时，如果只是简简单单的添加一条规则，并不需要重启防火墙，但是如果是永久增加规则，则需要重启防火墙。
*** 我们不妨来想想让一个命令永久生效的实现方法。很简单，当我们开启一个命令时，最好首先检查下是否有配置文件，然后根据配置文件中的配置来启动系统。永久生效的关键就在于修改这个文件，当我们使用永久生效命令的时候，实际上就是在修改这个配置文件，由于此时并没有重新读取配置文件，所以很多时候我们需要重新启动程序来重新读取配置文件，来使得我们的修改生效，这就是永久生效的原理。
*** 防火墙是什么？防火墙实际上就是一个端口管理器。默认情况下，本地的端口对外是不开放的，这样有利于保护自己的电脑不被不明身份的人攻击，但有时候我们确实需要这种情况，因此就需要一个程序把这些所有的端口管理起来，这就是防火墙了。
*** 使用函数嵌套函数可以非常方便的进行前置处理，后置处理。只要保证参数一致，我们可以非常方便的在不改变函数输入的情况下改变函数的输出。这种流式的状态处理也许就是函数式编程的精髓了。
*** 实际上，对任何工具，我们只需要非常少的拓展就已经可以让那个东西非常好用了，没有必要做很多不必要的拓展。
*** 绝大多数情况下，flex布局方式都是最好的布局方式，没有之一。它可以轻松实现水平方向与垂直方向的左对齐，右对齐，居中对齐。而且写出来的代码简单易读（实际上也只是比其他方式写出来的鸟语稍微简单点而已），也便于维护。
*** 代码编写过程中，续处理的方式实际上只有两种，一种是通过函数参数，一种是通过返回值。
	通过返回值进行续处理的写法类似于proc3(proc2(proc1(args)))，这种写法写出来的代码简单易读，适用于比较简单的情况，但缺陷是函数书写顺序与执行顺序不一致以及不支持异步；
	通过函数参数进行续处理的情况类似于proc1(proc2,args)，这种写法需要将续处理的函数通过函数参数传递给原函数，可读性差点，但这种方式更加的灵活，适合于复杂的情况以及异步的情况。
*** TODO 到底是将UI控件数据保留在控件上比较好，还是使用另外的变量存储起来比较好？将数据保留在控件上，需要的时候再从控件上去取
*** 写小函数有哪些好处呢？
	1) 侵入小。一般加一个功能用函数调用可能只需要在以前代码上加上一句话。
	2) 可读性好。由于已经给一小段代码合理的命了名，读起来就会非常顺畅，不需要去通过看代码实现去猜测这段代码做了什么事情。
	3) 便于拓展与组合。函数是非常灵活的，它可以随意通过参数与返回值进行组合，从而进行续处理。
	4) 非常容易调试，由于代码执行的顺序非常清晰，所以排查起错误来非常容易，不需要大段大段在代码里面去翻找全局变量。
	5) 并发容易，我们可以自由的将某一部分代码分发到其他机器上。
*** 全局变量为什么会造成并发困哪呢?因为全局变量是无法跨越机器的。也就是说，一台机器上的全局变量想在另外一台机器上获取是很难的，因为机器间在通讯的时候是无法感知全局变量的存在的。而函数式编程通过将这些的参数提炼出来，使得我们可以将这些变量传递到其他机器，实现了并发。
*** 实际上，flex布局还有如下一点好处，它可以让我们无需关心容器里面的元素是行内元素还是块级元素，反正都不会换行。这样，当我们设定了父级容器使用flex布局以后，我们可以随心所欲的在里面写任意标签，不用管哪个是行内元素，哪个是块级元素，我这样写会不会换行，这些非常烦人的问题都不在了。它是一种真正的容器布局，只要设定好了父级的布局方式，里面的元素都按照那个规则来排就好了，非常方便。
*** 除了flex这个容器布局以外，实际上，css没有什么像样的容器布局了。常见的容器布局除了flex布局以外就是绝对定位、相对定位、浮动定位布局了，这几种布局方式都有自己的缺陷。
	比如绝对定位需要一个个元素取用坐标定位，绝对定位的遮盖问题也不好解决。
	比如相对定位
*** 没有主角光环，只有场景多少。
** 2016/09/02
*** display:none与visiblily:hidden的区别DDDD前者是不会占据位置的，使用这种方式很可能会引发元素的从排序，从而印象性能；而后者是会占据位置的，不需要进行重排序。所以，一般来说，能用visiblily：hidden就用这个吧。
*** lazy evalation,惰性求值，尽可能的延后计算的时机。
** 2016/09/03
*** 计算机只是个辅助工具，当科技继续发展以后，计算机很可能会被逐渐淡化，人们关注的重心会渐渐向文化与艺术方面倾斜。就像deemo这种游戏一样，计算机只是个载体，内容才是关键。
*** css中，border很容易导致元素的位置发生改变，要慎用。
*** 关于css的样式覆盖问题，有个很重要的原则就是样式权值相同时，写在后面的获胜，与写css的顺序相关，而与写class的顺序无关。
** 2016/09/05
*** 对象是一个哈希表，里面的对象是无序的，这在数据项比较多的时候能够加快对象的访问效率，但是如果数据项比较少的时候，它的访问效率可能还不如使用普通的数组，而且数组的优势在于有序，这能够方便我们的调试。灵活的运用数组，而不是使用哈希表。
*** 关于css属性的继承规则要牢记DDDD大多数的css属性是不能被继承的，比如布局边框之类的，只有少数与字体有关的属性才可以被继承，一旦继承，会一直往下继承，不会只继承一层。但有时候，我们希望一些不能被继承的属性也有用继承特性，这个时候怎么办呢，只需要将需要继承的属性值设置成inherit就可以了。
** 2016/09/06
*** 也许编写代码最重要的原则是"开闭原则"，不要修改之前已经写好的代码,要拓展它。
*** TODO 当点击一个按钮时发出一个事件的这种处理方式真的好吗？
*** 使用一个全局的layers，用来存储当前所有的图层，当左侧的图层事件发生时，遍历所有的图层，找到符合条件的目标图层，对这个图层进行操纵。这实际上是事件派发的基本原理，事件派发的本质是遍历集合，然后对集合中符合条件的元素进行处理。
*** TODO 在进行抽象的时候，如何过滤掉多余的条件，只专注于要解决的问题，同时又不能影响其他部分?
** 2016/09/07
*** TODO 流式处理能够给调试带来巨大的方便，而事件这种处理方式会打破流式处理，给调试带来很大的麻烦。
*** 正则表达式是进行数据验证的神器，文本框控件输入后的第一件事就是数据验证，这些验证中有些直接使用程序验证会比较费劲，比如：
	正整数、日期、电话号码、邮箱、密码强度、中文、身份证号码、IP地址、url地址、文件路径...
	这个时候不妨考虑下正则，往往会有出其不意的效果。
	但是正则表达式也有自己的缺点，比如：
	1) 可读性、可维护性比较差。这就要求我们不能写出很长、很奇葩的的正则表达式，因为后期基本就无法维护了。
	2) 只适合于匹配文本字面，不适合匹配文本意义。比如像匹配整数容易，某个范围的整数就费劲了。
	3) 几乎没有可组合性。
*** 正则表达式的本质不是字符串，而是一个数据结构，这个数据结构叫做NFA（非确定性有限自动机）。正则表达式强行：
	1） 把函数与数据合并到一起
	2） 把几个数据层次合并到一层
	这就使得我们必须对正则里面的很多特殊字符进行转义，几乎没有可组合性。可读性、可维护性因此而大大下降。
*** 随着编程语言的发展，正则表达式这种东西必然会被模式匹配所取代。因为模式匹配将正则表达式的数据转换成了代码。它将正则表达式的精髓“字符匹配”给剥离出来，变成了一种种的模式融合进了代码，使得我们能够根据各种不同的情况进行不同的操作。可读性、可维护性、可组合性因此而大大提升。模式匹配是现代编程语言库函数逐渐成熟的标志之一。
*** "box-sizing:border-box"这个css选项能够将border计算进width、height，能够避免因为添加border引起元素宽高改变导致布局出错的问题，很多情况下，这一方式是比浏览器的默认处理方式更好的处理方式，这一选项应该与"margin:0;padding:0"一样成为所有元素的默认配置。
*** 把正则表达式作为一门语言来进行理解，也许会起到出其不意的效果。普通字符是常量，竖线、中括号就是枚举型，\c这种是提前定义好的枚举型，点是任意字符，其他像^.{}+?都只是匹配模式罢了。
*** 什么是数据类型？数据类型实际上不过是一些值的集合。我们完全可以自己定义一个集合，然后定义我们自己的数据类型。定义数据类型容易，数据类型上面的运算才是真正精髓的东西。
*** websocket是什么?首先说明，websocket与socket并没有半毛钱关系，websocket是与http协议平级的一种通讯协议。它能够实现服务器与客户端的全双工通信，不同于http这种短连接，它是一种长连接，它也没有xhr的同域限制。被公认为ajax的理想替代者。
*** 如果事件太多，那么给它一个命名空间也许是必要的，这样就能减少事件碰撞发生的几率了。但这其实也是一种无奈之举，正确的方法应该是少用事件。
*** 虽然说事件会导致代码跳来跳去，非常难调试，应该尽量少用。但事件也不是一无是处，有个事件不能忽略的优点是它能让你非常轻松的写出符合开闭原则的程序。为什么我们完全不需要知道浏览器的代码就能在它上面进行开发，因为浏览器的事件系统。同样的道理也适合于操作系统。
*** 提供简单统一的抽象接口，然后在接口实现的时候根据不同的类型分别处理，这才是抽象的精髓。
** 2016/09/08
*** 尽可能的避免使用事件，非常难以调试。
*** 关于嵌套div事件的问题，如果点击了内层的div，这个事件对象也会被传递到外层，一直传递到docment，这个时候如果想在哪一层阻止传播，直接使用stopPropagation就可以了。
*** 将所有状态放在单独的一个地方专门管理，然后渲染的时候一个个读这些状态。
** 2016/09/09
*** 绝对不要使用全局变量，因为全局变量哪里都可以修改，你根本无法知道你在哪里修改了这个全局变量，也无法避免别人修改这个全局变量。当你需要使用全局变量的时候，应该改为使用全局函数，然后返回一个局部变量；如果不行，真要使用全局量的话，应该使用全局常量const。
*** 不要将同一份数据复制好多份，因为一旦你复制了，你就需要考虑这几份数据的同步问题，这是一个大坑。
*** 一个变量的作用域过大，就必然难以维护，即使是一个局部变量，如果你将它传来传去，也跟一个全局变量没有什么差别。
*** TODO 当打开任务的时候，我真的有必要将所有的特效与当前打开的特效纪录下来吗？
*** 周会的目的其实在于总结，不在于说干了哪些事。
** 2016/09/11
*** 实际上，call、apply、bind的最大作用是实现数据与代码的组合，我们可以将数据（对象属性）与代码（对象方法）分割成两个部分，然后使用这几个函数将它们串联起来，实现更加精细的控制。
** 2016/09/12
*** 其实在线地图数据制作的流程是非常的复杂的，可以作为复杂数据制作的范本。主要包含下面几个部分：
任务切分与领取、数据编辑与保存、数据检查与提交，在数据编辑的过程中还要考虑各种数据与资料的接入与处理等。
*** 实际上，要想对前端跨域问题有个比较清晰的认识，必须对浏览器与后台交互的各种方法有个比较全面的认识，要彻底理解这个问题，不止要牢记答案，更重要的是理解流程以及基于此流程的变通跨域方案，只有这样才能有个比较清晰的回答。
*** 实际上，前端的面试无非是从深度以及广度的层面上来考验面试者的能力，所以，即使他问你的问题你并不知道答案，也可以说说其他与之相关的问题，如果能够都讲出个所以然来，也是没有问题的。
** 2016/09/13
*** 什么是数据与表现分离?谈到数据与表现分离，有几个绕不开的词就是MVC/MVP/MVVM，这几种开发模式是数据与表现分离的典型例子。具体来说，数据与表现分离指的就是进行数据操作的代码中不能有界面相关的代码，界面相关的代码中不能有数据操作的代码。如何做到这一点呢？首先我们需要分清哪些代码是数据相关的代码，那些是界面相关的代码。在前端，界面相关的代码一般是指操作html与css的代码，数据相关的代码一般是指操作数据的代码。通过将这两部分的代码分离，能够减少这两者之间的相互依赖，这样我们就能独立的修改任一部分而不印象另一部分了，大大降低了开发与维护的难度。
*** 什么叫做web语义化？web语义化，简单来说，就是让机器能够读懂内容。因为随着web规模的不断扩大，让机器能够读懂网页变得越来越重要，这样才能更好的降低机器处理web内容的难度。如何实现web语义化呢？1、我们需要维持简单清晰的网页结构。2、尽可能的多使用html5提供的语义化便签，不要什么都用div。3、使用业界比较通用的表述方法，比如专门用来描述个人信息的vcard格式等。
*** 什么是数据？什么是代码？数据与代码各有什么特性？数据是内容易变的，结构不变的；而代码是内容不变的，结构易变的。代码不断进化的过程就是不断的将公共的结构冒泡成代码，将不变的结构沉淀成数据的过程的。
*** 编码的过程中应该渗透设计模式的思想而不应该是形式。
*** 设计模式实际上就是一种高层的代码抽象，我们使用它抽象出了代码的骨架，然后在下层只需要填充血肉就可以了。
*** 实际上绝大多数的设计模式都有一个特点，就是使用它们写出来的程序是符合“开闭原则”的。比如观察者模式、访问者模式、策略模式、迭代器模式、责任链模式、模板方法模式、解释器模式等等。
*** 实际上，前端的复杂度也许真不是后端可比的，后端实际上说来说去都只是容器、并发这些东西。而前端才真是各种稀奇古怪的情况都要考虑。只不过当前国内的编程形式，前端的整体水平偏低，实际上，前端所需要的抽象能力甚至高于后端。
*** 设计模式实际上是语言无关的，但是当初我学习设计模式的时候是使用面向对象的语言实现的，中间大量运用到了继承，也许什么时候需要用函数式的方法重新实现一遍才能掌握其精髓。
*** flux架构实际上和mvc几乎是是一回事，它也由三部分组成，view、dispatcher、stroe。真要说与mvc有点区别的地方在于它强化了单向数据流的概念，数据由view通过dispatcher流动到store，然后再由stroe发出消息引发view重绘，这样就形成了一个单向的循环，简化了数据流动，提高了代码的可读性、可维护性。
*** flux实际上也是一种界面与表现分离的实现。它在model将数据与回调通过props传进view，在view中进行交互，产生新的数据并将其通过回调传回model继续处理，最后将结果重新同步到view，完成数据流循环。
** 2016/09/16
*** 基本上在所有编程语言中，直接用等号赋值执行的都是浅拷贝，如果被赋值的对象是基本数据类型，那么不会有什么问题，但是如果是引用数据类型，那么原来的值也会跟着改变了，这在很多时候并不是我们说希望的。如何处理这种情况呢？使用深拷贝就好了。
*** 在js中，函数参数实际上就是一个浅拷贝赋值，如果你修改了函数参数中的对象并且这个对象是引用数据类型，那么就很有可能出一些莫名其妙的问题，正确的方法是每当需要修改这种类型时，使用深拷贝复制一份。
*** 实际上赋值仅仅是做浅拷贝很多时候是有缺陷的。如果所有的赋值都是深拷贝，除了浪费内存浪费效率以外，语言本身其实并不会出错，相反能够避免很多问题。
** 2016/09/17
*** 简单数据类型与复杂数据类型在很多时候对同一个操作会有不同的反应，
*** 实际上传统语言的等号赋值实现也许是有问题的，等号赋值并不是修改原有等号数据的值，而是应该将它赋给一个新的值。也就是说，等号赋值有可能会开辟一块新的内存并去修改这块新内存，并不修改老的内存块。
** 2016/09/18
*** 变量命名提升是说使用var声明的变量这一声明会被移动到当前作用域的顶部，这种特性允许我们先使用，后声明，将核心的代码写在前面，写出来的代码可读性比较好。这本来是个不错的特性，但是由于js中if/while/for这种语句块并不会产生新的作用域，导致这种特性配合这些语句的时候很容易出现莫名其妙的错误。实际上更好的办法是将if/while/for等这些语句也实现成一个函数，这样自然就有了自己的作用域，可惜这样会有兼容性问题，所以才有了let。
*** 如果是在文件中，变量命名提升只会提升到文件顶部而不会跨越文件。如果是在函数中，变量命名提升只会提升到函数的顶部。全局范围没有全局作用域这回事，全局范围有很多反常的东西。
*** vue.js也是一个数据双向绑定的组件，它能够把界面上的数据自动同步到模型，免去了程序员自己从界面上读取并将它修改到模型的重复繁琐劳动。
** 2016/09/19
*** 柯里化是将一个函数分解成为多个函数，以便于我们重新组合；还有一种组合函数，就是反柯里化函数，能够将多个函数组合成一个函数，方便于我们调用。值得注意的是，不是任意函数都可以随意组合的，要满足以下条件：
	1) 这些函数都有返回值。
	2) 函数参数个数相等且类型一致。
    反柯里化实际上很简单，只需要将你想组合的函数都放在新函数参数中，然后返回一个新函数依次调用这些函数就好了，如果函数个数不确定，使用reduce来进行抽象就好了。
*** 函数式编程具有强大的可组合性、可拓展性、可维护性。
*** 语句与表达式，语句是没有返回值的，表达式则不一样，表达式是总是有返回值的。js的赋值是有返回值的，所以，js的赋值是表达式而不是语句。
*** 箭头函数是更加优秀的函数，我们应该尽可能的使用箭头函数而不是使用function，正如我们应该尽可能的使用let与const而不是var一样。
*** 实际上js中箭头函数的写法是非常类似于haskell的，可能就是从haskell借用过来的，既然haskell把这种写法作为唯一的函数写法，那么说明这种写法是完全没有问题的，可以投入实际使用的。而且箭头函数相比于传统的function写法写出来的代码更加的简洁，可读性，可组合性都会更好。唯一的障碍就是好多浏览器暂时还不支持箭头函数，这随着时间流逝一点会被逐渐解决的。
** 2016/09/20
*** 不要使用数据，要使用函数充当数据的接口。因为数据是不断的在改变的，使用函数能够使得当数据结构发生改变的时候，我们只需要修改下函数实现，而完全不用动数据接口。这样数据接口不变，所有使用这个数据接口的地方都不会受到影响。
*** 关于css选择器的优先级，常见的css选择器主要有标签选择器、类选择器以及id选择器这三种。这三种选择器的优先级是这么来排序的，id选择器的优先级最高，是100；类选择器的优先级次之，是10，标签选择器的优先级最低，只有1。在编写css的过程中，常常会碰到需要覆盖样式的情况，这时合理的利用这种优先级是非常重要的，尽可能的少用important，因为这样样式就不能被覆盖了。
*** 关于css的样式覆盖，如果你想覆盖某个样式，只有一种途径，提高你想使用的样式的优先级。有两种方法，一种是使用important，直接给那个样式最高的优先级，但这种方法以后想覆盖此样式就不行了，拓展性不好，不推荐使用。还有一种方法是组合css样式，提高你想使用的样式的优先级，这样覆盖问题就解决了。这种方式也是最常被使用的方法。
*** pointer-events设置为none并不会阻止事件继续冒泡，事件会“穿透”元素并向父级传播，不用担心。
** 2016/09/21
*** js的for...in与for...of关联：
	1. for...in既可以遍历数组也可以遍历对象，它遍历出的是“key”，但是遍历出数组的“key”没啥意义，所以for...in一般用于对象遍历。
	2. for...of只能遍历数组，不能遍历对象，它遍历出的是“value”，它不能用来遍历对象，一般用于数组遍历。
*** vue的for有点不同于js的for，它统一使用for...in来进行集合遍历，这有点不同于js的语法，所以在后期版本中，这一点已经得到改善，可以使用for...of，这样就与js的for语法统一了。
*** vue相对于react的改进在于它模块化更加的彻底。react是不能模块化css的，而且react中的html与js是紧密耦合的，但是vue不存在这方面的问题，它将这三部分作为组件的一个整体，这样写出来的代码就更加的规范清晰。
*** 虽然vue相比于react模块化做的更好，但相比于操作dom元素，vue还是不如react简单清晰，这一点是不争的事实。
*** vue与react相比各有优劣，需要根据实际项目需要选择合适的框架。
*** less的嵌套样式是一级一级往下走的，但有的时候我们需要把样式就设置在当前层级，不希望往下，这个时候使用&就可以往上走了。
*** 事实上，使用npm install安装的库是无法通过script标签直接引用的，你必须通过一个额外的打包器，这个打包器可以是webpack，也可以是browerify。使用哪个打包器，就要使用哪个打包器对应的js写法。
*** 实际上，全自动的数据绑定框架很容易遇到性能问题，因为当用户输入很快或者输入的内容很长的时候，有可能数据还来不及同步到模型新的数据修改就来了，这种情况下就需要我们自己手动写同步逻辑了。
*** TODO ui控件往往具有这样一个规律，当这个控件被渲染出来的时候，我们需要同时给这个控件上的元素加上事件处理函数，这实际上相当于在渲染的时候还做了其他的事，也许是不合理的。
*** 通过eval来将代码写在字符串中实际上有个缺陷，就是它可能需要利用到其他函数，但却不持有这个函数的引用，那么就有可能发生函数已经被释放了，它才去调用，这时就会报undefined错误。
*** css的属性选择器支持与非，但是却不支持或选择器。但是这也不是什么大问题，如果我们需要或关系的属性选择器，直接使用逗号就可以了。也就是说，不管是与或非，属性选择器都是支持的，只是或选择器需要通过一定的变通。css选择器还是比较完备的。
*** 代码耦合性太高，乱成一锅粥，就非常容易出现改对了一个东西，却出现另一堆其他的问题，怎么改也改不完，最好的方法就是重写，别无它法，不过重写之前要先理清楚这一堆代码里面莫名其妙的逻辑，写注释也许是一个比较好的里逻辑的方法。
** 2016/09/22
*** 技术的发展必然是由合并到分拆最后再到合并的。因为初期业务规模小，逻辑简单，只需要一个部分就可以完成所有的业务逻辑；随着业务的发展，复杂度越来越高，一个人无法理清所有逻辑，因此分拆是必然之举，分拆之后，每个人专精于某一部分，从而简化了逻辑，使得业务可以继续发展；但业务继续发展之后，业务之间的交互与重叠会带来很高的沟通成本，同时各个子业务此时已经都发展的比较好，每个部分的逻辑已经比较简单，为了业务的继续发展，合并也必然成为趋势，这是事物发展的必然之举。不管是分还是合都是为了适应特定发展阶段的必然之举。
*** 原生js并没有直接清除一个标签内容的方法，但是有个变通的好方法，使用"innerHTML="""就好了。当然，使用innerText也是可以的。
*** 如果不能理解整体逻辑，那么当碰到问题时，必然只能通过特殊处理来解决bug，这是一种非常不好的解bug习惯，非常容易出现解了这个bug，又冒出另一个bug，怎么解都接不完的情况。
*** 在写递归函数的过程中，很多时候我们需要一个变量来记录递归状态，这有可能是为了避免额外的对象生成开销，可能是为了尾递归优化，但是我们又不想使用全局变量，这个时候将这个状态保存在额外的函数参数中往往是最好的选择。
*** 函数参数是一个往往很容易被忽略的领域，参数可以非常复杂，可以把参数设置成非常复杂的对象，然后在将这个对象派发到很多函数中去消化这个特别复杂的参数，js很多时候都是采用的这种技巧。使用非常简单的几个接口函数，然后它可以接受各种格式的配置文件（实际上就是一个特别复杂的参数），然后再慢慢消化这个参数，实现非常简洁的接口。
*** 常用web服务默认端口：
	1. ftp:21
	2. ssh:22
	3. telnet:23
	4. http:80
*** 事实上，主机间最简单的文件复制方法是使用scp命令，这个命令原本用于linux系统间互相复制文件，不过在windows上也不是问题。只要安装个cygwin或者mingw就行了，操作非常简单，完全不需任何额外的配置，秒杀ftp几条街，也难怪ftp现在已经不被大多数linux系统所遗弃，需要额外安装了。使用ftp的优势在于它可以直接检索远程主机的目录树，但其实对于一般的文件复制需求来说，这一点除了在查看时有点用以外一般没什么用，所以抛弃ftp改投scp的怀抱吧。
** 2016/09/23
*** 实际上给git添加忽略文件还是非常简单的，并不需要用额外的编辑器打开编辑.gitignore文件，直接在git文件夹敲入"echo filename >> .gitignore"就可以了（如果是文件夹，需要在最后添加一个"/"）。这个命令会在文件末尾添加一行，如果没有就创建，非常方便。
*** DONE 实际上开关特效就是一个修改数据并重新渲染的过程，需要重新渲染这几个部分：1. 顶栏；2. 全部特效面板3.地图。我们完全可以把这个过程给抽象出来实现复用。这个还可以继续拓展，实际上所有的编辑器都是个这样的过程，它修改的是数据，然后数据修改后需要重新渲染到各个部分。
*** 抽函数还有个好处就是能够很大程度上避免别人换乱修改你的代码。只要你将函数拆分的足够小并配合个清晰的函数名，别人修改这个函数的时候就会去想想代码放在这里是否合适，从而避免别人修改你的代码。
*** 编程过程中非常重要的一条原则是开闭原则，如何使得写出来的代码尽可能的复合这一原则呢？有一个非常重要的技巧就是每当你想修改别人的代码的时候，将你的代码抽成一个函数，然后在别人的代码中调用这个函数，然后将自己的逻辑全部写在这个函数中，这样能够保证基本对别人的代码无侵入（仅有一行修改），所有的新代码都在单独的函数（甚至是单独的文件）中，非常方便与各自调试与拍错，整体逻辑也会非常清晰。
*** 关于向量的点乘与叉乘。点乘是面积，是功，是力在某个方向上的累积，等于abcosa,等于x1x2+y1y2,对应相乘相加；叉乘是法向量，用于三维世界中光照的求解，还可用于二维世界中面积的求解,等于absina，等于x1y2-x2y1，交叉相乘相减，是三阶行列式的首行展开。
*** 实际上数学才是真正的完全剥离出了实际的业务逻辑，而专注于技术方面的求解的技术。站在编程的角度来说，数学是编程世界中抽象的非常好的技术层的东西。
** 2016/09/25
*** 向量是数学计算中的一个强有力的工具，它通过定义什么是向量以及向量之间的变换公式，使得我们能够避开业务细节而只关注于实现，通过一个个向量变换同时夹杂着某些信息，使得我们能够用最小的步骤算出我们自己关注的量，实现问题求解。
*** 巧妙的引入单位向量作为中间量，求解出另一个向量。
*** 探索出一个概念中的元变量是一个非常重要的。通常情况下，它并不是我们所关注的最后结果，但确是最好的中间结果。它通常是某个概念中排除某个变量因子的剩余量，它使我们能够先不考虑这个因子计算剩余的因子，等到需要的时候再将这个因子加入到问题求解中，得到最后的解。例如向量中的单位向量、三维建模中的三角面、编程中的元编程等等。
*** 记笔记也是有迹可循的，怎样写出来的话语比较容易被人理解？通常来说，具有以下这些原则：
	1. 同一句话最好主语不要变，一旦主语改变，就会比较费解。碰到这种情况，应该使用把字句被字句调整下主语或是将这句话放在其他的句子中。
	2. 不要长，通常来说，句子言简意赅是比较理想的。我们应该尽可能的避免说废话、重复的话。
** 2016/09/26
*** 树形结合实际上互为补充的，有些时候数学运算很难解的问题，直接从图形上看却一目了然，有些时候图形上看不出来的东西使用数学计算却可以算出来。
*** d3的data函数会对给定的数据与dom节点已经绑定的数据进行比较，重新分组，然后对各个组进行操作，这就是d3的核心思想。由于节点中绑定的数据没有改变，d3会将所有的dom节点分到update组中，只更新属性，不将元素放到enter集去添加dom节点，导致元素没有绘制出来。解决方法是重新绑定数据。
*** d3有两种绘制模式，一种是修改数据重新绑定到selection然后重绘，一种是直接删除dom节点然后重绘。这两种方式有许多差别，比如：
	1. 前者写起来比较麻烦，而后者写起来比较简单。
	2. 前者会尽可能的减少dom节点的删除与新增，尽量只是简单的修改属性；后者会涉及到dom节点的删除与新增；因此前者的性能大大优于后者。
	3. 前者实现了数据与渲染分离，而后者这两者是杂糅的。
*** d3是以组为单位进行绘制的，但新的子组加入时，如果直接还在原来的组。比较好的办法是在新建一个标签，然后把它作为一个组继续绑定数据，这样两个组就互不影响了。
** 2016/09/27
*** d3的核心思想之一是数据驱动页面，什么意思呢？传统的图形界面程序多是先修改界面，然后再更新数据，这种做法容易出现界面与数据不一致的情况，而且当情况比较复杂的时候也不好处理同步问题。但d3不一样，它是先修改数据，然后再利用数据重新更新界面，这样就能保证数据与界面是一致的，更加有利于界面比较复杂的情况。
*** 数据驱动编程并不是一个新鲜玩意，在老书《Unix编程艺术》中，作者在介绍Unix设计原则时，其中有一条为“表示原则：把知识叠入数据以求逻辑质朴而健壮”。其核心出发点是相对于程序逻辑，人类更擅长于处理数据。数据比程序逻辑更容易驾驭，所以我们应该尽可能的将设计的复杂度从程序代码转移至数据。这条原则早在70年代的软件危机中就得到了印证：凡是执着于逻辑实现的代码最终都难以维护，而将逻辑变化沉淀到数据集中的程序，则撑过了时间的检验。在web开发领域流行20多年的MVC架构，核心也是将数据、表现、操作分离从而降低程序复杂度。JAVA社区多年来就程序设计领域的讨论，翻来覆去也离不开数据驱动这个原则。                                   ――――张迪《理解d3数据驱动的真正含义》
*** TODO 变量、作用域、编程语言、操作系统如何跨越机器？随着编程的不断发展，很多东西发展的本质不过是把多态机器当做一台机器，这个趋势越来越明显了。
*** 事件实际上还有个作用就是将同步代码转化为异步代码，这是事件非常重要的应用之一。很多时候，如果我们预料到一个操作会耗费大量的时间，那么最好直接将这个操作作为一个事件。
** 2016/09/28
*** 实际上全局变量也是一种变相的import/export，不过使用全局变量import/export存在很多缺陷。首先是全局污染问题，其次是依赖关系不清晰，难以管理，最后是无法模块化，不能显示的制定加不加载某个模块。不过全局变量有个优点就是对象树会比较清晰，不过这也不是什么很大的有点，只要保持稳健结构的清晰，对象树自然就会清晰了。
*** 在代码改造的过程中，碰到全局变量的地方应该尽可能的考虑能不能用import/export来替代，一般这个问题的答案都是yes。
*** 如何将同步代码转换为异步代码？使用事件是必须的，通过在函数中封装事件处理函数并将处理函数透出作为函数参数，就可以完成将同步代码转换为异步代码的任务。
	上一节介绍的转换方法需要依赖于事件系统，这种依赖实际上可以继续抽象，抽离出几个状态，然后用
*** 实际上模块加载器的核心依赖于一个数据结构，它就是模块的数据结构（模块对象），主要由这四个部分组成：id（唯一标识）、deps（依赖模块）、factory（自身代码）、status（加载状态），再核心一点，实际上就是维护一个数组，只要维护好了这个数组就实现了模块加载器。
*** 虚拟dom的核心实际上非常类似于模块加载器，它也是依赖于一个非常简单的数据结构（dom元素对象），主要由三部分组成：type（标签类型）、props（属性）、children（子元素）。通过这种数据结构进行嵌套就可以得到dom树，然后引出的问题就是dom diff。dom diff之所以优于直接浏览器重绘的原因在于它能减少不必要的重排版，虽然它实现的语言速度上赶不上浏览器，不过由于它确实减少了大量的运算，所以效率依然优于浏览器重绘。
*** 写程序的时候应该建立起自己的抽象屏障，避免过多的使用别人的接口，这样当别人修改接口的时候，你就不需要动程序的核心逻辑，只需要修改下接口适配就好了。避免代码跨越层次。
*** 实际上dom本来就是一棵树，虚拟dom只不过是从这棵树中抽取了部分我们关注的信息，加入了一些新的信息而已，我们完全可以使用原始的dom进行diff。
*** TODO 配置文件的本质也许也是一颗对象树，将他们使用对象树的思维来写也许是个不错的选择。
*** 尽量少用对象存储信息，多数时候，使用数组是更好的选择，因为使用对象会丢失顺序信息，但是使用数组则不会。
*** 使用对象还是使用数组是一个需要仔细权衡的问题，使用数组实际上相比于使用对象多了顺序信息，数据项较少时，使用数组不管是时间还是空间都会更优，但使用数组的话数据比较又会是个问题。
*** 快捷键需要统一管理、弹窗需要统一管理、渲染需要统一管理、颜色需要统一管理、常量需要统一管理......
*** 不要使用标签选择器，不仅因为标签选择器很容易选择到其他的标签，还因为标签选择器是非常易变的，很有可能你本来是使用div标签，但说不定哪个版本别人说不要换行，你就换成span了，这样你的div选择就失效了。
*** 在进入某个功能的时候先加载它依赖的所有子操作，以便一一显示出来并使用。
** 2016/09/29
*** 除非有自己特殊的理由，否则不要使用label，应该尽量使用span代替label，因为label带有多余的语义，这种多余的语义可能会在你不知情的情况下给程序引入bug。label一般只用于form表单中当你想标签与输入框联动的时候。
*** es6有个特性是增强的对象字面量语法，这个语法允许我们简写对象，简写key，简写kv，这确实时一个非常好用的东西，能够大大方便js代码的编写。
*** es6的各种新特性总结下来实际上都是为了方便js代码的书写，使用了这些新特性之后，确实能少些很多代码，大大提升了js的表达能力。比如变量定义、增强的对象字面量语法、函数语法、解构语法、类支持、模板字符串支持、迭代器、生成器函数等等，这些都使得js好像一门新语言，一门非常强大的工业级语言。
*** 解构语法用于快速从数组或对象中提取值，它能一次提取多个值，就不用我们一个个去做了，实际上就是一个比较弱的模式匹配，不要小看这一改变，它能大大提升js从数组或对象中取数据的能力，简化代码编写,同时可读性也非常的好。
*** 实际上，作用域的概念在编程过程中广泛存在，context（上下文）、模式、module（模块）、scope等这些东西的本质都是作用域。实际上想想也很好理解，如果事情规模比较小，那么把所有的东西都丢在全局也没有什么问题，但是如果规模渐渐变大，必然就要规定事务的边界，在什么时候载入，什么时候卸载，以节约资源、防止冲突。关键的地方在于资源的边界以及释放。
** 2016/09/30
*** 什么是抽象？抽象实际上就是将对数据的直接操作封装成函数，以及对函数继续封装成更简单的函数。抽象能建立起一个屏障防止别人直接对最终的数据进行操作，使得我们能够在动作发生之前对操作进行预先处理，实现更加灵活的处理。
*** git直接在一个分支上开发，如果提交了一次commit想撤销，直接git reset --mixed HEAD^就可以了。不要随便git reset --hard 这样会丢失所有的修改。
*** 关于git checkout 命令，这个命令用来检出，可以检出文件，也可以检出分支。注意，尽量不要使用这个命令检出文件，因为你的开发应该尽可能的基于本地分支而不是远程分支，真的需要恢复时，应该使用git reset命令。
*** 实际上git的本质也只不过是多分支一数组而已。你的修改总是基于一个分支，然后这个分支有一个提交数组，这个数组维持着提交列表，提供撤销与重做，允许多人同时修改这个数组。它通过一个统一的数组将所有修改管理起来了，使得修改可以回溯以及回放。
*** 实际上分支的设计是git非常好的设计，这也许是它强于svn的最根本性的原因之一。它相当于是对代码的一次备份，允许我们在修改出错时方便的回滚到任意版本。传统的svn由于没有分支的概念，往往只能通过拷贝实现分支，这样建当代码很多的时候建分支、切换分支的成本就会非常的高，而且分支合并起来非常的痛苦，但是git没有这个问题，它建分支基本没有什么硬盘开销，合并起来很多时候也是自动的，非常方便。
*** 要理解git的分布式版本控制系统的意义。绝大多数时候，我们并不需要直接操作远程分支，我们只需要操作自己本地的分支，然后需要的时候将这个分支同步到远程就完成了版本控制。比如建立分支、分支修改、分支合并、分支删除等，所有的操作都是现在本地发生，然后被提交到远程的。
*** 注意git的删除远程分支的用法git push origin :branch-name，这个用法的语法来自于git push [远程名] [本地分支]:[远程分支]，相当于推送一个空分支到远程，自然就是删除这个远程分支了。
*** TODO 如何使得css样式也变得可复用，如何进行样式抽象？
