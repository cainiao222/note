** 2016/09/01
*** centos7使用了firewalld来管理防火墙，借助这个命令提供的firewall-cmd命令，我们可以非常轻松的管理防火墙，非常方便。
*** 使用firewall-cmd来管理防火墙时，如果只是简简单单的添加一条规则，并不需要重启防火墙，但是如果是永久增加规则，则需要重启防火墙。
*** 我们不妨来想想让一个命令永久生效的实现方法。很简单，当我们开启一个命令时，最好首先检查下是否有配置文件，然后根据配置文件中的配置来启动系统。永久生效的关键就在于修改这个文件，当我们使用永久生效命令的时候，实际上就是在修改这个配置文件，由于此时并没有重新读取配置文件，所以很多时候我们需要重新启动程序来重新读取配置文件，来使得我们的修改生效，这就是永久生效的原理。
*** 防火墙是什么？防火墙实际上就是一个端口管理器。默认情况下，本地的端口对外是不开放的，这样有利于保护自己的电脑不被不明身份的人攻击，但有时候我们确实需要这种情况，因此就需要一个程序把这些所有的端口管理起来，这就是防火墙了。
** 2016/09/12
*** 其实在线地图数据制作的流程是非常的复杂的，可以作为复杂数据制作的范本。主要包含下面几个部分：
任务切分与领取、数据编辑与保存、数据检查与提交，在数据编辑的过程中还要考虑各种数据与资料的接入与处理等。
*** 实际上，要想对前端跨域问题有个比较清晰的认识，必须对浏览器与后台交互的各种方法有个比较全面的认识，要彻底理解这个问题，不止要牢记答案，更重要的是理解流程以及基于此流程的变通跨域方案，只有这样才能有个比较清晰的回答。
*** 实际上，前端的面试无非是从深度以及广度的层面上来考验面试者的能力，所以，即使他问你的问题你并不知道答案，也可以说说其他与之相关的问题，如果能够都讲出个所以然来，也是没有问题的。
*** 使用函数嵌套函数可以非常方便的进行前置处理，后置处理。只要保证参数一致，我们可以非常方便的在不改变函数输入的情况下改变函数的输出。这种流式的状态处理也许就是函数式编程的精髓了。
*** 实际上，对任何工具，我们只需要非常少的拓展就已经可以让那个东西非常好用了，没有必要做很多不必要的拓展。
*** 绝大多数情况下，flex布局方式都是最好的布局方式，没有之一。它可以轻松实现水平方向与垂直方向的左对齐，右对齐，居中对齐。而且写出来的代码简单易读（实际上也只是比其他方式写出来的鸟语稍微简单点而已），也便于维护。
*** 代码编写过程中，续处理的方式实际上只有两种，一种是通过函数参数，一种是通过返回值。
	通过返回值进行续处理的写法类似于proc3(proc2(proc1(args)))，这种写法写出来的代码简单易读，适用于比较简单的情况，但缺陷是函数书写顺序与执行顺序不一致以及不支持异步；
	通过函数参数进行续处理的情况类似于proc1(proc2,args)，这种写法需要将续处理的函数通过函数参数传递给原函数，可读性差点，但这种方式更加的灵活，适合于复杂的情况以及异步的情况。
*** TODO 到底是将UI控件数据保留在控件上比较好，还是使用另外的变量存储起来比较好？将数据保留在控件上，需要的时候再从控件上去取
*** 写小函数有哪些好处呢？
	1) 侵入小。一般加一个功能用函数调用可能只需要在以前代码上加上一句话。
	2) 可读性好。由于已经给一小段代码合理的命了名，读起来就会非常顺畅，不需要去通过看代码实现去猜测这段代码做了什么事情。
	3) 便于拓展与组合。函数是非常灵活的，它可以随意通过参数与返回值进行组合，从而进行续处理。
	4) 非常容易调试，由于代码执行的顺序非常清晰，所以排查起错误来非常容易，不需要大段大段在代码里面去翻找全局变量。
	5) 并发容易，我们可以自由的将某一部分代码分发到其他机器上。
*** 全局变量为什么会造成并发困哪呢?因为全局变量是无法跨越机器的。也就是说，一台机器上的全局变量想在另外一台机器上获取是很难的，因为机器间在通讯的时候是无法感知全局变量的存在的。而函数式编程通过将这些的参数提炼出来，使得我们可以将这些变量传递到其他机器，实现了并发。
*** 实际上，flex布局还有如下一点好处，它可以让我们无需关心容器里面的元素是行内元素还是块级元素，反正都不会换行。这样，当我们设定了父级容器使用flex布局以后，我们可以随心所欲的在里面写任意标签，不用管哪个是行内元素，哪个是块级元素，我这样写会不会换行，这些非常烦人的问题都不在了。它是一种真正的容器布局，只要设定好了父级的布局方式，里面的元素都按照那个规则来排就好了，非常方便。
*** 除了flex这个容器布局以外，实际上，css没有什么像样的容器布局了。常见的容器布局除了flex布局以外就是绝对定位、相对定位、浮动定位布局了，这几种布局方式都有自己的缺陷。
	比如绝对定位需要一个个元素取用坐标定位，绝对定位的遮盖问题也不好解决。
	比如相对定位
*** 没有主角光环，只有场景多少。
** 2016/09/02
*** display:none与visiblily:hidden的区别――――前者是不会占据位置的，使用这种方式很可能会引发元素的从排序，从而印象性能；而后者是会占据位置的，不需要进行重排序。所以，一般来说，能用visiblily：hidden就用这个吧。
*** lazy evalation,惰性求值，尽可能的延后计算的时机。
** 2016/09/03
*** 计算机只是个辅助工具，当科技继续发展以后，计算机很可能会被逐渐淡化，人们关注的重心会渐渐向文化与艺术方面倾斜。就像deemo这种游戏一样，计算机只是个载体，内容才是关键。
*** css中，border很容易导致元素的位置发生改变，要慎用。
*** 关于css的样式覆盖问题，有个很重要的原则就是样式权值相同时，写在后面的获胜，与写css的顺序相关，而与写class的顺序无关。
** 2016/09/05
*** 对象是一个哈希表，里面的对象是无序的，这在数据项比较多的时候能够加快对象的访问效率，但是如果数据项比较少的时候，它的访问效率可能还不如使用普通的数组，而且数组的优势在于有序，这能够方便我们的调试。灵活的运用数组，而不是使用哈希表。
*** 关于css属性的继承规则要牢记――――大多数的css属性是不能被继承的，比如布局边框之类的，只有少数与字体有关的属性才可以被继承，一旦继承，会一直往下继承，不会只继承一层。但有时候，我们希望一些不能被继承的属性也有用继承特性，这个时候怎么办呢，只需要将需要继承的属性值设置成inherit就可以了。
** 2016/09/06
*** 也许编写代码最重要的原则是"开闭原则"，不要修改之前已经写好的代码,要拓展它。
*** TODO 当点击一个按钮时发出一个事件的这种处理方式真的好吗？
*** 使用一个全局的layers，用来存储当前所有的图层，当左侧的图层事件发生时，遍历所有的图层，找到符合条件的目标图层，对这个图层进行操纵。这实际上是事件派发的基本原理，事件派发的本质是遍历集合，然后对集合中符合条件的元素进行处理。
*** TODO 在进行抽象的时候，如何过滤掉多余的条件，只专注于要解决的问题，同时又不能影响其他部分?
** 2016/09/07
*** TODO 流式处理能够给调试带来巨大的方便，而事件这种处理方式会打破流式处理，给调试带来很大的麻烦。
*** 正则表达式是进行数据验证的神器，文本框控件输入后的第一件事就是数据验证，这些验证中有些直接使用程序验证会比较费劲，比如：
	正整数、日期、电话号码、邮箱、密码强度、中文、身份证号码、IP地址、url地址、文件路径...
	这个时候不妨考虑下正则，往往会有出其不意的效果。
	但是正则表达式也有自己的缺点，比如：
	1) 可读性、可维护性比较差。这就要求我们不能写出很长、很奇葩的的正则表达式，因为后期基本就无法维护了。
	2) 只适合于匹配文本字面，不适合匹配文本意义。比如像匹配整数容易，某个范围的整数就费劲了。
	3) 几乎没有可组合性。
*** 正则表达式的本质不是字符串，而是一个数据结构，这个数据结构叫做NFA（非确定性有限自动机）。正则表达式强行：
	1） 把函数与数据合并到一起
	2） 把几个数据层次合并到一层
	这就使得我们必须对正则里面的很多特殊字符进行转义，几乎没有可组合性。可读性、可维护性因此而大大下降。
*** 随着编程语言的发展，正则表达式这种东西必然会被模式匹配所取代。因为模式匹配将正则表达式的数据转换成了代码。它将正则表达式的精髓“字符匹配”给剥离出来，变成了一种种的模式融合进了代码，使得我们能够根据各种不同的情况进行不同的操作。可读性、可维护性、可组合性因此而大大提升。模式匹配是现代编程语言库函数逐渐成熟的标志之一。
*** "box-sizing:border-box"这个css选项能够将border计算进width、height，能够避免因为添加border引起元素宽高改变导致布局出错的问题，很多情况下，这一方式是比浏览器的默认处理方式更好的处理方式，这一选项应该与"margin:0;padding:0"一样成为所有元素的默认配置。
*** 把正则表达式作为一门语言来进行理解，也许会起到出其不意的效果。普通字符是常量，竖线、中括号就是枚举型，\c这种是提前定义好的枚举型，点是任意字符，其他像^.{}+?都只是匹配模式罢了。
*** 什么是数据类型？数据类型实际上不过是一些值的集合。我们完全可以自己定义一个集合，然后定义我们自己的数据类型。定义数据类型容易，数据类型上面的运算才是真正精髓的东西。
*** websocket是什么?首先说明，websocket与socket并没有半毛钱关系，websocket是与http协议平级的一种通讯协议。它能够实现服务器与客户端的全双工通信，不同于http这种短连接，它是一种长连接，它也没有xhr的同域限制。被公认为ajax的理想替代者。
*** 如果事件太多，那么给它一个命名空间也许是必要的，这样就能减少事件碰撞发生的几率了。但这其实也是一种无奈之举，正确的方法应该是少用事件。
*** 虽然说事件会导致代码跳来跳去，非常难调试，应该尽量少用。但事件也不是一无是处，有个事件不能忽略的优点是它能让你非常轻松的写出符合开闭原则的程序。为什么我们完全不需要知道浏览器的代码就能在它上面进行开发，因为浏览器的事件系统。同样的道理也适合于操作系统。
*** 提供简单统一的抽象接口，然后在接口实现的时候根据不同的类型分别处理，这才是抽象的精髓。
** 2016/09/08
*** 尽可能的避免使用事件，非常难以调试。
*** 关于嵌套div事件的问题，如果点击了内层的div，这个事件对象也会被传递到外层，一直传递到docment，这个时候如果想在哪一层阻止传播，直接使用stopPropagation就可以了。
*** 将所有状态放在单独的一个地方专门管理，然后渲染的时候一个个读这些状态。
** 2016/09/09
*** 绝对不要使用全局变量，因为全局变量哪里都可以修改，你根本无法知道你在哪里修改了这个全局变量，也无法避免别人修改这个全局变量。当你需要使用全局变量的时候，应该改为使用全局函数，然后返回一个局部变量；如果不行，真要使用全局量的话，应该使用全局常量const。
*** 不要将同一份数据复制好多份，因为一旦你复制了，你就需要考虑这几份数据的同步问题，这是一个大坑。
*** 一个变量的作用域过大，就必然难以维护，即使是一个局部变量，如果你将它传来传去，也跟一个全局变量没有什么差别。
*** TODO 当打开任务的时候，我真的有必要将所有的特效与当前打开的特效纪录下来吗？
** 2016/09/11
*** 实际上，call、apply、bind的最大作用是实现数据与代码的组合，我们可以将数据（对象属性）与代码（对象方法）分割成两个部分，然后使用这几个函数将它们串联起来，实现更加精细的控制。
