** 2016/09/01
*** centos7使用了firewalld来管理防火墙，借助这个命令提供的firewall-cmd命令，我们可以非常轻松的管理防火墙，非常方便。
*** 使用firewall-cmd来管理防火墙时，如果只是简简单单的添加一条规则，并不需要重启防火墙，但是如果是永久增加规则，则需要重启防火墙。
*** 我们不妨来想想让一个命令永久生效的实现方法。很简单，当我们开启一个命令时，最好首先检查下是否有配置文件，然后根据配置文件中的配置来启动系统。永久生效的关键就在于修改这个文件，当我们使用永久生效命令的时候，实际上就是在修改这个配置文件，由于此时并没有重新读取配置文件，所以很多时候我们需要重新启动程序来重新读取配置文件，来使得我们的修改生效，这就是永久生效的原理。
*** 防火墙是什么？防火墙实际上就是一个端口管理器。默认情况下，本地的端口对外是不开放的，这样有利于保护自己的电脑不被不明身份的人攻击，但有时候我们确实需要这种情况，因此就需要一个程序把这些所有的端口管理起来，这就是防火墙了。
*** 使用函数嵌套函数可以非常方便的进行前置处理，后置处理。只要保证参数一致，我们可以非常方便的在不改变函数输入的情况下改变函数的输出。这种流式的状态处理也许就是函数式编程的精髓了。
*** 实际上，对任何工具，我们只需要非常少的拓展就已经可以让那个东西非常好用了，没有必要做很多不必要的拓展。
*** 绝大多数情况下，flex布局方式都是最好的布局方式，没有之一。它可以轻松实现水平方向与垂直方向的左对齐，右对齐，居中对齐。而且写出来的代码简单易读（实际上也只是比其他方式写出来的鸟语稍微简单点而已），也便于维护。
*** 代码编写过程中，续处理的方式实际上只有两种，一种是通过函数参数，一种是通过返回值。
	通过返回值进行续处理的写法类似于proc3(proc2(proc1(args)))，这种写法写出来的代码简单易读，适用于比较简单的情况，但缺陷是函数书写顺序与执行顺序不一致以及不支持异步；
	通过函数参数进行续处理的情况类似于proc1(proc2,args)，这种写法需要将续处理的函数通过函数参数传递给原函数，可读性差点，但这种方式更加的灵活，适合于复杂的情况以及异步的情况。
*** TODO 到底是将UI控件数据保留在控件上比较好，还是使用另外的变量存储起来比较好？将数据保留在控件上，需要的时候再从控件上去取
*** 写小函数有哪些好处呢？
	1) 侵入小。一般加一个功能用函数调用可能只需要在以前代码上加上一句话。
	2) 可读性好。由于已经给一小段代码合理的命了名，读起来就会非常顺畅，不需要去通过看代码实现去猜测这段代码做了什么事情。
	3) 便于拓展与组合。函数是非常灵活的，它可以随意通过参数与返回值进行组合，从而进行续处理。
	4) 非常容易调试，由于代码执行的顺序非常清晰，所以排查起错误来非常容易，不需要大段大段在代码里面去翻找全局变量。
	5) 并发容易，我们可以自由的将某一部分代码分发到其他机器上。
*** 全局变量为什么会造成并发困哪呢?因为全局变量是无法跨越机器的。也就是说，一台机器上的全局变量想在另外一台机器上获取是很难的，因为机器间在通讯的时候是无法感知全局变量的存在的。而函数式编程通过将这些的参数提炼出来，使得我们可以将这些变量传递到其他机器，实现了并发。
*** 实际上，flex布局还有如下一点好处，它可以让我们无需关心容器里面的元素是行内元素还是块级元素，反正都不会换行。这样，当我们设定了父级容器使用flex布局以后，我们可以随心所欲的在里面写任意标签，不用管哪个是行内元素，哪个是块级元素，我这样写会不会换行，这些非常烦人的问题都不在了。它是一种真正的容器布局，只要设定好了父级的布局方式，里面的元素都按照那个规则来排就好了，非常方便。
*** 除了flex这个容器布局以外，实际上，css没有什么像样的容器布局了。常见的容器布局除了flex布局以外就是绝对定位、相对定位、浮动定位布局了，这几种布局方式都有自己的缺陷。
	比如绝对定位需要一个个元素取用坐标定位，绝对定位的遮盖问题也不好解决。
	比如相对定位
*** 没有主角光环，只有场景多少。
** 2016/09/02
*** display:none与visiblily:hidden的区别――――前者是不会占据位置的，使用这种方式很可能会引发元素的从排序，从而印象性能；而后者是会占据位置的，不需要进行重排序。所以，一般来说，能用visiblily：hidden就用这个吧。
*** lazy evalation,惰性求值，尽可能的延后计算的时机。
** 2016/09/03
*** 计算机只是个辅助工具，当科技继续发展以后，计算机很可能会被逐渐淡化，人们关注的重心会渐渐向文化与艺术方面倾斜。就像deemo这种游戏一样，计算机只是个载体，内容才是关键。
*** css中，border很容易导致元素的位置发生改变，要慎用。
*** 关于css的样式覆盖问题，有个很重要的原则就是样式权值相同时，写在后面的获胜，与写css的顺序相关，而与写class的顺序无关。
** 2016/09/05
*** 对象是一个哈希表，里面的对象是无序的，这在数据项比较多的时候能够加快对象的访问效率，但是如果数据项比较少的时候，它的访问效率可能还不如使用普通的数组，而且数组的优势在于有序，这能够方便我们的调试。灵活的运用数组，而不是使用哈希表。
*** 关于css属性的继承规则要牢记――――大多数的css属性是不能被继承的，比如布局边框之类的，只有少数与字体有关的属性才可以被继承，一旦继承，会一直往下继承，不会只继承一层。但有时候，我们希望一些不能被继承的属性也有用继承特性，这个时候怎么办呢，只需要将需要继承的属性值设置成inherit就可以了。
** 2016/09/06
*** 也许编写代码最重要的原则是"开闭原则"，不要修改之前已经写好的代码,要拓展它。
*** TODO 当点击一个按钮时发出一个事件的这种处理方式真的好吗？
*** 使用一个全局的layers，用来存储当前所有的图层，当左侧的图层事件发生时，遍历所有的图层，找到符合条件的目标图层，对这个图层进行操纵。这实际上是事件派发的基本原理，事件派发的本质是遍历集合，然后对集合中符合条件的元素进行处理。
*** TODO 在进行抽象的时候，如何过滤掉多余的条件，只专注于要解决的问题，同时又不能影响其他部分?
** 2016/09/07
*** TODO 流式处理能够给调试带来巨大的方便，而事件这种处理方式会打破流式处理，给调试带来很大的麻烦。
*** 正则表达式是进行数据验证的神器，文本框控件输入后的第一件事就是数据验证，这些验证中有些直接使用程序验证会比较费劲，比如：
	正整数、日期、电话号码、邮箱、密码强度、中文、身份证号码、IP地址、url地址、文件路径...
	这个时候不妨考虑下正则，往往会有出其不意的效果。
	但是正则表达式也有自己的缺点，比如：
	1) 可读性、可维护性比较差。这就要求我们不能写出很长、很奇葩的的正则表达式，因为后期基本就无法维护了。
	2) 只适合于匹配文本字面，不适合匹配文本意义。比如像匹配整数容易，某个范围的整数就费劲了。
	3) 几乎没有可组合性。
*** 正则表达式的本质不是字符串，而是一个数据结构，这个数据结构叫做NFA（非确定性有限自动机）。正则表达式强行：
	1） 把函数与数据合并到一起
	2） 把几个数据层次合并到一层
	这就使得我们必须对正则里面的很多特殊字符进行转义，几乎没有可组合性。可读性、可维护性因此而大大下降。
*** 随着编程语言的发展，正则表达式这种东西必然会被模式匹配所取代。因为模式匹配将正则表达式的数据转换成了代码。它将正则表达式的精髓“字符匹配”给剥离出来，变成了一种种的模式融合进了代码，使得我们能够根据各种不同的情况进行不同的操作。可读性、可维护性、可组合性因此而大大提升。模式匹配是现代编程语言库函数逐渐成熟的标志之一。
*** "box-sizing:border-box"这个css选项能够将border计算进width、height，能够避免因为添加border引起元素宽高改变导致布局出错的问题，很多情况下，这一方式是比浏览器的默认处理方式更好的处理方式，这一选项应该与"margin:0;padding:0"一样成为所有元素的默认配置。
*** 把正则表达式作为一门语言来进行理解，也许会起到出其不意的效果。普通字符是常量，竖线、中括号就是枚举型，\c这种是提前定义好的枚举型，点是任意字符，其他像^.{}+?都只是匹配模式罢了。
*** 什么是数据类型？数据类型实际上不过是一些值的集合。我们完全可以自己定义一个集合，然后定义我们自己的数据类型。定义数据类型容易，数据类型上面的运算才是真正精髓的东西。
*** websocket是什么?首先说明，websocket与socket并没有半毛钱关系，websocket是与http协议平级的一种通讯协议。它能够实现服务器与客户端的全双工通信，不同于http这种短连接，它是一种长连接，它也没有xhr的同域限制。被公认为ajax的理想替代者。
*** 如果事件太多，那么给它一个命名空间也许是必要的，这样就能减少事件碰撞发生的几率了。但这其实也是一种无奈之举，正确的方法应该是少用事件。
*** 虽然说事件会导致代码跳来跳去，非常难调试，应该尽量少用。但事件也不是一无是处，有个事件不能忽略的优点是它能让你非常轻松的写出符合开闭原则的程序。为什么我们完全不需要知道浏览器的代码就能在它上面进行开发，因为浏览器的事件系统。同样的道理也适合于操作系统。
*** 提供简单统一的抽象接口，然后在接口实现的时候根据不同的类型分别处理，这才是抽象的精髓。
** 2016/09/08
*** 尽可能的避免使用事件，非常难以调试。
*** 关于嵌套div事件的问题，如果点击了内层的div，这个事件对象也会被传递到外层，一直传递到docment，这个时候如果想在哪一层阻止传播，直接使用stopPropagation就可以了。
*** 将所有状态放在单独的一个地方专门管理，然后渲染的时候一个个读这些状态。
** 2016/09/09
*** 绝对不要使用全局变量，因为全局变量哪里都可以修改，你根本无法知道你在哪里修改了这个全局变量，也无法避免别人修改这个全局变量。当你需要使用全局变量的时候，应该改为使用全局函数，然后返回一个局部变量；如果不行，真要使用全局量的话，应该使用全局常量const。
*** 不要将同一份数据复制好多份，因为一旦你复制了，你就需要考虑这几份数据的同步问题，这是一个大坑。
*** 一个变量的作用域过大，就必然难以维护，即使是一个局部变量，如果你将它传来传去，也跟一个全局变量没有什么差别。
*** TODO 当打开任务的时候，我真的有必要将所有的特效与当前打开的特效纪录下来吗？
*** 周会的目的其实在于总结，不在于说干了哪些事。
** 2016/09/11
*** 实际上，call、apply、bind的最大作用是实现数据与代码的组合，我们可以将数据（对象属性）与代码（对象方法）分割成两个部分，然后使用这几个函数将它们串联起来，实现更加精细的控制。
** 2016/09/12
*** 其实在线地图数据制作的流程是非常的复杂的，可以作为复杂数据制作的范本。主要包含下面几个部分：
任务切分与领取、数据编辑与保存、数据检查与提交，在数据编辑的过程中还要考虑各种数据与资料的接入与处理等。
*** 实际上，要想对前端跨域问题有个比较清晰的认识，必须对浏览器与后台交互的各种方法有个比较全面的认识，要彻底理解这个问题，不止要牢记答案，更重要的是理解流程以及基于此流程的变通跨域方案，只有这样才能有个比较清晰的回答。
*** 实际上，前端的面试无非是从深度以及广度的层面上来考验面试者的能力，所以，即使他问你的问题你并不知道答案，也可以说说其他与之相关的问题，如果能够都讲出个所以然来，也是没有问题的。
** 2016/09/13
*** 什么是数据与表现分离?谈到数据与表现分离，有几个绕不开的词就是MVC/MVP/MVVM，这几种开发模式是数据与表现分离的典型例子。具体来说，数据与表现分离指的就是进行数据操作的代码中不能有界面相关的代码，界面相关的代码中不能有数据操作的代码。如何做到这一点呢？首先我们需要分清哪些代码是数据相关的代码，那些是界面相关的代码。在前端，界面相关的代码一般是指操作html与css的代码，数据相关的代码一般是指操作数据的代码。通过将这两部分的代码分离，能够减少这两者之间的相互依赖，这样我们就能独立的修改任一部分而不印象另一部分了，大大降低了开发与维护的难度。
*** 什么叫做web语义化？web语义化，简单来说，就是让机器能够读懂内容。因为随着web规模的不断扩大，让机器能够读懂网页变得越来越重要，这样才能更好的降低机器处理web内容的难度。如何实现web语义化呢？1、我们需要维持简单清晰的网页结构。2、尽可能的多使用html5提供的语义化便签，不要什么都用div。3、使用业界比较通用的表述方法，比如专门用来描述个人信息的vcard格式等。
*** 什么是数据？什么是代码？数据与代码各有什么特性？数据是内容易变的，结构不变的；而代码是内容不变的，结构易变的。代码不断进化的过程就是不断的将公共的结构冒泡成代码，将不变的结构沉淀成数据的过程的。
*** 编码的过程中应该渗透设计模式的思想而不应该是形式。
*** 设计模式实际上就是一种高层的代码抽象，我们使用它抽象出了代码的骨架，然后在下层只需要填充血肉就可以了。
*** 实际上绝大多数的设计模式都有一个特点，就是使用它们写出来的程序是符合“开闭原则”的。比如观察者模式、访问者模式、策略模式、迭代器模式、责任链模式、模板方法模式、解释器模式等等。
*** 实际上，前端的复杂度也许真不是后端可比的，后端实际上说来说去都只是容器、并发这些东西。而前端才真是各种稀奇古怪的情况都要考虑。只不过当前国内的编程形式，前端的整体水平偏低，实际上，前端所需要的抽象能力甚至高于后端。
*** 设计模式实际上是语言无关的，但是当初我学习设计模式的时候是使用面向对象的语言实现的，中间大量运用到了继承，也许什么时候需要用函数式的方法重新实现一遍才能掌握其精髓。
*** flux架构实际上和mvc几乎是是一回事，它也由三部分组成，view、dispatcher、stroe。真要说与mvc有点区别的地方在于它强化了单向数据流的概念，数据由view通过dispatcher流动到store，然后再由stroe发出消息引发view重绘，这样就形成了一个单向的循环，简化了数据流动，提高了代码的可读性、可维护性。
*** flux实际上也是一种界面与表现分离的实现。它在model将数据与回调通过props传进view，在view中进行交互，产生新的数据并将其通过回调传回model继续处理，最后将结果重新同步到view，完成数据流循环。
** 2016/09/16
*** 基本上在所有编程语言中，直接用等号赋值执行的都是浅拷贝，如果被赋值的对象是基本数据类型，那么不会有什么问题，但是如果是引用数据类型，那么原来的值也会跟着改变了，这在很多时候并不是我们说希望的。如何处理这种情况呢？使用深拷贝就好了。
*** 在js中，函数参数实际上就是一个浅拷贝赋值，如果你修改了函数参数中的对象并且这个对象是引用数据类型，那么就很有可能出一些莫名其妙的问题，正确的方法是每当需要修改这种类型时，使用深拷贝复制一份。
*** 实际上赋值仅仅是做浅拷贝很多时候是有缺陷的。如果所有的赋值都是深拷贝，除了浪费内存浪费效率以外，语言本身其实并不会出错，相反能够避免很多问题。
** 2016/09/17
*** 简单数据类型与复杂数据类型在很多时候对同一个操作会有不同的反应，
*** 实际上传统语言的等号赋值实现也许是有问题的，等号赋值并不是修改原有等号数据的值，而是应该将它赋给一个新的值。也就是说，等号赋值有可能会开辟一块新的内存并去修改这块新内存，并不修改老的内存块。
** 2016/09/18
*** 变量命名提升是说使用var声明的变量这一声明会被移动到当前作用域的顶部，这种特性允许我们先使用，后声明，将核心的代码写在前面，写出来的代码可读性比较好。这本来是个不错的特性，但是由于js中if/while/for这种语句块并不会产生新的作用域，导致这种特性配合这些语句的时候很容易出现莫名其妙的错误。实际上更好的办法是将if/while/for等这些语句也实现成一个函数，这样自然就有了自己的作用域，可惜这样会有兼容性问题，所以才有了let。
*** 如果是在文件中，变量命名提升只会提升到文件顶部而不会跨越文件。如果是在函数中，变量命名提升只会提升到函数的顶部。全局范围没有全局作用域这回事，全局范围有很多反常的东西。
*** vue.js也是一个数据双向绑定的组件，它能够把界面上的数据自动同步到模型，免去了程序员自己从界面上读取并将它修改到模型的重复繁琐劳动。
** 2016/09/19
*** 柯里化是将一个函数分解成为多个函数，以便于我们重新组合；还有一种组合函数，就是反柯里化函数，能够将多个函数组合成一个函数，方便于我们调用。值得注意的是，不是任意函数都可以随意组合的，要满足以下条件：
	1) 这些函数都有返回值。
	2) 函数参数个数相等且类型一致。
    反柯里化实际上很简单，只需要将你想组合的函数都放在新函数参数中，然后返回一个新函数依次调用这些函数就好了，如果函数个数不确定，使用reduce来进行抽象就好了。
*** 函数式编程具有强大的可组合性、可拓展性、可维护性。
*** 语句与表达式，语句是没有返回值的，表达式则不一样，表达式是总是有返回值的。js的赋值是有返回值的，所以，js的赋值是表达式而不是语句。
*** 箭头函数是更加优秀的函数，我们应该尽可能的使用箭头函数而不是使用function，正如我们应该尽可能的使用let与const而不是var一样。
*** 实际上js中箭头函数的写法是非常类似于haskell的，可能就是从haskell借用过来的，既然haskell把这种写法作为唯一的函数写法，那么说明这种写法是完全没有问题的，可以投入实际使用的。而且箭头函数相比于传统的function写法写出来的代码更加的简洁，可读性，可组合性都会更好。唯一的障碍就是好多浏览器暂时还不支持箭头函数，这随着时间流逝一点会被逐渐解决的。
