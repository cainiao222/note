* 2017/11
** 2017/11/07
*** 关于webpack的循环引用问题。循环引用有两种情况：
	+ a依赖b，b依赖a，这样的话当b调用a中的方法时，由于a此时尚未引入完毕，b就会找不到a中的引用，这样会出现未定义的问题。
	+ a依赖b，b依赖c，c依赖a，这种情况下也是一样，由于c会调用a中的方法，而此时a尚未加载完毕，所以也会报未定义的问题。
	如何解决这一问题呢？
	
** 2017/11/08
*** TIPS 封装确实是一个极其强大的抽象手段，提供单一的入口，我们只需要修改这个入口的实现，就可以修改所有使用这个入口的地方的功能，实现特定的定制需求。
*** 关于vue的mixin，首先要明白，mixin是继承的一种，只不过不统一类继承的接口继承，mixin是实现继承，它是一个拷贝。在vue中，mixin就是一个简版的组件，一般是“无头”（无UI）的，我们可以使用mixin来实现一些通用的操作，然后将这些东西通过mixin的形式添加进组件。
*** vue没有提供如类继承那样的接口继承，我们只能通过mixin来实现拷贝继承。但实际上要想实现接口继承也容易，我们只需要通过类似于prototype那样使用一个新的对象持有vue组件对象的引用，然后先调用本对象的方法，找不到就去引用里面找方法，这样就是先了引用继承。
** 2017/11/09
*** TIPS apache2.4 rewrite与proxy配置：
	1. rewrite
	   + 打开mod_rewrite
	   + 配置directory
	   + 修改权限AllowOverride All
	2. proxy
	   + 打开mod_proxy,mod_proxy_http
	   + 打开httpd-vhosts.conf
	   + 配置VirtualHost与ProxyPass/ProxyPassMatch/ProxyReverse
** 2017/11/10
*** 关于联调，前期环境准备必须一致：
	+ host必须先统一对好，特别是passport,因为每一方都需要走passport鉴权，任何一方passport不一致就必然会报错。
** 2017/11/13
*** 关于js的undefined，这个东西是js独有的，在跨语言的时候会有问题，比如转成json时undefined字段会被过滤掉，而null不会有这个问题，同样的，undefined不能被后端语言（比如java）解析。使用的时候要注意。
*** TIPS 把凡是复杂的地方抽象成一个函数，从函数的视角来考虑这个问题。多数情况下，这个问题将会得到很好的抽象与重新封装。
*** TODO 布隆过滤器
** 2017/11/16
*** 关于css class的命名，有两种方式，一种是以名称命名，一种是以功能命名。以名称命名是为了标识某个元素是什么，比如vip-header,vip-footer等，便于为特定的部分添加自定义样式；以功能命名是为了复用，比如：btn,btn-primary等。与函数命名十分类似，这两种命名方式应该结合起来使用，外层使用名称命名，提供清晰的接口，内层使用功能命名，提高复用性。
*** TIPS css中，哪些样式写在里面，哪些样式写在外面，是非常重要的。应该遵循这样的规则，将样式相关的部分写在里面，便于复用，将位置相关的部分写在外面，便于布局。也就是说，将paint的样式与flow的样式分开写是非常必要的，能够提高代码质量。
*** TIPS 水平居中的两种主流方法，一是使用margin: auto,能够将block的元素使用margin居中，它只是让元素内容看起来好像居中了，实际上元素还是占据着整行，没有空出来地方。还有一种是text-align，它可不仅仅是用来使div中的内容居中，还能使inline-block的元素居中，在这种用法下，它才是让元素真正居中了，空出的地方可以用来放其他的东西。也正是因为这点不同，导致这两种居中方式在使用上有点轻微的差异：
	1. 前者是使用在子元素上的，后者是用在父元素上的。
	2. 前者只能够居中一个元素，后者能够使几个元素一起居中。
** 2017/11/17
*** html中，button元素的样式可定制性还是挺强的，没有复选框样式修改的这些那些限制。
*** TIPS 实际上jsx就是一个函数，既然是函数，自然就可以赋值给其他变量，这个变量可以被其他的jsx引用，相当于一次函数调用，我们可以使用props将数据传进去，使用callback的props将数据传出来，实现数据管理。
** 2017/11/18
*** 关于css的垂直居中，除了position:absolute；top:50%、flex布局以外，还有一个很有用的方法，vertical-align：center。使用它时要注意，要将父元素的布局设为table，子元素设置为table-cell才有效，通过这种方法，我们能够实现整块元素垂直居中。
*** TIPS 关于background-size有个坑爹的bug，就是它必须放在background-image后面，如果写错了放在了前面，会失效。
*** TIPS 要实现一个圆形按钮实际上非常简单，设置好宽高以后将border-radius设置成宽高的一半就可以了，这样一个完美的圆形按钮就出来了。有一点需要注意，使用border-radius处理之后，在角的边上（矩形之内）点击时是不会被算成点击事件的，不需要开发去关心误触发。
*** 在vue的单文件组件中，其实最简单情况下我们只需要写template就可以了，script标签部分与style标签部分实际上都是可以不写的，不会有任何报错，不过为了便于修改，即使没有也最好写一个空的标签。值得注意的是，script标签不能完全留空，如果写了，需要至少export default一个空对象才行。
** 2017/11/20
*** 什么时候用margin，什么时候用padding？一般来说，优先用margin，但是有些情况下，比如需要将border显示出来，这个时候用区别就出来了，margin是在border外面的，padding是在border里面的，如果我们需要在border外显示一段空白，这个时候应该用margin，反之用padding。
*** 领取流程：
	1) 
*** 一般需要管理的数据才需要被放到类的成员变量中（vue的组件可以看成是一个类），其他一次性的数据不应该放到成员中，会加大类的复杂度。
*** TIPS VUE组件中的data到底应该放接口中的数据还是UI的数据？答案是放UI中的数据。因为如果放接口中的数据，我们就只能将UI的数据放在computed中，这样实现双向绑定就很麻烦了，因为我们需要自己写很多的get/set，数据逻辑被写的很散，很难维护；而如果将这些逻辑放在钩子函数中，data中只放UI的数据，这样双向绑定就可以比较顺畅了。还有一点需要注意，不应该将过多的UI数据放在data中，应该只放最基本的ui数据，有些可以推到出的ui数据应该被转移到computed中，这样我们只需要设置基本的data数据，computed数据就自动正确同步了。
*** 将所有this有关的操作（特别是set操作）集中在有限的几个函数里，而不是到处乱用是个很不错的主意，因为这样能尽可能的缩小副作用的范围。
** 2017/11/21
*** 我们经常碰到需要根据两个变量的状态来决定最终状态的情况，这种情形常用的解法是一个一个判断，但这样容易遗漏而且写出来的代码可读性很差，更好的方法是把两个状态合在一起来判断，这样代码的可读性与可维护性都会大大提升。
*** TODO 并不能乱用await，这样会使得异步代码有变成了同步代码，大大降低代码效率与用户体验。
*** 复杂项目总util如何设计呢？应该以功能命名而不是模块，以功能命名用起来才更加容易，因为人总是要使用到某个功能才去想是不是有这个方法的。
*** TODO 区分UI data与Logic data。
** 2017/11/22
*** TODO 关于接口的设计，如何设计一个优秀的接口呢？首先返回值应该遵循固定的格式，比较好的格式如下：
#+BEGIN_SRC javascript
{
	code: "", // "A000000","A000001","B000000","B000001"
	msg: "", // error msg
	data: {
		//...
	}
}
#+END_SRC
	这是最基本的要求，然后应该用统一的格式区分成功、各种错误状态以及描述，这部分也应该统一处理，可读性和可维护性才会比较好，前后端都比较轻松。
*** css div的margin叠加大多数时候并没有什么问题，但有些情况下我们不希望叠加，而是希望相加，这个时候将div设置成inline-block的，然后设置div的宽度使得一行放不下，然后使用margin，这个时候margin就不会发生叠加了。
** 2017/11/23
*** TIPS 如何使得一个div总是成一个正方形呢？无需css3的新技巧，通过伪元素就可以了，形如width:xxx; padding-top:x%或者height:xxx; padding-left: x%。通过这一技巧，你不止可以做一个正方向，你还可以做任意比例的div，因为百分比布局是相对于父元素的宽高的，而伪元素的父元素正好就是元素本身。
*** 关于显示图片的时候是使用img标签还是div加background-image的问题。两者主要的区别在于div可以提前占位，但div有个问题就是需要多设置一次宽高，无法像img一样直接动态宽高。
*** TIPS 关于git pull需要注意，它只会拉取当前分支的远程分支内容更新到当前分支，并不会拉取更新所有分支，所以如果你想merge远程的某个分支，你需要先切到本地的那个分支，然后先git pull一下，再切到想要合并进的分支，然后在git merge，这样这个分支就被更新成远程的另外分支了。
*** 关于html中css的命名实际上也是很讲究的，我们不应该把实现带进html中，比如style样式，黑白颜色等，应该把这些样式分个类并站在用户的角度命名，这样才比较好阅读和维护。
*** TIPS 关于程序的命名问题实际上很简单，站在用户的角度命名就可以了。这一核心原则又可以分为两个方面，一个是对于系统外的用户，他们不了解系统，只能使用块命名，这样便于查找；而对于系统内的用户，他们是程序员，他们关注的是重用，这个时候就应该用功能命名了。需要注意的是，即使是对于系统内用户（开发）而言，如果他没有接触过某个模块（或者虽然是他写的但时间长忘了），他依然属于系统外用户，这时也应该使用块来命名。
*** 什么是网络代理？代理就是代码请求，使用代理机器的环境（包括host等）进行网络请求并返回结果。或者说所有网络请求都会跑到代理机器上去，这样就可以用本地的环境模拟线上了。
*** TODO 如何统一处理错误？首先没有一个统一的数据结构，处理起来会困难重重。错误code的问题需要统一处理。使用统一的数据结构，前后端使用不同范围的错误码。前后端统一错误码，甚至集团统一错误码是非常有意义的。
*** 能够将纷繁复杂的状态抽象成一个枚举是一种非常重要的能力，比如常用的按钮类型、日志类型、card类型等等，正式因为枚举的引入大大简化了记忆开销，方便了使用与维护。
** 2017/11/24
*** IMPORTANT 如何写出优秀的css？要特别注意树形结构，同一个层级的内容不能过多，应该分成有限的几块，然后再在块内细分。每个应该让人一看就知道这一块代表哪一个部分，然后一层一层的去查找想改的内容。
*** 关于vue模板中prop="xxx"与:prop="xxx"的区别，前者是一个字符串，会被直接传入到子组件，而后者是一个表达式，会被计算后传入到子组件，一般会引用到组件中的数据；一个是数据，一个是代码。
*** 以前，我只要看到代码重复就会把这个重复提出来，但后来我发现这样代码是写得短了，但可读性却并不好，因为有不少不知干啥用的工具函数。后来我学乖了，不能乱提工具函数，提取的时候要始终保持接口简单，不然还不如不提。
** 2017/11/25
*** 关于纯渲染组件：不要在纯渲染组件中进行事件处理，应该把这个事件抛出来给外部，然后在外部处理。秉承数据的来源在哪里，就在哪里管理的原则，这样组件的数据流会比较清晰。
** 2017/11/27
*** 写css的class有个很有用的技巧，对于性质类似却有着自己特性的几个元素，使用两段式写法，第一段为这一类元素定一个类型，写公共属性，第二段为这几个元素的特性定一个类型，写特殊属性。这样写出来的class可读性又好又短还便于拓展。
** 2017/11/28
*** 数据在哪里获得就在哪里维护
** 2017/11/29
*** git实际上只是提供了分支这种工作方式，至于具体怎么使用，建立哪些分支这些需要开发人员自己去处理解决。
*** 只支持请求拦截，不支持函数拦截。
** 2017/11/30
*** 每多一个接口，就多出三种状态，呈指数型增长。
** 2017/12/04
*** 关于git的分支工作方式，有一个很大的主分支（master），然后由这个分支分成三个小主分支(dev、test、online)，这种分支为流程服务。然后每个小主分支分成更小的分支，为开发人员或者是需求服务，所有的提交都只能在最小的分支上进行，然后通过合并（merge）的方式更新到主分支，以此演进，推动开发任务的完成。
