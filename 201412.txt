﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿* 2014/12
** 2014/12/01
*** 关于MFC的自定义消息，其实就是生成了2组函数，先声明并定义自己的函数，再在消息映射上把自己的函数跟补充上去，这样，当消息发生的时候（也就是接受到PostMessage时）,MFC就能将函数调用给转移到自定义的函数上面去了。实际上这与Qt的信号槽没有什么不同，不过就是Qt的更加灵活一点罢了。
*** 将函数查找也用自己的工具给管理起来，快速定位到自己的函数。写一个搜索工具，来快速定位自己想要使用的函数与函数库。自己的代码段管理器。
*** 团队开发如何进行，非常重要的一点就是先各自给出自己的接口。即使不实现，也要互相知道各自的接口，这一点在一个人需要使用另一个人的东西时格外的重要。
*** 其实编程语言也是一个函数库，与其他的函数库相比没有什么不同，语言中不提供的功能，可以自己去给它添加。虽然这样可能会造成语言整体语法的不一致，但也是没办法的事。
*** 两种定义枚举变量的方式：
    (1) enum MyType{STATE1,STATE2,STATE3};
    (2) #define STATE1 1
        #define STATE2 2
        #define STATE3 3
        typedef unsigned char MyType;
这两种方式各有自己的优缺点，前者优势在于简单，对于类型只有几种比较简单的情况而且不怎么会变的时候比较好用，而且可以让人对可取的值一目了然，但缺乏拓展性，增加新状态比较麻烦。后者的优缺点正好与前者相反。
*** 关于include包含文件的顺序，先包含尖括号的，再包含双引号的。因为尖括号的往往为系统库文件，而双引号的往往为自定义的头文件，这样能防止库覆盖。
*** 不与别人讨论，靠自己的理解做出来的东西，也许其本质是最好的，但如果不符合别人的预期，别人依旧会说你的不是。所以，客户认为好才是真的好，这就是为别人做东西跟为自己做东西的不同。
** 2014/12/03
*** 让程序在结束时另外开启一个程序，这个程序的作用就是对当前程序作出一些修改，然后重新启动程序。这是一种使得对程序的任何修改成为可能的一种方法。通过这种方法，可以使程序在运行过程中动态修改程序的结构，使得传统静态语言编写的程序也能拥有动态语言的特性。因为程序已结束，此时就是一个普通的文件，所以你可以任意读写修个此文件，当修改完毕后，如果文件依旧是正确的可执行文件格式，那么重启此程序也不会有什么困难。
*** 以只读的方式可以打开任何一个文件，不管这个文件当前是否已经处于被打开状态。以读写的方式不能打开已经处于读写状态的文件，因为两个进程同时对一个文件写入，前面的写入会被覆盖。
*** 库工程（不论动态库还是静态库）中的函数或变量如果只声明而不定义的话，生成库时会直接忽略此声明。使用某个库时如果某个函数定义找不到（这种情况只可能是依赖其他库），不管这个函数使不使用，函数在链接时都会报链接错误。
pp租车 共享经济
听云 传感器
拉勾网 帮助选择
趣分期 互联网金融，个人金融个人信用体系
传统企业始终无法具备最先进的想法与理念，最好的实现自我价值的方式就是进入新兴企业。

** 2014/12/09
*** 为什么需要序列化与反序列化？实际上是为了跨平台跨语言跨架构下传输数据。如果无需顾及这些，那么根本没必要进行序列化与反序列化，直接传输对象二进制流就ok了。这样省去了这两个过程，效率大大提升，而且避免了序列化与反序列化可能出现的bug。所以，记住，直接传输对象的二进制流可以大大简化流程，提升效率。
*** 文本协议与二进制协议。文本协议实际上只利用到了编码空间中很少的一部分，因为它实际上只是利用到了256里面的96个可打印字符，很多情况下实际上只有大小写英文字母与有限的几个标点符号，实际上只是用了不到七十个字符，也就是只利用了四分之一左右的编码空间。所以，如果利用到了所有的编码空间，至少可以把长度压缩为四分之一。
*** 在循环中不要随便使用continue，因为你一旦使用了这东西有可能使得下面所有的代码得不到执行的机会，但其实下面的代码此时还没写，可能有些代码即使失败仍要执行。比较好的方法是使用if(...)...而不是if(!...)continue;...
** 2014/12/10
*** 关于代码的乱与清之道——改动可能性比较小的部分代码可以比较杂乱，但经常需要改动的部分代码务必要清晰。并不是说要所有的代码都很清晰，那是理想的情况，实际情况是没有那么充足的时间。应该尽可能地话最少的时间做最多的事。不要太拘泥于小节，但大事不能马虎。
** 2014/12/11
*** TODO 把函数的地址存起来，自己管理函数，自己接管函数调用，一切都可以自己做主。自己处理参数的压栈出栈，自己管理函数调用规则，实现自己的语言。
*** TODO 自己用汇编实现自己的函数调用。
*** 最开始是从业务逻辑抽象，渐渐的这种表层的简单抽象已无法满足代码复杂性的需求，需要从茫茫多的函数中抽象出一些公共的，进场被调用的代码段变成公用函数。渐渐的就成为了逻辑层下面的功能层。
*** 常见的三层架构就简简单单地把软件分成了表现层，业务层，数据访问层。跟核心业务打交道的这部分软件核心只有薄薄的一层，实际上是一种非常粗粒度的分层模型。实际的情况中至少应该把业务层再细分成两层。业务层与功能层。可能很多业务经常要使用相同的功能，将他们分隔开可以减少代码重复。同时，还有很多经常要调用的函数需要使用缓存机制来降低反复执行的性能开销。应该将部分执行结果存放到一个公共的区域中来管理，这样就成了一个与前面的业务层与功能层垂直的并行结构。这两种细分估计就是复杂软件所要努力解决的问题了吧。
*** 如何避免代码的重复出现？使用函数是一个方法，使用循环也是一个方法，但这两种方法有什么区别呢？为什么有的东西可以用函数抽象，而有的东西又只能用循环来抽象呢？这两种抽象方式有什么不同，又有什么联系呢？区别就在于循环适用于重复的代码呈现出上下关系，而函数适用于重复的代码呈现出分布式出现的规律。然后使用函数抽象会在这些地方留下一个函数的影子，几处就有几个地方，而循环抽象可以使得出现几次的情况变得只出现一次。这两种抽象方法的共同之处就在于只要分离出数据，就可以抽象出共同的代码，但同时都有一个缺陷就是如果代码不一样，比如说调用功能相似但名字不同的函数，无论使用哪种方法来抽象，都是无法抽象出来的，因为函数无法抽象。总之，要记住以下的原则，如果重复出现的代码只有数据不同，如果这些代码紧挨着，应该使用循环，如果这些代码分布在各处，应该使用函数。
*** 多态其实最重要的作用是作为抽象函数的手段，正是因为它抽象函数的本质，所以其不可缺少。但作为一种简简单单的抽象手段，它还需要抽象出类来支持这一抽象，再通过类的函数调用来显示出这种抽象，绕了两道弯子，所以并不是一种合适的抽象手段，需要使用另一种的抽象机制来解决抽象函数这一问题。而动态语言可以直接使用同样的函数名来作为抽象函数的手段，解决方法就稍微好了一点，但其实即使是一般的动态语言，也无法摆脱实现抽象函数需要引入额外的类这一限制，所以虽然比静态语言好点，也并不是一种最好的解决方案。真正的解决方案应该是直接将函数也当成是数据，使得抽象函数与抽象数据变成本质上一样的东西。在这一点上，lisp是做的最好的。
*** 其实使用回调函数也是一种抽象代码的手段。回调函数是如何解决将代码抽象的问题的呢？因为它允许将函数作为数据，其实也就是函数指针，函数指针本来就是一种将代码作为数据的机制，通过使用函数指针，能够将相似但不同的函数名再做一次抽象，这样就实现了数据也可抽象，代码也可抽象。但也仅限于简单的函数名可以抽象而已。如果代码片段中一部分很相似，可以抽象，而另一部分这完全无规律可循，在这种情况下，函数指针也会无能为力，这时，宏，特别是lisp的宏发挥威力的时候就来了。
*** TODO 如何使用lisp来抽象函数是一个比较有意思的问题。
*** 与其说是lisp不区分数据与代码倒不如说lisp根本就没有数据与代码的概念，一切都是符号演算。一切都可以抽象成符号演算。lisp正是凭借其无语伦比的抽象能力，才使得这门语言这么多年过去了，一直活跃在编程语言领域的前沿。
*** 实际上，三种基本的控制结构，面向函数，面向类，面向对象，面向架构，面向服务等等所有技术都只是一种抽象的手段而已。抽象才是编程的本质。才是事物化繁为简的本质。所有的知识其实都是通过抽象获得的，抽象才是世界进步的钥匙。
编程的能力实际上就是抽象的能力，你的抽象思维的能力越强，编程的能力相应的也越高。
*** 要实现一门编程语言，其实首先是要抽象出一些基本的工具，然后语言的用户就可以使用这些基本的工具继续抽象出更多的东西来做自己想做的事。
*** 其实，输入法是非常接近与语音识别的实现原理的，只有得到了一个词就可以预测出下一个词，这种逐词预测就是语音识别的核心原理所在。
*** 关注事物的暗面往往比关注事物的明面容易得到更多的东西，很多事物的重大突破基本都是在暗面获得的。
*** 永远没有绝对的真理，因为抽象之路绝不会有尽头。
其实面向类并不等于面向对象。面向对象是一种很正确的编程思想。面向类只是这种思想的一种实现，而且是一种不怎么优美的实现。各种编程语言都实现了面向对象，但各种编程语言的具体实现都不尽相同。
** 2014/12/12
*** 很多事物发展的规律都是指数性增长，前期会比较艰难，发展缓慢，但一旦基础的条件都具备以后，就会飞速发展，挡都挡不住。当发展到饱和后，发展会减缓，但依然会继续发展到超饱和状态，然后缓慢回落，再到飞速回落。这就是事物的发展规律，呈现出余弦曲线。这给予我们的其实是首先我们要尽量选择处在曲线前四分之一的行业，努力寻找已经基本具备了基本条件但是尚未被充分开掘的领域。努力积累，相信前途是光明的，努力充实自己，积累还缺失的部分，由量变转为质变。当发展到已经饱和的时候，要激流勇退，不要看着依然有钱可赚就继续死撑。继续寻找曲线前四分之一的行业，继续进步，始终处在时代前列。
*** TODO 软件复杂以后，重复计算会变成一个很突出的问题，缓存系统在这时候变得越来越重要，如何设计一个缓存系统？
*** 调用系统api与自己实现api的区别：系统实现的api可能很多时候可以使用到并没有被公开的信息，系统能够使用这些信息来优化api实现，而自己手写只能自己来算这些信息。这就导致系统api多数情况下效率高于自己手动实现的api。当然，也有可能是低于的。比如系统有些时候为了api通用性的考虑会做很多额外的工作，而自己的写的api可能就没有这些东西了，由于做的事更少，所以效率更高。其实只要理解了系统api质量往往比较可靠就行了，没必要纠结于效率。
*** placement new是一个神器。你可以先分配好一大块内存，然后在这块内存上构造各种对象，自己管理这一块内存，避免反复开辟释放内存的开销。实际上就是自己实现了一个内存池。rapidxml之所以比tinyxml块一个数量级就是因为使用了内存池技术。
** 2014/12/16
*** 关于软件项目的划分有两种主要的方式，按照模块划分与按照功能划分。在实际的开发中，其实前期主要是按照模块来搭架子，后期才是按照功能来在一个个模块上来配合实现功能。前期主要是要打通模块之间的通信技术，后期主要要确定的是通信的规范。
*** 消息映射是MFC发明的东西，不是windows系统的。你不用消息映射照样可以使用windows api来完成这些事。消息映射将特定的消息与特定的函数给记录下来，然后发生消息的时候调用构造函数，这就是其核心原理。这种机制的好处是效率高，但缺陷也十分明显。不能在运行过程中修改消息映射，只是一个静态的消息数组而已，无法在运行过程中修改。
*** 学习知识并不是直接接受就行了的，还要对学习的知识进行提炼加工，然后才能把知识学习清楚。因为学习本来就是一点一滴慢慢积累的，这些零碎的知识小点如果不经过一遍整理的话就会像一个堆杂物的房间一样，这样的存储结构你还指望能够得心应手的使用这些知识吗？所以，在学习的时候要多问问自己这个东西的本质是什么，这种提问会引发自己的思考，这些思考会渐渐的引导你进行深入思考，渐渐摸清知识的根源。
** 2014/12/17
*** TODO switch-case这种控制语句就如同旧时代的goto语句一样，随意使用这种结构会使得代码结构混乱，非常难以维护。相对好点的解决方法一是使用查表法，不过这种方法的缺陷就是每添加一种情况就要添加表项，这也是一种累赘。还有使用多态也许也可以。还有可能可以的解决方案——命令模式。
** 2014/12/18
*** 从SendMessage的函数声明就可以看出，消息实际上是windows窗口间用来通信的机制。特别要注意第一个参数类型是HWND，不是HANDLE,HMODULE,更不是其他乱七八糟的类型。所以，消息只能发送给窗口，不能发送给其他东西，比如控制台。控制台程序就不是windows窗口程序，没有窗口句柄这个东西，虽然vs给你虚拟了一个控制台窗口，但这个窗口不是属于控制台程序的。即使你在控制台程序里面加入了GetMessage这样的代码依然是无用的。
*** 实际上代码就是由数据与函数组成的，一旦你发现自己写的代码拥有了写好后依然可以添加类（数据）与函数的能力，那么，这个程序就离成为语言不远了。
*** TODO 把自己的工具函数，不再使用头文件来管理函数，使用自己编写的工具来遍历所有的函数，查找函数代码。
*** 其实写代码遵循深入浅出的概念。拿到问题后，先深入，将问题转化为自己内部使用的用来处理信息的数据，然后再浅出，重新隐藏这些数据，将计算的结果给返回给对方，完成处理。
** 2014/12/19
*** 函数的取名应该做到见名知意，不要因为参数类型与参数名已经标示了部分意思就不在函数名上表示出来。因为别人往往只记得函数名而不记得参数的类型与参数名。只有这样才能使得函数更易于使用。
*** 实际上句柄与对象可以认为是一回事。句柄即对象，对象即句柄，它们只是两种不同的管理资源的方法而已。因为windows是使用c语言编写的，而c语言是不带类的，也就是没有对象的。但是使用一种方式来标示一种资源这种需求客观存在，于是句柄应运而生。使用句柄给所有的对象一个编号，然后你可以任意拓展给这个对象哪些方法，这种方式就获得了比面向类更精确的控制与更强大的灵活性。可以说面向句柄的资源管理是绝对优于面向对象的。
*** 在编程中不管是采用哪种编程方法，面向过程，面向对象，面向服务，面向架构等等。你始终要寻找一种能够集中管理数据，集中管理代码的方法，只要有了这种方法，不管你采用什么技术，都是无关紧要的。
*** 面向类与面向对象实际上不是一回事，实际上这两个概念差别非常大，不要搞混了。类实例化才成为了对象，一个类可以有很多个对象。面向类管理的是这许许多多个对象，这些对象结构相同但数据不同。而面向对象管理的是一个个对象，直接管理类下面实际的某一个资源，可以获得更精细，更灵活的控制。在面向类里面，方法是针对具体类的，无法获得更细致的控制。但面向对象，方法是针对于具体的对象的。可以根据对象值的不同定制不同的方法，确实是非常诱人的。
*** windows使用句柄来管理对象，为每个对象编个编号，然后可以使用很多共享的方法来操作这些对象资源。这是一种很灵活的资源管理方式。同时，句柄被设计为进程相关的。这就使得随意修改其他进程的内核对象变得不是那么容易，从而保证了系统的稳定性。
*** 编程真的是一个技术活，技巧性非常强，非常吸引人，是值得为之奋斗一生的事业。
*** windows使用句柄来管理资源，而linux使用文件描述符来管理资源。这是两种不同的管理资源的方式。
*** 使用线程时，线程与函数的关系要搞清楚。到底是将函数写在线程里面还是线程里面调用函数，这是一个非常值得探讨的问题。如果一个函数要管理很多线程，那么最好将创建线程写在函数里面。而如果一个线程要管理很多函数，那么最好还是先创建线程，再在线程函数里面管理这些函数，这样就能最大限度的发挥线程的作用。
*** 如何在非主线程（窗口线程）中使用窗口资源，有一个非常好的方法就是在主线程创建子线程的时候将主线程的this指针或窗口句柄也给传递过来。这样就可以通过这个参数访问到主线程中所有的东西了。
*** 要记住，内核对象是进程中的全量，是可以在所有线程中共享的。也就是说，凡是拥有句柄的东西要非常敏感地知道——这个资源是肯定是有办法在所有线程间共享的。所以，一旦看到在线程间传递了内核对象，就要很明显地知道这必定是多余的。
** 2014/12/21
*** 服务化的好处：
1、人人都可以用。
2、没有开启进程线程得时间开销。
3、特定的事可以只交给一个人来做，提升了代码的质量与效率。
缺陷是：
1、部署困难。
2、需要强大的网络和IO支持。
*** 数据类型可以是一个很大的限制，但同时也可以是一个强大的工具。使用好了这个工具不仅可以使编写出来的代码整齐划一，效率更强，也非常有利于程序的差错。同样的道理也适用于函数式编程。
** 2014/12/22
*** 生活如果仅仅只是赚钱的话没什么意思，要把更多的精力放在实现自己的人生理想上，多做自己想做的事。
*** 实际上人的记忆结构跟文件系统很像。如果你使用重复记忆的死记硬背的方式，那么这部分数据会被存储在临时文件里，你的大脑会容量有限，会定期清理缓存，这部分数据很快会被删除掉，这种记忆方式记忆的又慢又容易遗忘。但如果你使用关联记忆，就相当于给记忆归了个类，建立了个文件夹，这样就能记忆的又快又持久了。比如记忆“凯美佳国际会议中心”，只需记住凯美佳，依然不好记，但是如果你联想到爱情公寓里面的美嘉，你瞬间就记住了。再比如你记忆141,474这两个公交车号，你只需记住首尾一致，四七呼唤就好了。在总结下，人的记忆其实很像多重继承，是一种从下往上的总结结构，一次次的总结归类，记忆越来越小，越来越趋于牢固，所以要多对知识进行梳理。
*** 做自己喜欢做的事，而不是大众喜欢做的事。
*** 判断代码质量的标准有一个很简单的方法——看代码重复的部分，凡是重复的代码，不管是在同一个函数还是不同的函数，都是应该被杜绝的。
** 2014/12/23
*** 实际上，实数（包括整数与浮点数）与字符串相比也就少占空间，便于计算的优点而已。如果一个实数无需计算，不关心大小，只需传输中转的时候（这种情况很常见）直接用字符串表示这种数据会更好些。
*** 很多时候你只是光想会觉得很困难，但是如果你尝试着去做就会发现其实并不是你想象中的那么难。因为人的思维能力是有限的，不能一次适应过多的变数，但是如果你动手实际去做，就能慢慢减少这些变数，然后做起来就容易很多了。同时，你在渐渐做的过程中，会发现自己的思维能力也会跟着提高，因为你做熟练了之后会发现某些变数变得不再是变数了。
*** 加减乘除这四种运算实际上都是表示一种事物之间关系处理的方式。加法表示将两种性质相同的东西放在一起，减法则与加法相反，表示从相同的东西里面剥离出一部分出来。乘法表示将两种完全不同的东西放在一起，由于这两者之间是完全没有关系的正交关系，对应于事物A的每一种情况，都对应于事物B的所有情况，这就表示相乘。除法则表示从由两个正交关系组成的集合中去掉某一事物，仅保留另一事物的集合。加减乘除正式这样将大千世界的事物联系在了一起。使用加减乘除来处理数据，既有了函数，又有了代码，可以直接看成是一种语言。人们往往很容易理解加减，而难以理解乘除。其实乘除的力量远远超出你的想象。如果会使用，那么直接就可以使用一句话表示很多很多东西了。
*** lisp的设计初衷——将世间的万事万物都看成是list，也就是数据，使用car,cdr来遍历数据元素。list的第一个atom称之为操作符，也就是代码，使用代码来对所有的数据进行处理。这样就构建了一个完成的运算系统。
*** 如何成为一门语言——只要有数据以及代码就足够了。使用代码来表示操作，使用数据来表示操作的对象。这两者互相正交变化，就成为了一门语言。那字符串处理来说吧，字符串本身就是一个字符的集合，你需要对这一堆字符来进行处理，就需要在这个集合上定义一堆操作，比如你需要一个合并集合的+操作，需要一个获取特定元素的nth操作。。。但操作符不能随便定义，要有层次结构的定义，首先定义几个最基本的操作，再使用这几个基本的操作进行正交组合，实现复杂的东西，这样慢慢下来，一整套的语言就出来了。
** 2014/12/24
*** 电脑的思维方式与人脑的思维方式是不一样的。电脑的思维方式更接近于查表法。它是通过将同一类信息的很多对象保存在一个集合（可以是数组，队列，链表，哈希等），然后从中取出指定对象来进行运算，运算后更新集合的方式来进行工作的。而人脑的思维方式就复杂很多了。人更擅长于做划分，人有很多经验性的快速搜索方案，这些都是计算机很难做到的。
*** WM_QUIT实际上是退出消息循环，这样程序就能继续往消息循环下面走，进而退出程序了。
*** 关于程序的拓展性问题，如何实现高拓展性？很简单，留出足够的接口就行了，然后别人通过这些接口获取足够的信息处理并设置进软件，这样就实现了高拓展性。使用什么语言来拓展无关紧要，关键是要留出获取软件信息以及设置这些信息的方法。
** 2014/12/25
*** 其实最简单的实现软件高拓展性的方法是使用文件，将重要的信息保存在文件里面，别人就可以通过以任意语言操纵此文件来实现拓展软件的功能。
** 2014/12/26
*** 何为命运？命运其实只不过是事物运行的规律。如果你按照某种方式去做，那么未来必然就是那样的。至于具体的规律是啥，其实易经中已经说的非常清楚了，简而言之就是因果循环，注意不是因果报应。因果之间啊并不总是报应，好的因也会有好的果。特别要注意这其中有一种非常特殊的情况，被经常拿来用于小说，文学 ，影视等的创作，这种就是传说，天命一类的东西。其实这种情况只是一种很长年代的因果而已，前人种下了因，然后由后人来结果。这谓之命运，预言，传说实现。
** 2014/12/28
*** 如何产生很尖锐的矛盾冲突，有一个很简单的方法就是反过来演，正派人物演成反派，反派人物演成正派。
*** 其实个人整体时局的影响真的很有限，不要总以为世界只是围着你一个人在转的，当你跳出小我，现在大我的角度上看得时候，你就能够很容易的看懂很多问题了。
*** 不断的循环，高潮低谷，高潮低谷，整体的高潮低谷，部分的高潮低谷，一个个串起来，再互相嵌套。。。这就是生活。
*** 由多个人的命运来互相推动，这就是整体的命运。一个人对整体的影响终究有限，由几个关键人的命运决定整体的命运，也就是大命运。
** 2014/12/29
*** 思维的层次要高一点，这样思考起很多问题来会变得简单很多。
*** 我想追求最先进的技术。云只是一个非常有前景的方向，但未必就是我所喜欢的方向。我想找一个与语言无关，但会用到方方面面最先进技术的编程技术的工作，这样的工作在哪里？不再希望对代码质量的要求只是一个自己的玩物，自己费尽心思想的高级代码不再只是一个只有自己看得见的精美雕塑。
无论你爱或不爱，你已经走在命运提前为你安排好的道路上了。你既然是一个喜欢追求技术极限的人，你就会不断的走在这条道路上，无论你想还是不想。只有你自己可以看见自己的人生，也只有而且必须你来为自己的人生轨迹负责。
无论你所处在的环境需不需要你自己不断向前，你自己都需要鞭策自己向前。因为你自己如果不向前，就会被那些需要努力向前的人超越。
这年头想找一个与自己真心相对的朋友好难，但你必须用心来观察，先是你自己拿出百分百的真心来对待你想交心的人，你才有可能收获对方的真心。
我希望当自己老来问到自己这一辈子活的怎样的时候，我的答案是yes。如果没有好好的谈过一场恋爱，没有好好的追求过自己的理想，那还谈什么人生呢？
去做自己喜欢的事，而不是别人都喜欢的事。去做自己认为对的事，而不是别人都认为对的事。
