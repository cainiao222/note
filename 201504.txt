* 2015/04
** 2015/04/01
*** LadybugSimpleGrab LadybugCap
** 2015/04/02
*** 如何理解递归？递归的正确理解方式绝对不是将特定的输入带入到函数里面，然后观察函数是怎么一步步得到结果这种简单的迭代式的思维方式的。正确的方式应该是使用数学归纳法式的理解方式，假设函数对于情况n是正确的，看函数对于情况n+1是否依然正确，如果答案是肯定的，那么这个函数对于所有的情况就都是正确的。
*** 原来数学归纳法是朴素递归思想的体现，这一如此重要的方法论在以前学习数学归纳法的时候我怎么没有意识到呢！
*** 其递归的核心同数学归纳法的核心一样，是找到特定情况下问题的解，然后在根据这个解推导出对于一般情况下问题的解。同样的，递归的难点同数学归纳法的难点也一样，关键在于如何由当前输入得到下一个输入，也就是迭代器。
*** 其实以前学习数学归纳法是有一个错误的观念——数学归纳法只能用于证明命题，而不能用于得到问题的解。这是一个极度非常错误的观念。数学归纳法的真正作用绝对不在于证明命题这种小儿科的东西，而在于用它来得到问题的解。求解问题永远比已经解决了问题，然后看这个解是否正确这种事情来得重要。必然的，使用数学归纳法来解决问题与使用它来证明问题的思路是存在差异的。证明问题的核心难点在于对n+1个输入进行规约与化简，得到将这个输入带入结果的形式。其实在知道了n中输入的结果以后，解出n+1种输入的答案要简单很多，并不需要进行复杂的规约化简，只需要带入新的输入就可以了，这是非常简单的思维方式，并不存在类似于证问题那样的难点。
*** 迭代的是人，递归的是神——L.Peter Deutsch。为什么这么说呢？神是从来不会考虑解决一个问题需要多少资源的，他关心的只是这个问题能不能简单的得到答案，也就是说——神是只关注结果，不关注过程的，所需要的资源总是可以通过时间来得到解决，因为技术总是在发展，速度总是会越来越快。
*** 其实生活中碰到的绝大多数问题，都可以用递归来解决，而且用递归解决起来比用迭代解决起来要简单得多。
*** 凭空想具有极大的灵活性，但同时也有容易走神的缺陷，中间成果无法保存造成无法回溯改进的缺陷，所以它适合于迸出灵感，并不适合于将某个问题思考的清楚。要想将一个问题思考清楚，得靠记录，我的这个日志就是起这个作用，也许我根本都不会回头过去看自己以前写过什么，但其实这个东西的价值在于写的时候那个帮助思考的过程，虽然慢点，但却很容易把某个概念透彻的理解的。
*** 如何使用递归来解决问题呢？你需要把问题切分成有限小的子问题，这些子问题依然是原来的问题，只不过规模和解决方法比原问题简单了很多，然后在有限的步骤内解决一个子问题，其他问题依靠这个子问题继续求解就得到了问题的所有解了。
*** 封装的意义在于减少重复，如果因为封装造成了新的重复，那么这种封装不要也罢！
** 2015/04/03
*** 编程上不能偷懒，你偷懒通常躲不过测试人员，他们反馈过来你就需要比你不偷懒做更多的事情。
** 2015/04/07
*** 函数式编程的缺陷在于——忽视了赋值操作，忽视了数据结构的重要性，片面的喜欢使用纯函数来表达本来不纯的东西，结果导致了对内存资源的随意滥用，拖慢了效率。
** 2015/04/08
*** hpp也有hpp自己的缺陷——无法使用全局变量与全局函数，它只适合于封装类，并不适合于封装满是全局的变量与全局函数的工具代码。如果你真要那么做，那么强行将本来全局的东西禁锢在类里面会使得代码变得非常奇怪，影响编程思路的表达。与之对应的，使用.h与.cpp虽然多了一个文件，但确实能够使得代码能够以更加灵活的形式来进行组织，该怎么写就怎么写，不要让工具限制你的代码，要让你的代码来控制工具。
*** 类是什么？函数与数据的封装？这种说法不错，但没有回答到关键点上。类实际上主要起的作用是函数的封装。类封装函数，给函数一个public,private的标识，使得函数不再杂乱无章的分布在全局的命名空间里面，开始有了树形结构的影子，是一个巨大的进步。而封装数据，是一个应该尽可能的少用的特性，因为这样会使得函数的原子性丢失，从而失去可重用性。即使在有的时候有些变量必须被很多函数说共享，也应该把这几个函数给单独拿出来封装在一个尽可能小的类里面，使得这种丢失的影响被降到最低。
*** 实际上，递归的本质就是状态累积。我们生活中所碰到的绝大多数问题都可以通过状态累积的方式得以解决。比如表达式求值（包括算术表达式与list表达式），这绝对是非常非常常见的问题，绝大多数的问题实际上都是表达式求值，比如xml、json数据处理、文件处理等。甚至还有我最近做的数据格式检查，其本质也是一个数据累积的过程。
*** 循环的层数不能很多，两层都不行，一旦出现了大于等于两层的情况，就代表你要将内层循环抽象成函数了。
** 2015/04/09
*** 其实lisp的表达能力之所以这么强，不是因为它采用了函数式编程，很大的一部分原因是它采用了统一的数据结构以及访问这种数据结构的通用接口，甚至连代码也是使用的这种数据结构。这种统一的数据结构的强大威力在于——它使得我们能以统一的方式处理所有的东西，甚至包括代码，从而彻底省去了编码与解码以及接口熟悉工作，不再有数据类型，不再有各种千奇百怪的接口，不再有各种沉重的学习负担。使得我们能够真正的关注与义务的处理而不是学习接口。实际上仔细思考我们的编程工作就会发现，学习接口实际上占据了我们编程的绝大部分时间。总结一下，统一的数据结构以及统一的数据访问接口，是lisp真正强大的根源。我们经常说数据封装，数据封装，确实，封装可以使我们改变数据结构，带来特定接口函数的效率提升，但其实也会给使用接口函数的函数带来效率的麻烦，因为别人不知道接口函数的实现方式，也就很难有效地使用这些接口函数。在这种情况下，暴露数据接口的实现反而能够提高效率。统一的数据结构，所带来的恐怖表达能力是很多语言都望尘莫及的。
*** 实际上，实现变参在c++里面还是非常容易的，只需要自己操作调用栈就行，c语言说提供的va_list，va_start,va_end就是用来做这一类工作的，但是这个东西用起来非常难用而且难以理解，还不如直接自己操作调用栈来得方便。方法是直接将需要变参的函数的参数设置成...，然后另外定义个整数，然后自己来移动指针就可以了。
*** 模板的意义就在于它可以让你写能够处理很多类型数据的函数而并不需要这些类型有丝毫的关联关系，这就比使用类继承具有了更低的耦合性。只需要参数个数一致，不管什么类型都可以传递到对应的函数里面。同时，变参模板的出现则更加使得连参数的个数都能够改变了。
*** list表达式中括号的出现其实就是为了表达作用域的概念，正式因为有了括号才使得list的数据从此有了层次之分，不再为简单的一维结构，编程了树形结构。由于我们所生活的世界本质上就是一个树形结构，所以能够非常方便地对它进行建模解决问题。
*** 前缀表示法使得这种语言统一了函数调用与表达式求值的形式，所有的东西都变成了S-表达式的求值，使得这门语言得以用非常少的元素就表达出了非常复杂的编程，而且空前灵活。可以说，括号是list表达能力如此强的第二法宝。
*** lisp其实可能最初的想法非常容易，就是统一所有数据结构，然后用这种数据结构来进行运算，可能最初的设想就是一个字符串，然后cons,car,cdr对这个字符串进行构造与遍历，然后发现这种结构不能够表达复杂的世界，渐渐的发展，从而变成了七个基本运算符号的。实际上lisp的基础是数据，而操作数据实际上只需要这三个运算符就足够了，但lisp不能仅仅用来表示数据，它还要用来计算，因而才出现了其它几个元素atom,quoto,eq,cond。
*** 一个句子不能太长，太长就意味着有太多的修饰限定词来修饰主谓宾，这样非常容易淹没主谓宾，这样的结果就是当别人很快的看了一遍以后根本不能很好的理解这句话的意思，还需要仔细斟酌去掉修饰词才能搞清楚句子的意思。这与语言水平无关，根本就来源于修饰的滥用，要注意避免。
*** c++的宏并不支持变参，它只能读取到第一个参数，对后面的参数就无法识别了。
*** 编程行业发展才短短几十年，还远远达不到发达的程度。有很多重复的，垃圾的东西充斥在我们周围，更气人的是这些东西有些还颇为流行，曾经被捧得居高无比，比如继承，比如面向对象，比如cobra等等，这些东西基本都可以解决问题，但采用不同的方式解决起问题的难度可能千差万别，要清楚地了解自己手中的工具，才能保证使用过程中不出现错误。
*** 实际上更好的编程方法是面向闭包而不应该是面向对象，面向闭包比面向对象更加的先进。闭包实际上弥补了纯函数式编程的缺陷，使得函数能够定义和使用一些变量，这些变量将于函数一同存在，影响函数的功能，从而在很多时候能够简化函数式编程。函数式编程配合闭包确实是编程的利器。
*** 闭包非常类似于类但又不是类。闭包是有数据的行为，类是有行为的数据。一个是数据，一个是行为，是数据就意味着必须先创建，才能使用；行为就意味着必须要创建就能实现行为。相比之下，首先，使用闭包更加的简单直接而且没有副作用，不会像类一样调用结束后类对象依然存在。
*** 当你接口不变，但是不停的修改实现的时候测试确实非常有必要，只有足够的测试才能够保证每次修改后的代码是正确的，没有引入新的bug。如果这种情况频繁出现，你就要考虑写测试用例了。
** 2015/04/10
*** 编程时，注意力不要总是放在代码写了什么，很多时候还要想想对应的生成了那些汇编代码，因为机器最终执行的还是汇编代码。有些时候，虽然代码写的也许有点麻烦，但其实生成的汇编代码也许很简单。这两者虽然多数时候复杂度是相对应的，但有时候却并不是一样的。典型的例子就是递归、指针运算。当然还有其他的，只有懂点汇编的只是才能灵活的运用自己手头的编程语言写出最高效率的代码。
*** 记录式思维是很容易被人忽略的宝库。记录式思维既有纯人脑思维的灵活，又有纯用笔思维的平稳。是一种非常牛逼的思维方式，绝大多数的问题用这种思维方式都能很快得到解答。
*** 同编程一样，文学也总是有无穷无尽的东西需要人去探索。很多的创作技巧，很多的表达手段，确实也是一个非常需要追求的领域，值得我们花费一生的时间去探索。
*** 去修改原有的对象有的时候真的不如去创造一个对象。
*** 我们总是希望去发明一种通用的编程语言，却不知道这实际上根本就是一个悖论。因为一个东西越是通用，发明起来的复杂度就会越大。最终为了解决所有的问题，必然会导致复杂度大大超越问题本身的复杂度，这样使用这种语言来解决这种问题的意义就会变得越来越小，还不如用其他的方法来解决这个问题。这就是造物主的聪明之处，他精心设计了很多悖论，解决了一个问题，同时又会出现另外的问题，然后他们又去解决新的问题，就这样永远没有终点。他们其实不明白其实一开始，他们就在解决一个错误的问题，这个问题是永远不可能解决的，特别是用所谓通用的方法。真正正确的方法其实是放弃通用的方法的天真想法，针对特定的问题去设计一个领域语言DSL，然后用这种语言来解决特定的问题。
*** 其实绝大多数的问题，都可以用程序语言与解释器的原理解决。也就是采用从前到后扫描，然后分情况递归的方法来解决。这种方法的特点是，多数情况下，只需要遍历一次就可以解决问题。这样就远比用各种各样高级的工具，为了完成一个问题需要把很多事重复地做好多遍来得简单容易的多。
*** 编程是一个既有入，又有出的平衡问题，不能只有入，没有出。要把握好入与出的关系，时刻保持代码质量的稳定。
*** 在自动上传的云盘上安装绿色软件所带来的好处也许是不可估量的。通过将软件安装在云盘上，可以轻松同步软件的所有设置，再也不用依赖软件公司提供的专门保存某类数据的接口了，轻松解决了一切同步问题，同时大大降低了被软降公司窃取资料的风险。还有重装系统时将变得无比轻松，因为再也不需要安装乱七八糟的软件以至于拖慢系统的速度了，云盘里面都有了。还有将快捷方式也保存在云盘，软件启动将变得无比简单。真正在云端上的系统在短期内还是先不了，但在云盘上的系统确实非常容易实现的。
*** 原来维持数据的同步是如此的重要，我们编程中总是因为数据格式的不统一、不同步而浪费了太多的时间。所谓的解析数据，其实就是这种浪费，数据根本不需要解析。完全避开数据解析有很多方法，一种是通过云盘，一种就是完全统一的数据接口。后者实现起来太难，所以比较靠谱的还是前者。云盘使得某种格式的数据只需要对应的程序来解析，并不需要其它程序的干涉，从而使得问题根本不再需要解决。
*** 程序与数据本来就应该是一起的，很多时候我们喜欢将程序与数据分开存储。其实应该意识到——程序本身也是数据，而且是跟它所处理的数据精密相关的数据，应该把他们放在一起，强行为了节省一点空间就将程序与数据分开存放是非常不合理的。但也不是说每份数据都需要放程序，一份数据只需要存放一份程序就够了，不管数据有多大都是这样。
*** 为了处理一种格式的数据而引入另一种格式的数据在很多时候是并不明智，虽然一般情况下这种新数据的格式会比原数据的格式简单，但新数据依然需要被管理，所以未必是好的解决办法。
** 2015/04/11
*** 部落冲突常见流派以及注意点：
1、石猪跳：适合女王在中心，中心除连弩火力稀疏（一般就是防空比较多）的情况。先灭援兵，再在女王一侧下兵，靠女王将兵引进阵型中心，跳进女王身边，然后同时下猪，掩护石法，再让猪跳进中心，配狂暴，拿下。
2、球猪：适合的阵型跟石猪跳一样。一般22球22猪，先用球灭掉三面，然后放野猪直冲中心，下狂暴，下双王over。
3、石法：适合大本不是在中心，有点靠外的情况，从靠外的那个角冲，一般两星没问题。
** 2015/04/13
*** 流计算模式的核心是延迟计算。不要一开始就把所有的数据都给计算出来，而是只在这个数据真正需要使用的时候再去计算，这样能够省掉很多多余的计算，节省时间与空间。而使用类封装可以达到类似的效果，通过将初始状态与得到下一状态的方法进行封装，可以按需取用结果，实现延迟计算。
*** c语言运算符的优先级和结合性也许是一个非常失败的设计。因为运算符太多，即使是最有经验的程序员经常会忘记，由于忘记优先级而导致用错，错误难以发现，即使记得优先级也要反复验证，代码难以看懂和修改。程序员总是会为了这种细枝末节的小事而浪费大量的时间，而不是集中精力于实现业务逻辑上，是非常不划算的，还不如使用统一使用括号，一层括号里面只允许出现一个运算符，这样就避免了缺陷，大大改善了设计。
*** 程序语言出现的最初，所有人都不懂怎样设计一门语言。但现实的需求却如此迫切，他们只能仓促上阵，有一些非常蹩脚的语言能进行编程，然后遗留下来了大量的代码。这些代码虽然久经修改，没有啥大的bug，却由于语言的垃圾设计导致很多难以看懂，难以修改。程序员经常在这些垃圾中纠结，有些人坚持了下来，成为了这么语言的大师，能够有各种各样的奇淫巧计避免这些缺陷而引以为豪。他们已经习惯了这门语言，甚至不认为那是设计的缺陷，而嘲笑那些犯下类似错误的人不懂这门语言。而另外一些人选择了放弃这门语言，另外开宗立派，发明新的语言，以求避免这些错误，这些人才是真正的开拓者，真正看清了编程的程序员。
*** 在某些特定的程序里面，IO可能会严重影响性能，比如比较两个文件夹的文件名与文件大小的问题，如果在循环内层多读取几次文件的大小，就会造成函数的性能严重低下，要充分利用已经获得的数据，尽可能地避开文件大小比较的操作。
*** linux的管道操作实际上也是流计算模式的一种使用方式。先枚举每一个输入（find、cat），然后过滤输入（grep），只取所需要处理的输入(awk)，再map对这些输入进行一些操作，最后sum得到结果(awk)。
*** 流计算模式是一种非常重要的模式，解释器实际上也是使用的流计算模式，因为流计算模式实际上代表了一种解决事情的通用方法。
** 2015/04/14
*** 提供一种方式，让用户能够基于这种方式只有的组合函数，从而实现强大的功能，这是一种非常恐怖的能力。各种小工具的本质也是函数，提供函数的只有组合非常方便与强大。出了要提供函数调用接口意外，为函数提供一个运行环境，也可以说是作用域也是非常的必要的。
*** 如何实现closure？其实非常简单，调用函数时不要只是简简单单地调用函数的执行代码，而是在调用函数之前先恢复函数的调用环境，然后再调用执行代码；在函数执行的过程中，可以修改并保存这个环境。其实就是将函数看成是具体的执行代码以及函数外部那一层区域局部变量的总和就可以了。
*** 闭包实际上是脱胎于面向对象与面向函数的一种高级的基本程序单元。实际上编程本没有面向对象与面向函数的区分，直接面向闭包就好了。它既有面向对象保存状态的能力，也有了面向函数一步到位的调用能力。不要小看普通函数一步调用的能力，这使得你能够在一句话里面将函数调用串联起来，实现函数式编程。而不是像使用对象一样要先用一句话声明出一个对象实体，然后再使用这个实体来调用对象。
*** 使用面向函数写出的程序是流式结构，使用面向对象写出的函数是瀑布型的结构。流式的结构用比较少的状态量，而且状态量的作用域一般也比较小，比较容易拆分到不同的机器上去运行，实现递归也比较的容易，能够比较轻易的就表达出比较复杂的算法。而瀑布式的结构由于大量使用到了状态量，虽然有时能够提升代码的效率，但状态量的随意使用使得代码难以维护，难以拆分，也难以优化。
*** emacs lisp的optinal参数也许是一个非常糟糕的设计，别人不翻阅文档的情况下根本不知道哪个参数表示的是什么意思，还不如直接使用key argument，虽然多写了几个字，但带来的好处是代码清晰，一看就懂。
*** 如何设计一门编程语言？其实很简单，只要设计出基本的计算结构与计算规则，在配合几个控制结构控制什么时候怎么计算并允许他们互相嵌套，一门语言就设计完毕了。
*** 编程里面的很多概念与机制如果你总是纠结于字面意义上的理解，那么理解起来必然非常困难，费时费力。如果你尝试着从机制实现的角度去理解这些东西，通常就非常好理解了。比如：闭包，emacs里面的kill，ring，buffer等。而且从实现机制的角度去思考可以很容易的彻底掌握工具的设计与局限，以及如何改进这个设计等东西。
*** lisp没有关键字的概念，出了六个基本的算符以外，其他的要么是函数要么是宏，函数用来实现方法，宏用来实现控制结构，控制求值规则。
*** 浅谈emacs的设计。emacs不过是先用c实现了lisp，然后又用lisp做了个编辑器而已。其内核是lisp，因而自动拥有了lisp的诸多优点，包括所有函数都是随时可用的，可以修改可以重写，由此也带来了非常高德灵活性与拓展性。实际上，不使用lisp，使用其他的repl式的语言，像ruby,python，也可以很容易的发明出一个这种语言来。非常像为了实现一个编辑器，先实现了一个DSL，然后用这个DSL来实现编辑器。由于DSL前期的某些基础设计，因而这个东西得以摆脱通用编程语言的限制，拥有一些对特定领域非常好用的优势。
*** 继承的缺陷在于它对类提出了太高的要求，一个类中不能有多余的代码，一旦有而且被其他类继承的时候其他类里面就很有可能会出现非常奇怪的方法。其实继承出现的最初目的不过是为了减少重复代码而已，它也确实可以部分完成它的使命，减少重复代码，特别是重复的功能代码。但他要求类里面不会出现多余的代码部分这在实际中太难以做到了，这就使得这一特性成为了一个非常不美观的解决方案。使用它非常容易出现各种问题。c++允许继承甚至允许多继承，这个设计决策提供了非常好的灵活性，可以让程序员去比较自由的构建系统，但这同时也使得这门语言太容易被误用，写出非常糟糕的代码，可以说是一个非常失败的决策。现在很多的高级语言，像java，c#，一开始就禁止了多重继承，是很明智的，但他们允许继承这一点也许依然是不太明智。
*** 实际上编程语言中，为什么要出现各种各样乱七八糟的机制像类、接口、继承、函数等等，无非是为了减少代码重复，同样的功能只需要由一个代码块去实现。
*** c#实际上跟c++差不多，它只是在c++的基础上对c++进行了很多细化，以前用c++编写的代码存在很多不清晰不明确的地方。比如难以直接看出一个方法是public的还是private的（将public、private与方法的写在一起），难以确定一个基类中的public方法在子类中是否还有用（统一使用public继承），难以区分接口跟普通基类（interface），难以区分是重写的方法还是普通方法（virtual，override），无法实现类方法间的委托（这个在c++0x中已经通过function与bind解决了，c#的解决方案是delegate关键字），无法将一个很大的类拆分到几个文件中去实现（partial，这个设计也许有问题）,无法给类提供一些附加的说明性信息（Attribute,这个设计很奇怪，复杂化了语言，用处有限，很有可能是个失败的设计），去掉了c++中的鸡肋的宏。总体来说，c++整体的设计存在很多很多的问题，c#解决了部分，还是略好于c++的。
*** 类继承是直接继承了方法的声明与实现，接口继承是直接继承了接口的声明，但是缺乏一种只继承实现的机制来实现有时候只需要继承实现的情况，这时候mix-in因运而生，它使得我们能够更好的表达自己真正想继承的东西的机会，从而补齐了继承的短板。
** 2015/04/15
*** c#语言并没有进行重大的机制创新。它只是在c/c++的基础上进行了下重新设计，对c/c++的很多不合理的地方进行了些许改进，它只是重新实现了一门基本的c/c++然后在此基础上对这门语言的语法解析器进行了一些改进，支持更多规则，避免c/c++中的一些鸡肋规则等。
*** 泛型只是抽象化类型的一种机制，它使得程序员能够写出适应于各种类型的代码，而这一切都是在编译器决定的，并没有运行时的效率损失，但会延长编译时间。它只是一种技术，一种想法，所以自然既可以用在类上，也可以用在方法上，还可以用在接口上，结构体上，委托上等等等等。但不管它用在哪里，它的本质是对其作用的实体声明一个占位符，以后可以使用各种类型来将这个泛型对象生成正确的汇编代码。
*** 一旦你看到有一个地方需要频繁使用“switch...case...再加上枚举”来针对不同的类型进行不同的处理时就要有所警觉了——你实际上只需要传递一个处理方法，却额外的加入了枚举，加入了switch...case...来将这个方法通过枚举来进行传递，这样就绕了几道弯子来实现目的，这样不仅写出了很多多余的代码，而且一旦增加新的类型，还需要修改原来的代码，是非常不明智的。正确的方法是使用委托，直接传递方法就可以了。那么现在来重新思考一下，到底什么时候使用委托呢？当你获得了一个数据并要对它进行处理，但又不确定怎么处理或者想以后再确定处理方法的时候就要使用委托了，典型的例子就是事件机制。委托可以使你写程序时先只写一部分，非常适合于搭程序框架。更为灵活强大的是，委托可以相加减，一个东西可以绑定多个委托，是一种非常强大的抽象机制。
*** c#中委托实际上是一个类，可以像使用其他类一样来使用委托。委托是c#语言的巨大创新，正是因为有了委托，c#得以使用一种更加优雅的方式组织代码，非常方便。
*** MVC模式将程序逻辑、显示以及这两者之间的交互给分离开来，这种分类方式是有自己的适应范围的，并不是什么时候都适用，只能说在多数情况下还是适用的。真正的模式适用方式是这样的，如果你需要频繁改动显示界面，显示方式的话你需要将显示给抽象出来，如果程序逻辑需要经常修改的话你需要将逻辑给单独抽象出来，如果是逻辑跟显示之间的控制需要经常修改的话就需要将控制给抽象出来。其他的模型抽象方法也是这样，比如常见的三层架构。数据一层，业务一层，显示一层，之所以要这么分都是因为这些东西需要单独变化，如果不变化或很少变化的话，不分层反而是最合适的方式，实现起来又快，效率又高，还容易看懂。
*** 模型的使用并不是别人都这么用你就应该这么用，你要根据经常变化的部分把这一部分给抽象出来，才能充分发挥模型的威力，更快更好的开发代码。
*** 其实真正牛逼的模型是自己根据项目的实际情况将真正需要变化的部分给抽象出来，不要纠结于MVC,三层架构，五层架构等这些别人针对特定情况抽象出的模型，这些只会限制住你自己的思想。真正强大的模型是根据自己当前项目的需要把经常需要变化的部分抽象出来，不要拘泥于显示，控制，逻辑等这些东西，仅仅就是将经常变化的部分抽象出来，这些部分可能也许就是一个经常变化，但又没有被大众所发现的偏门东西你一样可以将这一部分给提出来，这样渐渐的你就得到了针对你自己具体问题的模型了。
*** 重剑无锋，大巧不工。真正牛逼的人是根本不会使用各种主流的工具，规则等等的，他们都是随时信手拈来，自己针对具体的问题创造出一个新模型出来的。
*** c#中，delegate实际上是一个类，而event实际上是一个delegate类的对象
** 2015/04/16
*** c++由于要兼容c，所以很多c语言的设计缺陷也不得不继承过来。比如宏，c++里面无用的struct关键字。它只是在c的基础上添加了面向对象，类。但他很多地方设计的很糟糕，很多地方设计的让人难以理解，比如多重继承，没有接口，子类的virtual可写可不写，函数声明的参数名可写可不写，new出的对象后面的括号可写可不写等等。
*** c#中event关键字的出现有两个作用。一是为了弥补委托有时候造成的不太优美的代码写法，还有一个就是提出一个新的概念来帮助人们理解代码。实际上不用event关键字只需要使用delegate照样能够实现event的功能，这种针对关键字设计缺陷而额外多出来修补缺陷的关键字，虽然说引入了额外的复杂性，但确实能够使代码优美不少。
*** 一切都是对象，一个对象的状态发生变化（成员函数调用）会引起另一个对象的状态发生变化（引起另一个对象的函数调用），这就是委托的核心。委托就像是胶水一样，将一组对象粘连在一起，一个对象发生变化其关联的一组对象状态都会发生改变。而用户所需要做的仅仅就是在消息的源头设置一个event对象，在需要变化的对象上面设置一个event对象对应的函数，然后一点event对象发生调用，这个调用就会被绑定到所有其关联的对象上进行调用，其实质就是一个通过函数进行对象通信的一种机制。
*** 事件与委托可以说是c#所进行的最伟大的创新了。它将各个类对象之间的通信给抽象了出来，特别是简化了函数的参数匹配问题，使得程序员可以随意组装通信接口，程序员再也不需要自己去额外写函数的参数匹配了（虽然自己去写参数匹配有时候更加的灵活好用），这些繁琐又没技术含量的小事本来就应该交给编译器去做，大大解放了程序员的思想，简化了开发流程。
*** 委托还是一种程序分解策略，将一个庞大的对象分解到很多个不同的对象上面去，然后通过委托进行对象通信，共同完成功能的实现，从此，程序的分解又多了一种抽象手段。
*** 委托实际上是规范了通信的接口，通过将函数的声明提前写出来，规定只能按照这种参数形式进行函数调用，使得人们能够很容易的实现函数通信，再也没有写像c++那样的void指针，然后各种类型转换这种非常丑的代码了。
*** 实际上程序组件间的通信是一门语言所不能忽略的部分。
    传统的通信方法是先将代码分成很多函数，然后通过函数调用来完成组件通信。可以单纯根据函数调用来通信有些时候很麻烦，无法保持状态，很容易使得编程陷入困境，参数过长，程序难写，效率也低。
    正式为了解决这一问题，面向对象这一编程思维出现了，面向对象将对象视作了一等公民，函数只能被封装在对象之类来实现功能。这种思维解决了函数式编程所遇到的困难，同时又兼容了传统的函数式编程的写法，因此一时风头无两，很快席卷了大半江山。
    但面向对象编程也有自己的问题，最大的问题就是它虽然兼容函数式编程，可是却大大复杂化了函数式编程，因为多出来的对象外壳大大打乱了程序的流式处理结构，使得原来函数式编程中很多非常简单的问题变得复杂无比。
    所以，很多时候这两种编程思想是个相反的关系，这个问题用这种思想解决好，用另一个思想却解决不好。两种方法各有侧重，各有优劣。那么，是不是说根据自己的实际问题选择最适合问题的编程方式就可以了呢？
    答案却是否定的。殊不知，这两种思想从本质上来说都是在解决同一个问题啊，既然是同一个问题，那么为什么要壁垒分明，强行给自己划分出一个编程的方法限制，来限制自己解决这个问题呢？应该有一种正确的模型来解决这个问题，而不是两种不同的模型来进行二选一。
    这种模型就是闭包，实际上，面向函数编程本身就是正确的模型，只不过传统的模型有些小的问题，需要经过很小的一点修改，加入状态就好了。面向对象试图解决这个问题，却引入了新的问题，把原来应该占据根本地位的函数给本末倒置了。
    面向闭包编程重新拿回了函数的根本地位，编程的基本单元不应该只是一个个简简单单的执行单元（函数），而是执行单元与这个单元所处的环境的一个整体，这个单元随时可以被调用，改变自己所处的环境，而不是还需要先实例化一个对象，然后再去调用。只有基于闭包的编程方法才是真正正确的方法，才能真正最好的解决我们所碰到的各种编程问题。
*** 面向闭包编程可以让我们站在更高的抽象角度看待问题，专注于问题是怎么被一步步解决的，专注于处理流程，数据都是可以见见加上来的，流程依然不变。而不是像面向对象一样，我们需要先关心需要哪些东西来交互解决问题，这种强行加在实际问题上的枷锁，大大束缚了我们的思维，使得我们考虑问题总是像在隔山打牛，隔靴搔痒一样。
** 2015/04/17
*** 反射实际上很简单，不过就是一种以程序为数据，处理程序的工具而已。c++所使用的动态加载dll的方法从本质上就是反射。反射能够从已经写好的程序中解析出程序信息，进行处理，这个处理不仅限于管理程序中，还可以调用所需要反射的dll，这就是反射的厉害之处。
*** 在编程中，真正重要的不是规则的实现，而是规则的指定。只要规则被合理的指定，其实实现起来是非常容易的事。典型的例子就是各种标准委员会。
*** 聚类算法——聚类算法是一种分类算法，实际上就叫分类算法还更好理解一些，没必要为了听上去高端就造出这么稀奇古怪的一个词来。
*** 很多时候我们为了听上去比较酷，为了在原来简单概念的基础上造出一点不同而喜欢造出一些很稀奇古怪的符号去表达新概念，这是非常有害的。这种凭空造出的词只会给初学者造成门槛，典型的例子就是数学。数学最喜欢搞出一堆乱七八糟的符号，所以数学那么难学，其实数学不过是把一些基本的问题探讨的比较深入而已罢了，很多时候并没有必要造出一个新的词来表达，那样只会带来不必要的麻烦。
*** k-means聚类算法实际上就是求出k个点，使得这k个点可以代表一大堆数据的一个最小方差组合，这一方法很简单，完全可以使用穷举法算出来。
*** 编程其实就是数学啊，更精确一点编程实际上就是排列组合啊，初期用穷举就可以解决很多很多的问题呢，可是如果你换个思维模式，你就可能找到简单的多的思考模式，更快的解决问题。每一种思考模式对应一种算法，算法的不同可能导致非常大的难度差异。
*** 所有问题都有输入与输出，对于大多数问题，我们能够很简单的由输入直接得到输出。但也有很多比较难的问题，我们不能由输入一步到位的得到输出，需要有很多中间的输出与输入才能得到最终的输出。在这种时候，我们需要先对这个问题先建立一个求解模型，把这个问题变成很多问题的串联，然后一个个的去解决问题，最终问题就得到了解决，而这个求解模型对问题的匹配度就是一个非常考验问题解决者水平的事了。好的问题解决者总是能找到解决问题的最简单模型，然后去解决问题，而坏的问题解决者则通常无法解决这个问题或是即使解决了也是采用类似蛮力穷举的方法解决，非常费时费力。多数时候我们的模型无法处理所有的情况，只是在大多数情况下适用，所以要不断的完善，不断的改进模型，增加特殊情况下的考量，模型才会越来越好。
*** 面向对象的三大特征——继承、封装和多态。其中封装是必须的，继承和多态则是设计非常糟糕的东西，特别是继承。一旦使用了继承，代码的可重用性就会大大降低，必须连着基类代码一起移植才能继续使用，这在类稍微简单点的时候还好，但稍微一复杂，重用的复杂度就差不多都要赶上重写了。而且一旦使用了继承，当基类的实现需要在几个类之间来回切换的时候非常的痛苦。除非是几个类都写在同一个文件中而且基类不需要切换实现的情况下，否则绝对不要用继承。
*** c++，特别是c++98确实存在非常多的设计缺陷，我自己的感觉还是非常准确的，c++11终于对部分缺陷进行了改进，使得这门语言变得不再那么丑了。但c++11只是在原有设计缺陷的基础上增加了很多新特性来规避原有设计的问题，却没有正视问题，把原来设计缺陷的地方重新设计、改正错误的勇气。这一点来说c++做的还是不够。
*** c++11新出的override关键字能够明确的指出函数是重写的父类的方法，以便当父类的方法发生改变的时候能够给予子类一些提示，还是比较有用的，但这种改变还不如直接规定子类想要重写父类的方法必须写出virtual关键字呢，哎，设计缺陷。。。
*** 语言的设计者应该将语言设计的尽可能的避免使用它的程序员犯错，尽可能地多做一些事来让程序员尽可能的将精力放在实现程序的逻辑上，不应该引入很多得充满地雷，让程序员不得不在实现业务逻辑与保证代码正确之间来回考量。
** 2015/04/19
*** 计算机的思维与人的思维还是存在很大不同的。最大的差别就是人计算循环是非常花费时间的，所以人一般会习惯性的避开循环，但是这对于计算机来说确实相当简单的。所以人使用计算机来解决问题的思维，需要有意识的规避这个思维短板，多使用循环，才能用计算机更好的解决问题，穷举法就是这种做法的典型。
*** 实际上我们生活中碰到的绝大多数问题都可以使用解释器的思维模式来解决。解释器思维模式实际上是一种分情况讨论的思维模式，复杂的问题基本都逃不开这种思维模式，针对每个子问题，然后很可能需要用到其它问题分支的解，此时就会用到递归。这种方式基本上能解决所有问题，非常有用。
*** 枚举，过滤，计算，合并。这种计算模型虽然在计算机中做起来不大高效，却是我们思考很多问题说常用的方法，非常适合于初期的算法，至于后期的优化，有了初期的算法，优化起来也不会太麻烦。
*** 编程中除了执行代码意外，执行环境（又叫上下文Context）也非常重要，这是闭包的两要素。实际上，函数参数就是最常见的指定代码执行环境的方法，但是很多时候执行环境是重复的，单用参数执行会导致参数无线延长而且不同情况参数差不多，此时，把经常重复的参数提取到方法外的一个环境中，同时又维持边界就显得非常有必要了，闭包、对象从本质上都是这种方法的一种尝试。
** 2015/04/20
*** 设计通用弹性框架的精髓在哪里？精髓在于首先你得抽象出你所面对的问题的通用计算模型，也就是“先做什么，再做什么，最后做什么”这些步骤。然后尽可能的将这些步骤设计成为数组，重要的还要保存成文件，使得用户能够针对每一步做修修补补的工作，加一件任务，减一件任务，覆盖意见任务等等等。总之，使得一切都变得可修改，这才是最重要的事，emacs之所以如此灵活，正是因为它做到了这一点。
*** 编程理论与编程实力应该齐头并进，任何一方领先于另一方太多都会导致迷惑不解，无法继续进步。纸上谈兵最大的问题就是理论超前于实践太远，自然只能学成一个半吊子，无法成长为大师。现在我的编程理论已经大大领先于编程能力，急需靠编程实践来加深我对理论的理解与认识。靠编程来验证理论，而不是为了完成任务。
*** 文件系统中的“..”得到父文件夹属性的设定确实是一个非常精妙的设计，它使得对文件系统树的遍历不止能够向下进行，而且能够向上进行。在任何时刻，我们都能很容易的得到整个文件系统，而这一切只需要很少的步数就可以完成。
*** 针对所有人的人工智能也许没有任何意义，因为所以人的思维综合起来本质上是一个比较混乱的个体，虽然面对很多逻辑性的问题这种东西通常能非常快的得出答案，但在这种情况下的人工智能就成为了一个普通的搜索引擎而已。而针对个人的人工智能，从一个人或是有限的几个人的日常生活中获取的数据进行训练则有可能将锻造出非常适合于这几个人的人工智能来，未来这可能是一个发展方向。更为惊人的事，这种事情不再是大公司的专利，一个人完全开发出针对自己的这种训练模型，然后让这个模型来帮助自己完成很多很多的事，非常的具有诱惑力。
** 2015/04/21
*** 当碰到困难时，不同的人有不同的解法。有的人试图逃避困难，有的人试图绕着弯子解决困难，有的人迎难而上直面困难。每种方法都能消灭问题，每种方式都各自有自己的利弊，没有完美的答案，也没有最好的答案。但选择不同的方式去消灭问题最后会得到不同的结果。逃避问题的会在自己的小领域活的很好，绕弯子解决问题的也许能够成为领头羊，带领一群人去解决问题。而直面问题的会成为领域精英。
*** 在编程中，语义的清晰表达应该是第一位的，不能为了所谓的效率就写出很多难以让人读懂的代码，即使实在代码优化的后期。程序的第一用户是自己，应该对自己友好，而不是对最终的程序友好，这种事应该让编译器去做，如果编译器做不到，那是编译器做的不够。
*** 何为猜疑链？猜疑链其实也不复杂，就是别人说的每句话都有可能是错误的，伪造的，基于这些做出的任何决策都是不靠谱的。如果这个东西带有很大的威胁性，比如技术爆炸，那么最好的方法就是将这个东西摧毁。这就是三体的理论基础。
*** 经典牛顿力学三大定律通过简简单单的三句话就创造出了一个力学世界。实际上这也可以看做是一门DSL，一种编程语言，一种计算模型。这也从侧面说明了，只要公理定义得当，确实可以通过简简单单的几句话创造出纷繁的世界。
*** 计算机的抽象 接口继承 实现继承
*** 我其实并不关注与于编程实现的哪一方面的问题，我所关注的是编程本身以及程序的设计，编程方面的各种技术，函数式编程，闭包式编程，计算模型，各种语言的设计，各种工具软件的设计、优缺点等。我觉得只要搞懂了这些，利用这些东西来解决实际的具体哪一方面的问题都轻而易举的。总之，技术与设计是我所关注的问题而且也将一直持续下去。我不会局限于哪一种语言，不会局限于这一种技术现在是不是热门，我只会选择我自己觉得好的技术，绝对不让大众代替我去思考，做一个有想法，有主见，有追求的人。
*** 我不习惯大量的使用类，相比之下，我更喜欢使用函数，类只是辅助。我只是偶尔用用类的特性来简化我的代码，但并不会大量使用。
*** 过犹不及，追求设计的通用性到达一定的程度后反而会使得程序写起来难以看懂，还不如自己用普通的思维重写了。所以要把握好一个度，并不是越通用越好。
*** 语言会朝着抽象层次更高的方向发展，因为高的抽象层次意味着高的表达能力，也意味着更少的代码能够表达更多的东西，也就意味着可以请更少的人，节省成本才是最重要的。要知道，人力成本永远比硬件成本高很多。
** 2015/04/27
*** 信号中继器的原理——信号中继器的本质就是在信号最后可以识别的地方识别出信号，然后进行重新发送的过程，可以理解为给信号补充了能量，所以需要耗电。中继器的概念非常重要，因为首先它真实的模拟了客观世界，引入了耗损的概念；其次它在现实世界中引入了无限的概念，使得信号可以无限远距离传输，这一点跟计算机世界中的流非常相似，其本质都是存储方法而不是存储数据。
    还有电力的中继器，电力的中继器的本质就不是补充能量了，而是转化能量形式，让能量以一种最小耗费的形式传输，然后在终端重新将能量转化为便于使用的形式。它则是一种无限衰减的能量形式，只能减小这种衰减，所以电力不能传输的太远。实际上电力中继器非常类似于有损压缩，只要损失不大，依然可以使用。
*** 谈谈计算机世界与现实世界的区别，计算机世界是比较理想化的世界，是没有衰减的世界。传输一个数据无论这个数据传输多远，不同线程，不同进程，不同程序，不同计算机等等，原来的数据是几，最后的数据还是几，它是绝对不会变化的。而现实世界不同，现实世界中，数据传输是会变化的，一个数据如果传输得过远，就不再是原来的数据了，因为信号会衰减，但有了中继器，就不存在这一问题了，现实世界得以完全用计算机来模拟。
*** 数学实际上也是一门编程语言，只不过它并不是一门通用的编程语言，而是一门DSL。它一般会定义几个简单的符号，然后用这些符号去处理某一类型的数据会处理得很好，这种情况对命名空间的需求不高。而通用的计算机编程语言则不一样，它要处理各种各样的问题，没有命名空间完全没有办法工作。所以，完全用数学来进行通用的编程是非常困难的，即使实现出来了，也不然是丑陋无比的。但数学依然会有非常多的概念可以被通用编程语言借鉴，比如复合函数，求和技法，微积分等等。
*** 什么叫做函数式语言里面的“纯函数”，只需要定义一个函数时不要留下“状态”，不要使用全局变量，这样定义出来的函数就是纯函数的，对于任何给定的输入必然会得到同样的输出，并不是说使用了赋值这个函数就不是“纯函数”了，比如：
int f(int x) 
{
    int y = 0;
    int z = 0;
    y = 2 * x;
    z = y + 1;
    return z / 3;
}    
这个函数就是一个纯函数。
*** 谦虚也许并不总是一种美德。谦虚很多时候总是试图隐藏自己的能力，特别是在口头上。谦虚的人总是试图通过实际的行动来证明自己的能力，而不是口头上。但现实世界是如果你习惯于隐藏自己的能力，那么与这种能力相关的施展机会很难落到你头上，因为别人并不知道你的能力。所以，谦虚很多时候是要不得的，他会阻碍你能力的的提高。
*** 实际上创新也许并不需要，我们只需要最简单方便的设计就可以了，并不需要各种花哨的东西，解决了一点问题却引入了更多的问题。忘记历史就是毁灭未来，只需要从历史中总结经验教训，规避过往设计中所存在的问题，这就是最好的设计。语言实际上还真是抄来的，并不是创新来的，但是抄只能是抄优秀的东西，而不能瞎抄。
*** TODO 强类型系统与弱类型系统 类型到底代表着什么
** 2015/04/28
*** 递归为什么这么重要？因为递归是一种通用的处理数据集的手段，我们生活中所遇到的绝大多数问题，其本质上都是数据集处理。小到查找排序，大到状态机，解释器，程序语言，其本质都是同种数据的一个集合，我们需要对每一项数据进行解释，执行一个动作，然后一个个处理到最后。按照这个模型，可以构造出一整个世界，典型的例子就是lisp。
*** 为了对数据集一个个地进行处理，我们需要四个要素，首先要能搞构造数据，其次感知数据，然后是要能够遍历数据，最后要能够对数据进行分情况处理。这就是对现实世界的一个抽象，可以表达出非常非常多的东西。当然，我们还可以有自己的其他抽象，
*** 记忆法又称为表格法，适用于当计算情况很少但计算次数很多的情况，在特征明显并且每个计算都很复杂的时候能够大大提升程序的性能。其核心思想非常简单，就是用表格记录下几种情况的输入与输出，当需要计算的时候，首先在表格里面查找下是否存在这一情况的结果，如果有就直接取结果，如果没有才进行计算。配合高效的表格，确实能够大大提升程序性能，同时代码的改动量也非常小。
*** 表格记忆技术的核心是存储下调用的函数以及对应的输入，每当函数与输入都一样的时候就直接取用结果，并不重复计算。
*** 学习一个知识的时候往往先从最简单的学起，先对知识的整体了解一个大概，然后再深入学习，将每一个细节都吃透，这样学习起来是最有效率的。相反，一开始就试图将明白一个非常复杂的东西，每次讲一点，尽管可以讲得非常细，但由于会让人看不到整体，学习效果依然是会很差的。比如讲解实现一个解释器，如果你一上来就是针对所有不同的情况一一阐述实现，那么无论你将的多么详尽，学习效果必然是很差的。相反，如果你先从计算器出发，先实现一个简单的计算器，然后再在计算器的基础上进行拓展，渐渐的推导出解释器，这样就会让人比较容易理解和接受。
*** 搜索引擎的基础就是倒排索引，只要掌握了这个，就可以轻松的做出一个简单的搜索引擎。
*** 聚类算法是数据挖掘的基础，因为做数据挖掘的第一步是分类，其实聚类算法有点类似于倒排索引，都是首先对数据进行分类，然后再根据类型查找数据。
** 2015/04/30
*** 翻译外文资料特别是计算机书籍有个非常重大的问题，就是虽然描述性的话语可以翻译，但对应的程序代码却无法翻译，这样就会导致程序与描述无法同步，造成理解上的困难，这个问题可以推广到其他的方面，所以翻译总是会丢失非常多的东西，能读懂原著尽量看原著。
*** 我们常说构成程序的基本构件是顺序、选择、循环，其实这是不对的，程序的基本构件应该是顺序、选择和递归，循环的表达能力很多时候是不如递归的，把循环作为递归的基础是非常不合适的。
*** 在使用一个函数时如果你不知道函数在后面所做的事那么写出来的新函数的效率很可能是有问题的，只有清楚的知道自己所使用的工具函数到底在后面干了点什么才能从整体上进行资源的宏观调配，避免重复运算，达到最高效率。
