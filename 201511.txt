* 2015/11
** 2015/11/02
*** 其实静态类型语言与动态类型语言的差别并没有那么的大，静态类型语言不过是使用其自身定义的类型系统简化了部分类型判断以及根据类型自动处理，但同时它也使得某些事变得复杂了，最主要的就是抽象能力，静态类型无法将类型当做函数来进行递归、嵌套，也无法将函数当做类型来定义与使用。虽然也可以通过各种变通的奇淫巧计来达到目的，但总归没有原生的来的简单直接。
** 2015/11/03
*** 会使用调试工具来调试没什么，牛逼的是会使用代码调试。
*** 几个人协作开发的时候，除了要讨论好调用接口外，还应该提前说好一些公共模块，主要有以下几点：
	1、错误日志。记录在哪里，如何记录。
	2、信息存储。如何将程序的信息保存出去，如何读入，存放在哪里。
	3、测试。是否需要建立统一的测试工程，如何进行测试。这其中包括测试代码、模拟器这些东西。
	4、代码风格。采用驼峰还是匈牙利，是否在成员变量前加"m_"等。
*** 不断思考之后的好处是思考能力的极大提升，往往很多东西，只要你说出了一个大概，我就能大致在脑中推演出这是个什么东西，可能会有哪些特性、哪些问题，在以往模型中的问题在这个东西中应该怎么解决。
*** 音乐这东西，过度关注音染，关注还原是没有什么意义的，无论是HIFI还是监听，只要听着够爽就行了。
** 2015/11/04
*** javascript是一种面向对象但不是类的语言，如果你的类一般只会有一个对象，那么这两者不会有很大差别，但如果你需要由一个类产生很多对象，差别就大了。
*** 语言本身也不过是个提供基本抽象能力的工具而已，Java这门语言提供的抽象能力太有限了，随便做个东西都要不停的绕弯。
*** 尽可能的使用些比较基础的东西来理解高级词汇，一些高级词汇本来含义就不清晰，再用它来理解其他词汇只会越描越黑。
*** TODO 关于面向对象，不同的语言有自己不同的理解，传统的面向对象语言将对象放在类中，使用类来生成对象，而js走了另外一条路，将对象放在函数中，使用函数来生成对象，跳过了类，这是个非常有趣的设计。当然这个设计也会产生几个问题。
	1、首先就是对象间成员的共享问题，就是类中的static变量与成员函数这些共享的东西。js的解决方案是原型prototype，使用它来解决static变量与成员函数的共享。
	2、还有一个就是嵌套函数的参数传递。
*** c#的委托本质上就是一种对象间解耦的手段，正式因为有了它，我们才不需要将动作的执行者植入动作的发出者内通过函数调用来传递参数，动作的发出者与执行者互相不需要知道对方的存在，只需要在第三方或执行者内建立一个关联就可以将动作的发出与执行连接起来，非常方便。
*** hittest碰撞检测，用来检测两个geometry之间有没有相交、包含等关系。
** 2015/11/05
*** c#的select实际上是做了一个元素置换，将一个可枚举的集合中的所有元素进行一个操作，替换成其他元素，更为牛逼的是――――可以置换为其他的类型。
*** c#的select其实就是map，where其实就是filter,还有一些用来进行计算的简单函数比如count、min、max、sum等，这些其实可以覆盖我们编程过程中的绝大多数情况。
*** 其实lambda表达式非常符合人类的思维模型，先输入一个东西，再输出一个东西，特别是在其写法为"args => retValue"这种形式时。
*** c#的"split分割模型、join合并模型"这两个模型非常好的表述了我们生活中常见的分割合并逻辑，非常好用。
*** map表达映射，filter表达过滤，accmulate表达累积、calculator表示计算，实际上编程的本质无外乎这几种而已。这一点实际上从sql查询上是最好看出来的，为啥sql查询只提供了select、where、order...by...、asc/desc这几个简单的关键字。
*** 一个合理的数据接口应该是什么样子的，可以参考数据库sql语句的设计，照着设计基本就不会差。
*** c#中所谓的装箱与拆箱，实际上就是将值类型与引用类型互相转换时所进行的一个转化而已，没什么特别的。执行装箱操作时不可避免的要在堆上申请内存空间，并将堆栈上的值类型数据复制到申请的堆内存空间上，这肯定是要消耗内存和cpu资源的。拆箱操作的执行过程和装箱操作过程正好相反，是将存储在堆上的引用类型值转换为值类型并给值类型变量。装箱操作和拆箱操作是要额外耗费cpu和内存资源的，所以在c# 2.0之后引入了泛型来减少装箱操作和拆箱操作消耗。其实装箱与拆箱的叫法还是比较形象的，一听就懂。
** 2015/11/06
*** 如果不读书、不住校，人生就缺少了一个一群人集体生活在一起这个非常重要的体验，而且这个体验很难在以后得到弥补，成为一生的遗憾。
*** c#中两个完全不相关的类型是可以通过实现隐式类型转换运算符来进行随意转换的，在转换的实现代码中根据已有类型来产生一个新的类型并返回就可以实现这种转换了。
** 2015/11/09
*** 使用command设计模式来实现将调用者与被调用者解耦。实际上就是使用一个command类来代表被调用者，暂代具体实现类去实现其功能，虽然这个类暂时可能是功能不完整的，但由于它的存在，我们可以先专注于实现调用者的逻辑，以后再去实现被调用者逻辑。
*** 设计模式只是简简单单的提出了几种常常碰到的情况，然后把解决这种情况的类设计答案给了出来，却并没有深入探究为什么要这样。也许它的提出者并不知道为什么要这样，仅仅是只知道可以这样。所以，我们需要学习设计模式，因为它比较全面的提出了面向类设计过程中可以碰到的复杂问题。但我们不能靠死记硬背去记忆答案，而是要自己记住这些问题，自己推演出答案，这样能够锻炼我们的思维，只有这样，我们才能更加有效的解决问题。
*** TODO 编辑器里面的选择如何实现，遍历？
*** 类的实现与使用是两个不同的维度，如果从类的实现中去看这个类很费解的话，可以考虑从类的使用中去看这个类，两者互相结合，看起来才会比较容易懂。
*** 管理这一行，必须只能由一个人来发号施令，否则被管理的人可以把责任推给另一个管理者，而管理者之间互不清楚布置的任务，所以也就没法评断谁的错误了。
*** lineString.erase(lineString.find_last_not_of("\n\r\t")+1);
** 2015/11/10
*** 实际上一个完整的类所要完成的事无非就是要完成读、写与修改，其中，读写是辅助，修改用来完成功能。为了完成读写，很可能还会有遍历。即使这个类的函数名字再怎么变，这些是始终不会变的。比如在最简单的情况下，这个类会直接设计成read、exec、write，复杂点的比如在类渲染的情况下，这个情况会变成add、remove与draw。
*** 写完一个函数之后，一定要单步跑的看一下，不能只简简单单的看结果就断定这个函数没有问题，一定要把函数的所有执行路径都跑一遍，看每一步的执行结果是否正常。
*** 使用大对象的时候要非常小心，要尽可能的使用引用，不要直接赋值，否则构造开销会很大，有的时候也许就是这一点点的差别效率差别天差地远。
** 2015/11/11
*** 对象ID是一个非常重要的东西，如果对象没有ID，就无法判断两个对象为同一个对象，即使它们的属性值一样，也有可能不是同一个对象。
*** 管理者如果不是技术出生，碰到问题就只会采取加班的方式，以为跟流水线的工人一样，而由于IT行业的特殊性，加班所起的作用非常有限，反而会失民心，一旦失去民心，这个团队的瓦解就不远了。
*** 使用成员变量进行读写分离，是一个非常重要的技巧，往大了说，读写分离是一个非常重要的技巧，实现读写分离的手段之一是使用成员变量，当然还有很多其他的方式，比如，使用文件其实也是一个在程序间实现读写分离的手段，这个程序写入，其他程序读取，实现读写分离。
*** 要实现函数并发非常简单，再函数里面不要使用全局变量，包括类变量，否则就只能实现类并发。如果类里面再使用了全局变量，那么这个类的并发就会非常困难。
*** 变量实际上在某种程度上也可以称之为一个ID，只不过这个ID不止可以由数字组成，还可以由字母、下划线等各种其他的字符组成。
** 2015/11/12
*** lambda其实是一个非常牛逼的抽象，是它使得我们可以在函数里面嵌套函数，从而把几个函数写在一起，使用函数来作为field与function的容器，来代替类，这样我们就可以使用纯函数编程，而不用受类的制约了。这种思想其实和js非常接近，js就是使用函数来装函数的。
*** 不管是面向对象、函数式、闭包式还是其他牛逼闪闪的编程模式，要始终记得，在编程里面，抽象还是最重要的，使用哪种模式能够最简单的将所需要的功能提取出来到处使用，就应该使用哪种模式，不应该拘泥于某一种。
*** 最简单的抽象方法就是写最笨的代码，写的多了才能发现哪些是需要被抽象的。
*** 类型系统其实违背了一个非常重要的原则――――所见即所得，一个整数，也许你看着它像整数，但实际上它还有可能是浮点数，字符串等，你需要小心翼翼的处理类型问题以避免出错，这需要很多的额外代码。
** 2015/11/14
*** 使用sublime有个很重要的技巧，你想知道某个动作所调用的是哪个函数，很简单，直接使用宏录制，然后打开所录制的宏，查看里面的代码，就可以知道了，它录制的宏还是非常容易读懂的。
*** emacs的拓展性之所以这么牛逼，几乎完全得益与它最初设计时一个非常简单的理念――――实时拓展（“real-time display which can be extented by the user while it is running”）。正是因为这个理念，我们才能
	1、在emacs初，加载自己的各种各样的配置。
	2、在emacs启动后，我们可以切换各种mode，用来改变我们编辑器的行为。
	3、如果对某个mode不满意，自己可以再对这个mode进行一些修改(自己写elisp脚本),然后直接使用eval-buffer加到我们的编辑器里面，完全不用重启软件。
	其实emacs正是因为这个设计理念，才被设计成了现在这个样子。
	要想做到即时拓展，程序必须要有一个接口来读入你想修改的配置文件，然后解析这个配置文件，然后将解析出来的东西作用于软件，这就必须要求软件要有一个后台程序来解析这个配置文件来将新的配置装载进程序，这就要求一个后台的脚本语言解析器来解析读入的脚本，Richard Stallman选择了lisp来干这个事，其实完全可以用其他的脚本语言（当然要如果当时要有的话）。然后需要将解析出来的配置作用于程序，就必须在程序上留出接口，这些接口越多越好，当然为了设计的简单，基本的用其他语言实现的接口最好越少越好，后期不易修改。其实emacs很早就意识到了将程序分层后台与前端的重要性，然后使用一个后台来随时读入新的配置，实现了程序的随时可配，这些设计其实联系当时的背景并不难想到，不要把它神化了。其实emacs要是现在来设计的话，lisp有可能会使用python，这种编辑器现在已经有了，这就是sublime。
*** 使用英文进行思维。
*** 如何实现编辑器里面的宏录制，实际上就是把撤销队列中抽取一部分给保存起来就可以了，以后运行宏时按照顺序重做一遍就实现了宏，一般这个宏里面可以看出大致的函数调用，因此有助于设置快捷键。
** 2015/11/15
*** 静态（词法）作用域vs动态作用于(lexical scoping vs dynamic scoping)
	惰性求值(lazy evaluation)
	柯里化(currying)
*** sublime与emacs，前者的配置文件是配置数据，而后者的配置文件是编程语言，这两者的区别是前者只是数据，相当于只有函数参数，而后者不止有函数参数，还有函数，显然，后者的拓展性更强点。虽然严格来说，这两者都留出了接口可以被其他语言拓展，不过与使用自己的语言相比，使用其他语言来进行拓展是有数据格式转化的开销的，始终无法达到直接用自己的语言来进行拓展那样达到原汁原味的效果。
*** 大浪淘沙，能够留的下来的都是金子，今天的互联网，已经结束了最开始的混乱，正在渐渐的走向成熟，不再是前几年那样只要闭着眼睛投钱进来就能赚钱的了，要想活着，必须要有点真本事才行。
*** 一个程序调用其他程序来实现功能，往往能很好的实现输入，将输入数据传送给另一个程序来处理，很多程序都预留了这方面的接口（其实就是通过命令行参数），但要实现处理结果回传就比较困难了，一般常见的方式也不过是重定向原程序的输出到本程序。
*** 其实编程，无非就名词跟动词两个东西而已，名词表示数据，动词表示操作，表现在语言上面就是――――名词是数据，是类，动词是函数，是操作，使用配置文件来修改程序的行为常见的模式是使用数据，但其实可以在数据中增加操作，形成语言，emacs就是这么做的。
*** 对于emacs，我已经接触了太多的时间，已经如此熟悉，因为熟悉，所以习惯性的忽略，不再去思考它设计中的精妙之处，其实emacs总是有很多东西值得我去学习的，最关键的是――――我不能放弃对emacs进行思考的习惯。
*** 写程序实际上就是在写抽象语法树(AST),而且写的程序越多，编程的风格会变得越像在写它，不管是写流程图，还是写程序，要变得心中有AST，这样写出的程序才逻辑清晰，不易出错。
** 2015/11/19
*** 其实客户端代码就像是一个杂货铺，所有的乱七八糟的代码都可以往这里塞，因为修改容易，在测试期完全可以这样做，当你试验后觉得那段代码可以被复用以后就可以把这段代码提出来了，提出来的代码就最好少改了，因为修改复杂。
** 2015/11/27
*** js的抽象能力确实很无敌，BOM、DOM这些东西通通都是js的对象，此外还有Math、Regex等等这些对象通通都可以为我所用，实现很牛逼的功能。js对象本身自成树结构，对象的成员自动可以使用本类的其他方法。
** 2015/11/29
*** 其实在公司，要想持续保持地位稳固，你必须得靠真本事才行，这个本事多半是指技术，偶尔的取巧虽然能带来一时的利益，但一旦失势，倒的也会很快，你不许有你自己的过人之处，才能始终走在前面。这就要求我们不断学习新的技术，不断的充实自己的头脑。真正能够始终走在前面的，只有靠技术，编程的技术以及管理的技术，如果整天什么都不敢，把精力都放在娱乐扯犊子上面，那当然无法继续提升。
*** 终身学习是非常有必要的，一旦不再学习，就必然会很快被跟你能力差不多且更勤奋好学的人超越。而且学要学有用的知识，每次学习决定学习一个新领域的知识前要想想这个东西会拓展你哪方面的能力，对你整体的能力提升有什么帮助，不能不假思索的胡乱学习。在学校里，学校可以靠开课保证我们技能树的完整，毕业了可就没有这东西了，只能靠我们自己去思考。自己的技能树自己要把关好，点好关键的点。
*** 要想程序运行飞快，只要把握好一个原则――――尽量减少程序运行时需要做的事就可以了。可以将部分工作提到运行前，如果真要在运行时去做的话做一次之后应该讲运行结果给保存起来以便下次直接取。实际上，多数时候要想优化时间需要付出一点空间的代价，但多数时候这是值得的。
*** 实际上我们一般编写的程序中空间利用率低的惊人，编程过程中有意识的提高空间利用率能够提高我们程序的质量，不管是对时间效率还是空间效率都有好处。
*** 我的牛逼不用别人认可，即使所有的人都不，我自己也要认可我自己，怀疑自己才是最大的失败。
*** 未来随着软件结构越来越复杂，面向功能的那种需求应该会越来越少，更多的可能会是面向API的需求，实际上API的个数不要太多，太过会很难使用，最好的API向外提供的接口API一般没有几个函数，却能处理各种情况。
*** 声明式编程而不是命令式编程。
